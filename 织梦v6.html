<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#8B7CF7">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="織夢">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="description" content="AI互動小說閱讀器 - 創建你的專屬故事">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%238B7CF7' width='100' height='100' rx='20'/><text x='50' y='65' text-anchor='middle' fill='white' font-size='50'>織</text></svg>">
  <title>織夢 - AI互動小說閱讀器 v6.1</title>
  <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.min.js"></script>
  <style>
:root{--primary:#8B7CF7;--primary-light:#A89CFF;--primary-dark:#6B5CE7;--bg-primary:#0F0F1A;--bg-secondary:#1A1A2E;--bg-tertiary:#252540;--bg-card:#1E1E32;--text-primary:#E5E7EB;--text-secondary:#9CA3AF;--text-tertiary:#6B7280;--divider:#2D2D44;--success:#10B981;--warning:#F59E0B;--error:#EF4444;--info:#3B82F6;--font-size:16px;--line-height:1.6;--paragraph-spacing:1em}
[data-theme="light"]{--primary:#6B5CE7;--primary-light:#8B7CF7;--bg-primary:#FFFFFF;--bg-secondary:#F5F5F7;--bg-tertiary:#E8E8ED;--bg-card:#FFFFFF;--text-primary:#1A1A2E;--text-secondary:#6B7280;--text-tertiary:#9CA3AF;--divider:#E5E7EB}
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:-apple-system,BlinkMacSystemFont,"PingFang SC",sans-serif;font-size:16px;background:#000;color:var(--text-primary);height:100vh;height:100dvh;overflow:hidden;user-select:none}
.app{width:100%;max-width:420px;height:100vh;height:100dvh;margin:0 auto;display:flex;flex-direction:column;background:var(--bg-primary);position:relative;box-shadow:0 0 50px rgba(139,124,247,0.2);overflow:hidden}
@media(min-width:421px) and (min-height:901px){.app{max-height:900px;margin-top:calc((100vh - 900px)/2);border-radius:40px}}
.app.fullscreen{max-width:100%;max-height:100%;border-radius:0;margin:0}
.status-bar{height:44px;background:var(--bg-secondary);display:flex;justify-content:space-between;align-items:center;padding:0 20px;font-size:14px;font-weight:500;flex-shrink:0}
.views{flex:1;position:relative;overflow:hidden}
.view{position:absolute;inset:0;display:flex;flex-direction:column;overflow:hidden;opacity:0;transform:translateX(100%);transition:all .3s ease;pointer-events:none;background:var(--bg-primary)}
.view.active{opacity:1;transform:translateX(0);pointer-events:auto;z-index:1}
.view.out{transform:translateX(-30%);opacity:.5;z-index:0}
.nav{height:52px;background:var(--bg-secondary);display:flex;justify-content:space-between;align-items:center;padding:0 16px;border-bottom:1px solid var(--divider);flex-shrink:0}
.nav-back{color:var(--primary);font-size:24px;cursor:pointer;padding:8px;margin:-8px}
.nav-title{font-size:17px;font-weight:600;flex:1;text-align:center}
.nav-right{display:flex;gap:4px}
.nav-btn{width:36px;height:36px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:18px;color:var(--text-secondary);border-radius:8px;transition:all .2s}
.nav-btn:hover{color:var(--primary);background:rgba(139,124,247,.1)}
.list-nav{height:52px;background:var(--bg-secondary);display:flex;justify-content:space-between;align-items:center;padding:0 16px;border-bottom:1px solid var(--divider);flex-shrink:0}
.list-nav-title{font-size:22px;font-weight:700;background:linear-gradient(135deg,var(--primary),var(--primary-light));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.search-bar{padding:12px 16px;background:var(--bg-secondary);flex-shrink:0}
.search-wrap{background:var(--bg-tertiary);border-radius:10px;padding:10px 14px;display:flex;align-items:center;gap:10px}
.search-wrap:focus-within{box-shadow:0 0 0 2px var(--primary)}
.search-input{flex:1;border:none;background:transparent;font-size:15px;outline:none;color:var(--text-primary);-webkit-text-fill-color:var(--text-primary)}
.search-input::placeholder{color:var(--text-tertiary)}
.search-input:-webkit-autofill,.search-input:-webkit-autofill:hover,.search-input:-webkit-autofill:focus{-webkit-text-fill-color:var(--text-primary)!important;-webkit-box-shadow:0 0 0 1000px var(--bg-tertiary) inset!important;transition:background-color 5000s ease-in-out 0s}
.progress-wrap{padding:0 16px 8px;background:var(--bg-secondary);display:flex;align-items:center;gap:8px;flex-shrink:0}
.progress-bar{flex:1;height:4px;background:var(--bg-tertiary);border-radius:2px;overflow:hidden;cursor:pointer}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--primary-dark),var(--primary));border-radius:2px;transition:width .3s}
.progress-text{font-size:11px;color:var(--text-tertiary);min-width:32px}
.scroll{flex:1;overflow-y:auto;padding:12px 16px}
.scroll::-webkit-scrollbar{display:none}
.card{display:flex;padding:14px;background:var(--bg-card);border-radius:12px;margin-bottom:12px;cursor:pointer;transition:all .2s;position:relative;border:1px solid transparent}
.card-menu-btn{position:absolute;top:8px;right:8px;width:28px;height:28px;border-radius:50%;background:var(--bg-tertiary);display:flex;align-items:center;justify-content:center;font-size:16px;color:var(--text-secondary);opacity:0.7;transition:all .2s;z-index:2}
.card-menu-btn:hover{opacity:1;background:var(--primary);color:white}
.card:hover{transform:translateY(-2px);box-shadow:0 4px 20px rgba(139,124,247,.15)}
.card:active{transform:scale(.98)}
.card.pinned::before{content:'📌';position:absolute;top:-6px;left:-6px;font-size:16px}
.card.selected{border-color:var(--primary)}
.card-cover{width:56px;height:70px;border-radius:8px;margin-right:12px;flex-shrink:0;background:linear-gradient(135deg,var(--primary-dark),var(--primary));display:flex;align-items:center;justify-content:center;font-size:24px;background-size:cover;background-position:center;overflow:hidden;position:relative}
.card-cover img{width:100%;height:100%;object-fit:cover}
.card-cover .cover-emoji{font-size:24px}
.upload-btn{position:absolute;bottom:4px;right:4px;width:20px;height:20px;background:rgba(0,0,0,0.6);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:10px;cursor:pointer;opacity:0;transition:opacity 0.2s}
.card-cover:hover .upload-btn,.char-avatar:hover .upload-btn{opacity:1}
.content.has-bg{background-size:cover;background-position:center;background-attachment:fixed}
.content.has-bg::before{content:'';position:absolute;inset:0;background:rgba(15,15,26,0.85);z-index:0}
.content.has-bg .msg{position:relative;z-index:1}
.card-info{flex:1;min-width:0}
.card-header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:4px}
.card-title{font-size:15px;font-weight:600}
.card-time{font-size:11px;color:var(--text-tertiary)}
.card-preview{font-size:12px;color:var(--text-secondary);margin-bottom:6px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;line-height:1.4}
.card-meta{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.card-instruction{font-size:10px;color:var(--primary);background:rgba(139,124,247,.15);padding:2px 6px;border-radius:4px}
.card-stats{font-size:10px;color:var(--text-tertiary)}
.card-tags{display:flex;gap:4px;margin-top:4px}
.tag{font-size:9px;padding:2px 5px;border-radius:3px;background:var(--bg-tertiary);color:var(--text-secondary)}
.tab-bar{display:flex;background:var(--bg-secondary);border-top:1px solid var(--divider);padding:6px 0;padding-bottom:calc(6px + env(safe-area-inset-bottom, 0px));flex-shrink:0}
.tab-item{flex:1;display:flex;flex-direction:column;align-items:center;padding:4px 0;cursor:pointer}
.tab-item .tab-icon{font-size:20px;margin-bottom:2px;transition:transform .2s}
.tab-item .tab-label{font-size:10px;color:var(--text-tertiary)}
.tab-item.active .tab-icon{transform:scale(1.1)}
.tab-item.active .tab-label{color:var(--primary)}
.content{flex:1;overflow-y:auto;padding:16px;font-family:"Noto Serif SC",Georgia,serif;font-size:var(--font-size);line-height:var(--line-height);word-break:break-word;overflow-wrap:break-word}
.content::-webkit-scrollbar{display:none}
.content.sys{font-family:-apple-system,sans-serif;font-size:15px;line-height:1.5}
.content p{margin-bottom:16px;word-break:break-word;overflow-wrap:break-word}
.content strong{color:var(--primary-light)}
.content blockquote{border-left:3px solid var(--primary);padding-left:12px;margin:12px 0;color:var(--text-secondary);word-break:break-word;overflow-wrap:break-word}
.content pre{white-space:pre-wrap;word-break:break-word;overflow-wrap:break-word;background:var(--bg-tertiary);padding:12px;border-radius:8px;overflow-x:auto;max-width:100%}
.content code{word-break:break-all}
/* 小說閱讀式 UI */
.msg{margin-bottom:24px;word-break:break-word;overflow-wrap:break-word;max-width:100%}
.msg.user{margin:24px 0}
.msg-user-action{text-align:center;padding:16px 0}
.msg-user-action .action-divider{color:var(--primary);font-size:13px;margin-bottom:8px;display:flex;align-items:center;justify-content:center;gap:12px}
.msg-user-action .action-divider::before,.msg-user-action .action-divider::after{content:'';flex:1;max-width:60px;height:1px;background:linear-gradient(90deg,transparent,var(--primary),transparent)}
.msg-user-action .action-content{color:var(--primary-light);font-style:italic;font-size:calc(var(--font-size) * 0.95)}
.msg-ai-story{padding:0 4px}
.msg-ai-story p{text-indent:2em;margin-bottom:var(--paragraph-spacing)}
.msg-ai-story p:first-child{text-indent:0}
/* 改善選項列表顯示 */
.msg-ai-story br{display:block;content:'';margin-top:calc(var(--paragraph-spacing) * 0.5)}
.msg-ai-story ol,.msg-ai-story ul{margin:1em 0;padding-left:2em;text-indent:0}
.msg-ai-story li{margin-bottom:0.5em;text-indent:0}
/* 確保圈號選項正確換行 - 使用更精確的選擇器 */
.msg-ai-story{white-space:pre-line}
.msg-timestamp{text-align:center;font-size:11px;color:var(--text-tertiary);margin-top:12px}
.msg-floor{position:absolute;right:8px;top:8px;font-size:10px;color:var(--text-tertiary);font-family:sans-serif;opacity:0.6}
.msg-menu-btn{position:absolute;right:28px;top:6px;width:24px;height:24px;border-radius:6px;background:var(--bg-tertiary);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text-secondary);cursor:pointer;opacity:0.4;transition:opacity .2s;z-index:5}
.msg:hover .msg-menu-btn,.msg-menu-btn:focus,.msg-menu-btn:active{opacity:1}
.msg-menu-btn:active{background:var(--primary);color:white}
.msg-action-menu{position:fixed;background:var(--bg-card);border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.3);padding:6px;z-index:1002;min-width:120px}
.msg-action-item{display:flex;align-items:center;gap:8px;padding:10px 12px;border-radius:8px;font-size:14px;color:var(--text-primary);cursor:pointer;transition:background .2s}
.msg-action-item:hover{background:var(--bg-tertiary)}
.msg-action-item.danger{color:var(--error)}
.msg-action-item .icon{font-size:16px}
.msg{position:relative}
/* 重要記憶標記 */
.msg-important{background:linear-gradient(90deg,transparent,rgba(255,215,0,0.08),transparent);border-left:2px solid #FFD700;padding-left:12px}
.msg-important-badge{position:absolute;left:8px;top:8px;font-size:14px;animation:starPulse 2s infinite;z-index:3}
@keyframes starPulse{0%,100%{opacity:0.8;transform:scale(1)}50%{opacity:1;transform:scale(1.1)}}
/* Lorebook 樣式 */
.lore-trigger-toast{position:fixed;top:60px;left:50%;transform:translateX(-50%);background:rgba(139,124,247,0.95);color:white;padding:8px 16px;border-radius:20px;font-size:12px;z-index:1001;animation:slideDown .3s ease;display:flex;align-items:center;gap:6px}
@keyframes slideDown{from{opacity:0;transform:translateX(-50%) translateY(-10px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}
.lorebook-card{background:var(--bg-card);border-radius:12px;padding:14px;margin-bottom:12px;border-left:3px solid var(--primary)}
/* 財產資產樣式 */
.inventory-item{background:var(--bg-card);border-radius:12px;padding:12px;margin-bottom:10px;display:flex;align-items:center;gap:12px;position:relative}
.inventory-item-icon{font-size:28px;width:44px;height:44px;display:flex;align-items:center;justify-content:center;background:var(--bg-tertiary);border-radius:10px;flex-shrink:0}
.inventory-item-info{flex:1;min-width:0}
.inventory-item-name{font-weight:600;font-size:15px;color:var(--text-primary);display:flex;align-items:center;gap:6px}
.inventory-item-name .quantity{font-size:12px;color:var(--primary);font-weight:500}
.inventory-item-category{font-size:11px;color:var(--text-tertiary);margin-top:2px}
.inventory-item-desc{font-size:12px;color:var(--text-secondary);margin-top:4px;line-height:1.4}
.inventory-item-actions{display:flex;gap:6px}
.inventory-item-btn{padding:6px 10px;border-radius:6px;font-size:12px;border:none;cursor:pointer;background:var(--bg-tertiary);color:var(--text-secondary)}
/* 行程樣式 */
.schedule-item{background:var(--bg-card);border-radius:12px;padding:12px;margin-bottom:10px;position:relative;border-left:3px solid var(--text-tertiary)}
.schedule-item.pending{border-left-color:#f59e0b}
.schedule-item.in_progress{border-left-color:#3b82f6}
.schedule-item.completed{border-left-color:#10b981}
.schedule-item-header{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.schedule-item-status{font-size:16px}
.schedule-item-datetime{font-size:13px;color:var(--primary);font-weight:600}
.schedule-item-event{font-size:15px;font-weight:600;color:var(--text-primary);margin-bottom:4px}
.schedule-item-details{font-size:12px;color:var(--text-secondary);display:flex;flex-wrap:wrap;gap:8px}
.schedule-item-detail{display:flex;align-items:center;gap:4px}
.schedule-item-notes{font-size:12px;color:var(--text-tertiary);margin-top:6px;font-style:italic}
.schedule-item-actions{position:absolute;top:10px;right:10px;display:flex;gap:6px}
.schedule-item-btn{padding:6px 10px;border-radius:6px;font-size:12px;border:none;cursor:pointer;background:var(--bg-tertiary);color:var(--text-secondary)}
.schedule-item-btn:hover{background:var(--bg-hover)}
.schedule-item-btn.danger{color:var(--error)}
.schedule-item.has-lorebook::after{content:'🔮';position:absolute;bottom:8px;right:10px;font-size:12px}
.inventory-item-btn:hover{background:var(--bg-hover)}
.inventory-item-btn.danger{color:var(--error)}
.inventory-item.has-lorebook{border-left:3px solid var(--primary)}
/* 圖標選擇器 */
.icon-option{width:36px;height:36px;display:flex;align-items:center;justify-content:center;font-size:20px;background:var(--bg-tertiary);border-radius:8px;cursor:pointer;transition:all .2s}
.icon-option:hover,.icon-option.selected{background:var(--primary);transform:scale(1.1)}
.lorebook-card.disabled{opacity:0.5;border-left-color:var(--text-tertiary)}
.lorebook-card-header{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.lorebook-card-status{width:8px;height:8px;border-radius:50%;background:var(--success)}
.lorebook-card.disabled .lorebook-card-status{background:var(--text-tertiary)}
.lorebook-card-title{flex:1;font-size:14px;font-weight:600}
.lorebook-card-lock{font-size:12px}
.lorebook-card-triggers{font-size:12px;color:var(--text-secondary);margin-bottom:6px}
.lorebook-card-stats{font-size:11px;color:var(--text-tertiary);display:flex;gap:12px}
.lorebook-card-actions{display:flex;gap:8px;margin-top:10px}
.lorebook-condition{display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg-tertiary);border-radius:6px;margin-bottom:8px;flex-wrap:wrap}
.lorebook-condition select,.lorebook-condition input{padding:6px 8px;border:1px solid var(--divider);border-radius:4px;background:var(--bg-card);color:var(--text-primary);font-size:13px}
.lorebook-condition input[type="number"]{width:60px}
/* 玩家面板樣式 - 增強版 */
.player-panel{background:var(--bg-card);border-radius:16px;padding:16px;margin-bottom:16px;border:1px solid var(--divider)}
.player-panel-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
.player-panel-title{font-size:16px;font-weight:600;display:flex;align-items:center;gap:8px}
.player-panel-edit{font-size:12px;color:var(--primary);cursor:pointer}
/* 分組樣式 */
.player-group{margin-bottom:16px}
.player-group:last-child{margin-bottom:0}
.player-group-header{display:flex;align-items:center;gap:8px;margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--divider)}
.player-group-icon{font-size:16px}
.player-group-title{font-size:13px;font-weight:600;color:var(--text-secondary);text-transform:uppercase;letter-spacing:0.5px}
.player-group-toggle{margin-left:auto;font-size:12px;color:var(--text-tertiary);cursor:pointer;transition:transform .2s}
.player-group-toggle.collapsed{transform:rotate(-90deg)}
.player-group-content{overflow:hidden;transition:max-height .3s ease}
.player-group-content.collapsed{max-height:0!important}
/* 屬性網格 */
.player-stat-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.player-stat-grid.grid-3{grid-template-columns:repeat(3,1fr)}
.player-stat-item{background:var(--bg-tertiary);border-radius:12px;padding:12px;position:relative;overflow:hidden;transition:transform .2s,box-shadow .2s}
.player-stat-item:active{transform:scale(0.98)}
.player-stat-item::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;opacity:0.8}
.player-stat-item.color-red::before{background:linear-gradient(90deg,#EF4444,#F87171)}
.player-stat-item.color-orange::before{background:linear-gradient(90deg,#F59E0B,#FBBF24)}
.player-stat-item.color-yellow::before{background:linear-gradient(90deg,#EAB308,#FDE047)}
.player-stat-item.color-green::before{background:linear-gradient(90deg,#10B981,#34D399)}
.player-stat-item.color-blue::before{background:linear-gradient(90deg,#3B82F6,#60A5FA)}
.player-stat-item.color-purple::before{background:linear-gradient(90deg,#8B5CF6,#A78BFA)}
.player-stat-item.color-pink::before{background:linear-gradient(90deg,#EC4899,#F472B6)}
.player-stat-item.color-default::before{background:linear-gradient(90deg,var(--primary),var(--primary-light))}
.player-stat-label{font-size:11px;color:var(--text-tertiary);margin-bottom:4px;display:flex;align-items:center;gap:4px}
.player-stat-value{font-size:18px;font-weight:700;color:var(--text-primary);display:flex;align-items:baseline;gap:4px}
.player-stat-value .unit{font-size:12px;font-weight:400;color:var(--text-tertiary)}
.player-stat-value.positive{color:var(--success)}
.player-stat-value.negative{color:var(--error)}
/* 進度條動畫 */
.player-stat-bar{height:8px;background:var(--bg-primary);border-radius:4px;margin-top:8px;overflow:hidden;position:relative}
.player-stat-bar-fill{height:100%;border-radius:4px;transition:width .5s ease;position:relative}
.player-stat-bar-fill::after{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.3),transparent);animation:shimmer 2s infinite}
@keyframes shimmer{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}
.player-stat-bar-fill.health{background:linear-gradient(90deg,#10B981,#34D399)}
.player-stat-bar-fill.energy{background:linear-gradient(90deg,#F59E0B,#FBBF24)}
.player-stat-bar-fill.mood{background:linear-gradient(90deg,#EC4899,#F472B6)}
.player-stat-bar-fill.default{background:linear-gradient(90deg,var(--primary),var(--primary-light))}
/* 文字類型標籤 */
.player-stat-tag{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;background:var(--bg-primary);border-radius:20px;font-size:13px;font-weight:500;color:var(--text-primary)}
/* 屬性卡片（設置頁） */
.player-attr-card{background:var(--bg-tertiary);border-radius:10px;padding:12px;margin-bottom:8px;display:flex;align-items:center;gap:10px;border-left:3px solid var(--primary)}
.player-attr-icon{font-size:20px;width:32px;text-align:center}
.player-attr-info{flex:1}
.player-attr-name{font-size:13px;font-weight:500}
.player-attr-type{font-size:11px;color:var(--text-tertiary)}
.player-attr-group{font-size:10px;color:var(--primary);margin-top:2px}
/* AI同步按鈕 */
.player-sync-btn{width:100%;padding:12px;background:linear-gradient(135deg,var(--primary),var(--primary-light));color:white;border:none;border-radius:10px;font-size:14px;font-weight:500;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:8px;margin-top:12px;transition:opacity .2s,transform .2s}
.player-sync-btn:active{transform:scale(0.98)}
.player-sync-btn:disabled{opacity:0.6;cursor:not-allowed}
/* 分組選擇器 */
.group-selector{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
.group-chip{padding:6px 12px;background:var(--bg-tertiary);border-radius:16px;font-size:12px;cursor:pointer;transition:all .2s;border:1px solid transparent}
.group-chip:hover{background:var(--bg-primary)}
.group-chip.active{background:var(--primary);color:white;border-color:var(--primary)}
.time-div{display:flex;align-items:center;justify-content:center;margin:20px 0;color:var(--text-tertiary);font-size:13px;cursor:pointer}
.time-div::before,.time-div::after{content:'';flex:1;height:1px;background:var(--divider);margin:0 12px}
.typing{display:flex;align-items:center;gap:4px;padding:12px 0}
.typing-dot{width:8px;height:8px;background:var(--primary);border-radius:50%;animation:typing 1.4s infinite ease-in-out}
.typing-dot:nth-child(1){animation-delay:0s}
.typing-dot:nth-child(2){animation-delay:.2s}
.typing-dot:nth-child(3){animation-delay:.4s}
@keyframes typing{0%,60%,100%{transform:translateY(0);opacity:.4}30%{transform:translateY(-6px);opacity:1}}
@keyframes highlight{0%,100%{background:transparent}50%{background:rgba(139,124,247,0.3)}}
.typing-cursor{display:inline-block;width:2px;height:1em;background:var(--primary);margin-left:2px;animation:blink 1s infinite}
@keyframes blink{0%,50%{opacity:1}51%,100%{opacity:0}}
.quick-cmds{display:flex;gap:8px;padding:10px 16px;background:var(--bg-secondary);overflow-x:auto;border-top:1px solid var(--divider);flex-shrink:0}
.quick-cmds::-webkit-scrollbar{display:none}
.quick-cmd{padding:6px 14px;background:var(--bg-tertiary);border-radius:16px;font-size:13px;color:var(--text-secondary);white-space:nowrap;cursor:pointer;border:none;transition:all .2s}
.quick-cmd:hover{background:var(--primary);color:white}
.quick-cmd.add{background:transparent;border:1px dashed var(--text-tertiary);color:var(--text-tertiary)}
.quick-cmd-item{display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:8px}
.quick-cmd-item .drag-handle{cursor:grab;color:var(--text-tertiary);font-size:14px}
.quick-cmd-item .cmd-info{flex:1;min-width:0}
.quick-cmd-item .cmd-label{font-size:14px;font-weight:500;color:var(--text-primary)}
.quick-cmd-item .cmd-content{font-size:11px;color:var(--text-tertiary);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.quick-cmd-item .cmd-actions{display:flex;gap:6px}
.quick-cmd-item .cmd-actions button{padding:4px 8px;font-size:12px;border:none;border-radius:4px;cursor:pointer}
.quick-cmd-item .cmd-actions .edit-btn{background:var(--bg-secondary);color:var(--text-secondary)}
.quick-cmd-item .cmd-actions .del-btn{background:rgba(239,68,68,0.1);color:#ef4444}
.persona-bar{background:var(--bg-secondary);padding:8px 16px;display:flex;align-items:center;gap:8px;border-top:1px solid var(--divider);flex-shrink:0}
.persona-selector{flex:1;display:flex;align-items:center;gap:8px;padding:6px 12px;background:var(--bg-tertiary);border-radius:12px;cursor:pointer;transition:all .2s}
.persona-selector:hover{background:rgba(139,124,247,.1);box-shadow:0 0 0 1px var(--primary)}
.persona-avatar{font-size:18px}
.persona-info{flex:1;min-width:0}
.persona-label{font-size:11px;color:var(--text-tertiary)}
.persona-name{font-size:13px;color:var(--text-primary);font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.persona-dropdown{font-size:12px;color:var(--text-tertiary)}
.input-bar{background:var(--bg-secondary);padding:10px 16px;display:flex;align-items:flex-end;gap:10px;border-top:1px solid var(--divider);flex-shrink:0}
.input-wrap{flex:1;background:var(--bg-tertiary);border-radius:20px;min-height:40px;max-height:120px;display:flex;align-items:center;padding:0 16px}
.input-field{flex:1;border:none;background:transparent;padding:10px 0;font-size:15px;outline:none;color:var(--text-primary)}
.input-field::placeholder{color:var(--text-tertiary)}
.send-btn{width:40px;height:40px;background:var(--primary);border:none;border-radius:50%;color:white;font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s}
.send-btn:hover{background:var(--primary-light);transform:scale(1.05)}
.send-btn:disabled{background:var(--bg-tertiary);opacity:.5;cursor:not-allowed}
.lore-section{margin-bottom:16px}
.lore-header{display:flex;justify-content:space-between;align-items:center;padding:10px 0;cursor:pointer}
.lore-header-left{display:flex;align-items:center;gap:8px;font-size:15px;font-weight:600}
.lore-count{font-size:12px;color:var(--text-tertiary);font-weight:normal}
.lore-toggle{color:var(--text-tertiary);transition:transform .3s;font-size:12px}
.lore-toggle.collapsed{transform:rotate(-90deg)}
.lore-list{max-height:none;overflow:visible;transition:max-height .3s ease, opacity .3s ease}
.lore-list.collapsed{max-height:0;opacity:0;overflow:hidden}
.lore-item{display:flex;align-items:flex-start;padding:12px;background:var(--bg-card);border-radius:10px;margin-bottom:8px;cursor:pointer;position:relative}
.lore-actions{position:absolute;right:8px;top:50%;transform:translateY(-50%);display:flex;gap:8px;font-size:14px;opacity:0.6}
.lore-actions:hover{opacity:1}
.lore-item:hover{background:var(--bg-tertiary)}
.lore-checkbox{width:20px;height:20px;border:2px solid var(--text-tertiary);border-radius:4px;margin-right:12px;display:flex;align-items:center;justify-content:center;flex-shrink:0;cursor:pointer}
.lore-checkbox.checked{background:var(--primary);border-color:var(--primary)}
.lore-checkbox.checked::after{content:'✓';color:white;font-size:12px}
.lore-icon{width:36px;height:36px;border-radius:8px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-size:18px;flex-shrink:0}
.lore-icon.char{background:rgba(59,130,246,.2)}
.lore-icon.loc{background:rgba(16,185,129,.2)}
.lore-icon.item{background:rgba(249,115,22,.2)}
.lore-icon.set{background:rgba(168,85,247,.2)}
.lore-content{flex:1;min-width:0}
.lore-name{font-size:14px;font-weight:600;margin-bottom:2px;display:flex;align-items:center;gap:8px}
.lore-affection{font-size:11px}
.lore-affection.pos{color:var(--success)}
.lore-affection.neg{color:var(--error)}
.lore-desc{font-size:12px;color:var(--text-secondary);margin-bottom:4px}
.lore-status{font-size:11px;color:var(--text-tertiary)}
.timeline-current{background:var(--bg-card);padding:12px 16px;border-radius:10px;margin-bottom:20px;display:flex;align-items:center;gap:8px}
.timeline-label{font-size:13px;color:var(--text-secondary)}
.timeline-value{font-size:15px;font-weight:600;color:var(--primary)}
.timeline-groups{margin-top:12px}
.timeline-group{margin-bottom:12px;border:1px solid var(--divider);border-radius:10px;overflow:hidden}
.timeline-group.current{border-color:var(--primary);box-shadow:0 0 0 2px rgba(139,124,247,.15)}
.timeline-group-header{display:flex;align-items:center;gap:8px;padding:12px 14px;background:var(--bg-tertiary);cursor:pointer;transition:background .2s}
.timeline-group-header:hover{background:var(--bg-card)}
.timeline-group-arrow{font-size:10px;color:var(--text-tertiary);width:16px}
.timeline-group-date{font-size:14px;font-weight:600}
.timeline-group-count{font-size:12px;color:var(--text-tertiary)}
.timeline-group-current{font-size:11px;color:var(--primary);background:rgba(139,124,247,.15);padding:2px 8px;border-radius:10px}
.timeline-group-summary{flex:1;font-size:12px;color:var(--text-secondary);text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.timeline-group-content{padding:8px 14px 14px}
.timeline-item{position:relative;padding:10px 12px;margin-bottom:8px;background:var(--bg-secondary);border-radius:8px;border-left:3px solid var(--divider)}
.timeline-item.current{border-left-color:var(--primary);background:rgba(139,124,247,.08)}
.timeline-item-header{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.timeline-time{font-size:13px;font-weight:600}
.timeline-now{font-size:10px;color:white;background:var(--primary);padding:2px 6px;border-radius:4px}
.timeline-item-actions{margin-left:auto;display:flex;gap:6px;opacity:0.5;transition:opacity .2s}
.timeline-item:hover .timeline-item-actions{opacity:1}
.timeline-events{font-size:13px;color:var(--text-secondary)}
.timeline-event{display:flex;align-items:center;gap:6px;margin-bottom:4px}
.timeline-event-dot{width:4px;height:4px;background:var(--text-tertiary);border-radius:50%}
.timeline-summary{font-size:12px;color:var(--text-tertiary);margin-top:8px;padding-top:8px;border-top:1px dashed var(--divider);line-height:1.5}
.tabs-bar{display:flex;background:var(--bg-secondary);padding:0 16px;flex-shrink:0;border-bottom:1px solid var(--divider)}
.tab-btn{padding:12px 20px;font-size:14px;color:var(--text-secondary);cursor:pointer;border:none;border-bottom:2px solid transparent;background:none}
.tab-btn.active{color:var(--primary);border-bottom-color:var(--primary)}
.section-title{font-size:13px;color:var(--text-tertiary);padding:12px 0;display:flex;align-items:center;gap:8px}
.f-card{background:var(--bg-card);border-radius:10px;padding:14px;margin-bottom:10px;cursor:pointer;transition:transform .2s}
.f-card:hover{transform:translateX(4px)}
.f-card.warning{border-left:3px solid var(--warning)}
.f-card.resolved{opacity:.6}
.f-card-header{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.f-card-icon{font-size:14px}
.f-card-title{font-size:14px;font-weight:600;flex:1}
.f-card-desc{font-size:13px;color:var(--text-secondary);margin-bottom:8px;word-break:break-word;overflow-wrap:break-word}
.f-card-meta{display:flex;align-items:center;gap:12px;font-size:11px;color:var(--text-tertiary);flex-wrap:wrap}
.save-card{background:var(--bg-card);border-radius:10px;padding:14px;margin-bottom:10px}
.save-card-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.save-card-title{font-size:14px;font-weight:600;display:flex;align-items:center;gap:8px}
.save-card-tag{font-size:10px;padding:2px 8px;border-radius:4px;background:var(--success);color:white}
.save-card-tag.be{background:var(--error)}
.save-card-tag.key{background:var(--warning)}
.save-card-preview{font-size:12px;color:var(--text-secondary);margin-bottom:8px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
.save-card-meta{font-size:11px;color:var(--text-tertiary);display:flex;gap:12px;flex-wrap:wrap}
.save-card-actions{display:flex;gap:8px;margin-top:10px}
.action-btn{flex:1;padding:8px;border:none;border-radius:6px;font-size:12px;cursor:pointer}
.action-btn.primary{background:var(--primary);color:white}
.action-btn.secondary{background:var(--bg-tertiary);color:var(--text-secondary)}
.action-btn.danger{background:var(--error);color:white}
.font-option{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:12px 8px;background:var(--bg-tertiary);border:2px solid var(--divider);border-radius:8px;cursor:pointer;transition:all .2s;color:var(--text-primary)}
.font-option:hover{border-color:var(--primary);background:rgba(139,124,247,.1)}
.font-option.active{border-color:var(--primary);background:rgba(139,124,247,.2)}
.inst-card{background:var(--bg-card);border-radius:12px;padding:16px;margin-bottom:12px}
.inst-header{display:flex;align-items:flex-start;margin-bottom:12px}
.inst-icon{font-size:28px;margin-right:12px}
.inst-info{flex:1}
.inst-name{font-size:15px;font-weight:600;margin-bottom:4px}
.inst-meta{font-size:12px;color:var(--text-secondary)}
.inst-binding{font-size:12px;color:var(--text-tertiary);margin-top:4px}
.inst-preview{font-size:12px;color:var(--text-secondary);padding:8px;background:var(--bg-tertiary);border-radius:6px;margin-bottom:12px;max-height:60px;overflow:hidden}
.inst-actions{display:flex;gap:8px}
.settings-section{margin-bottom:24px}
.settings-section-title{font-size:13px;color:var(--text-tertiary);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.settings-card{background:var(--bg-card);border-radius:12px;overflow:hidden}
.settings-item{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:1px solid var(--divider);cursor:pointer}
.settings-item:last-child{border-bottom:none}
.settings-item:hover{background:var(--bg-tertiary)}
.settings-item-label{font-size:15px}
.settings-item-value{font-size:14px;color:var(--text-secondary);display:flex;align-items:center;gap:4px}
.settings-item.danger .settings-item-label{color:var(--error)}
.toggle{width:44px;height:24px;background:var(--bg-tertiary);border-radius:12px;position:relative;cursor:pointer}
.toggle.active{background:var(--primary)}
.toggle::after{content:'';width:20px;height:20px;background:white;border-radius:50%;position:absolute;top:2px;left:2px;transition:left .2s}
.toggle.active::after{left:22px}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:100;opacity:0;visibility:hidden;transition:all .3s}
.overlay.active{opacity:1;visibility:visible}
.bottom-sheet{position:fixed;bottom:0;left:50%;transform:translateX(-50%) translateY(100%);width:100%;max-width:420px;background:var(--bg-secondary);border-radius:20px 20px 0 0;padding:20px;transition:transform .3s ease;z-index:101;max-height:85vh;overflow-y:auto;box-sizing:border-box}
.bottom-sheet.active{transform:translateX(-50%) translateY(0)}
.bottom-sheet-handle{width:40px;height:4px;background:var(--bg-tertiary);border-radius:2px;margin:0 auto 16px}
.bottom-sheet-title{font-size:17px;font-weight:600;margin-bottom:16px}
.sheet-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;padding-bottom:20px}
.sheet-item{text-align:center;padding:16px 8px;background:var(--bg-tertiary);border-radius:12px;cursor:pointer}
.sheet-item.danger .sheet-item-label{color:var(--error)}
.sheet-item:hover{background:var(--primary);color:white}
.sheet-item-icon{font-size:24px;margin-bottom:6px}
.sheet-item-label{font-size:12px}
.modal{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);background:var(--bg-secondary);border-radius:16px;padding:20px;width:calc(100% - 32px);max-width:360px;max-height:calc(100vh - 100px);overflow-y:auto;z-index:102;opacity:0;visibility:hidden;transition:all .3s;box-sizing:border-box}
.modal.active{opacity:1;visibility:visible;transform:translate(-50%,-50%) scale(1)}
.modal-title{font-size:18px;font-weight:600;margin-bottom:12px}
.modal-content{font-size:14px;color:var(--text-secondary);margin-bottom:20px;line-height:1.6;max-height:40vh;overflow-y:auto;word-break:break-word;overflow-wrap:break-word}
.modal-input{width:100%;padding:12px 16px;background:var(--bg-tertiary);border:1px solid var(--divider);border-radius:8px;font-size:15px;color:var(--text-primary);outline:none;margin-bottom:16px}
.modal-input:focus{border-color:var(--primary)}
.modal-actions{display:flex;gap:12px}
.modal-btn{flex:1;padding:12px;border:none;border-radius:8px;font-size:15px;cursor:pointer}
.modal-btn.cancel{background:var(--bg-tertiary);color:var(--text-secondary)}
.modal-btn.confirm{background:var(--primary);color:white}
.modal-btn.danger{background:var(--error);color:white}
/* v19: 模式選擇卡片 */
.mode-card{background:var(--bg-tertiary);border:2px solid var(--divider);border-radius:12px;padding:12px;text-align:center;cursor:pointer;transition:all 0.2s}
.mode-card:hover{border-color:var(--primary);background:var(--bg-secondary)}
.mode-card.active{border-color:var(--primary);background:rgba(123,97,255,0.1)}
/* v19: 資源面板 */
.sim-resource-bar{display:flex;gap:12px;padding:10px 16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider);overflow-x:auto;flex-wrap:wrap}
.sim-resource-item{display:flex;align-items:center;gap:4px;font-size:13px;white-space:nowrap}
.sim-resource-icon{font-size:16px}
.sim-resource-value{font-weight:600;color:var(--text-primary)}
.sim-resource-name{color:var(--text-secondary);font-size:11px}
.sim-resource-change{font-size:11px;margin-left:2px}
.sim-resource-change.up{color:var(--success)}
.sim-resource-change.down{color:var(--error)}
.sim-day-badge{background:var(--primary);color:white;padding:4px 10px;border-radius:12px;font-size:12px;font-weight:600}
.context-menu{position:fixed;background:var(--bg-card);border-radius:12px;padding:8px 0;box-shadow:0 4px 20px rgba(0,0,0,.4);z-index:200;min-width:160px;opacity:0;visibility:hidden;transform:scale(.95);transition:all .2s}
.context-menu.active{opacity:1;visibility:visible;transform:scale(1)}
.context-menu-item{padding:12px 16px;font-size:14px;cursor:pointer;display:flex;align-items:center;gap:10px}
.context-menu-item:hover{background:var(--bg-tertiary)}
.context-menu-item.danger{color:var(--error)}
.context-menu-divider{height:1px;background:var(--divider);margin:4px 0}
.toast{position:fixed;bottom:100px;left:50%;transform:translateX(-50%) translateY(20px);background:var(--bg-card);color:var(--text-primary);padding:12px 20px;border-radius:8px;font-size:14px;box-shadow:0 4px 20px rgba(0,0,0,.3);opacity:0;transition:all .3s;z-index:300;display:flex;align-items:center;gap:8px}
.toast.active{opacity:1;transform:translateX(-50%) translateY(0)}
.toast.success{border-left:3px solid var(--success)}
.toast.error{border-left:3px solid var(--error)}
.toast.warning{border-left:3px solid var(--warning)}
.loading{position:fixed;inset:0;background:rgba(15,15,26,.8);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:500;opacity:0;visibility:hidden;transition:all .3s}
.loading.active{opacity:1;visibility:visible}
.loading-spinner{width:40px;height:40px;border:3px solid var(--bg-tertiary);border-top-color:var(--primary);border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.loading-text{margin-top:16px;font-size:14px;color:var(--text-secondary)}
.empty{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:40px 20px;text-align:center}
.empty-icon{font-size:64px;opacity:.5;margin-bottom:16px}
.empty-title{font-size:18px;font-weight:600;margin-bottom:8px}
.empty-desc{font-size:14px;color:var(--text-secondary);margin-bottom:24px;max-width:260px}
.empty-btn{padding:12px 24px;background:var(--primary);color:white;border:none;border-radius:8px;font-size:15px;cursor:pointer}
.api-card{background:var(--bg-card);border-radius:12px;padding:16px;margin-bottom:12px;border:2px solid transparent;cursor:pointer}
.api-card:hover{background:var(--bg-tertiary)}
.api-card.active{border-color:var(--primary)}
.api-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.api-name{font-size:15px;font-weight:600}
.api-badge{font-size:10px;padding:2px 8px;background:var(--primary);color:white;border-radius:4px}
.api-info{font-size:12px;color:var(--text-secondary)}
.form-group{margin-bottom:16px}
.form-label{display:block;font-size:13px;color:var(--text-secondary);margin-bottom:6px}
.form-input{width:100%;padding:12px 16px;background:var(--bg-tertiary);border:1px solid var(--divider);border-radius:8px;font-size:15px;color:var(--text-primary);outline:none}
.form-input:focus{border-color:var(--primary)}
.form-select{width:100%;padding:12px 16px;background:var(--bg-tertiary);border:1px solid var(--divider);border-radius:8px;font-size:15px;color:var(--text-primary);outline:none;cursor:pointer;appearance:none}
.form-textarea{width:100%;padding:12px 16px;background:var(--bg-tertiary);border:1px solid var(--divider);border-radius:8px;font-size:14px;color:var(--text-primary);outline:none;resize:vertical;min-height:80px;font-family:inherit;line-height:1.5}
.form-textarea:focus{border-color:var(--primary)}
/* 記憶可視化樣式 */
.mem-viz-item{display:grid;grid-template-columns:90px 1fr 60px;gap:8px;align-items:center;margin-bottom:10px}
.mem-viz-label{font-size:12px;color:var(--text-secondary)}
.mem-viz-bar-container{height:20px;background:var(--bg-primary);border-radius:10px;overflow:hidden}
.mem-viz-bar{height:100%;border-radius:10px;transition:width .5s ease;min-width:2px}
.mem-viz-value{font-size:12px;font-weight:600;color:var(--text-primary);text-align:right}
/* v8 角色編輯面板樣式 */
.char-panel{background:var(--bg-card);border-radius:12px;margin-bottom:10px;border:1px solid var(--divider);overflow:hidden}
.char-panel-header{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;cursor:pointer;font-size:14px;font-weight:600;color:var(--text-primary);transition:background .2s}
.char-panel-header:hover{background:rgba(139,124,247,.05)}
.char-panel-header:active{background:rgba(139,124,247,.1)}
.char-panel-arrow{font-size:10px;color:var(--text-secondary);transition:transform .2s}
.char-panel.expanded .char-panel-arrow{transform:rotate(90deg)}
.char-panel-content{padding:0 16px 16px;border-top:1px solid var(--divider)}
.greeting-option{padding:12px;margin-bottom:10px;background:var(--bg-tertiary);border-radius:10px;cursor:pointer;border:2px solid transparent;transition:all .2s}
.greeting-option:hover{background:var(--bg-card)}
.greeting-option.selected{border-color:var(--primary);background:rgba(139,124,247,.1)}
.greeting-option-header{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.greeting-char-avatar{font-size:20px}
.greeting-char-name{font-weight:600;font-size:14px}
.greeting-badge{font-size:10px;padding:2px 6px;background:var(--primary);color:white;border-radius:4px;margin-left:auto}
.greeting-preview{font-size:13px;color:var(--text-secondary);line-height:1.5;max-height:60px;overflow:hidden}
.relationship-item{background:var(--bg-tertiary);border-radius:10px;padding:12px;position:relative}
.relationship-item .delete-btn{position:absolute;top:8px;right:8px;width:24px;height:24px;border-radius:50%;background:var(--error);color:white;border:none;cursor:pointer;font-size:12px;display:flex;align-items:center;justify-content:center}
.relationship-row{display:flex;gap:8px;margin-bottom:8px}
.relationship-row .form-input,.relationship-row .form-select{flex:1;padding:8px 10px;font-size:13px}
.rel-type-badge{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:500}
.rel-graph-node{position:absolute;width:70px;height:70px;border-radius:50%;background:var(--bg-card);border:3px solid var(--primary);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:move;transition:transform .2s,box-shadow .2s;z-index:2}
.rel-graph-node:hover{transform:scale(1.1);box-shadow:0 4px 20px rgba(139,124,247,.4)}
.rel-graph-node .node-avatar{font-size:24px}
.rel-graph-node .node-name{font-size:10px;margin-top:2px;max-width:60px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center}
.rel-graph-node.protagonist{border-color:#FFD700}
.rel-graph-node.npc{border-color:var(--text-tertiary)}
.rel-graph-line{position:absolute;pointer-events:none;z-index:1}
.rel-graph-label{position:absolute;background:var(--bg-secondary);padding:2px 6px;border-radius:4px;font-size:10px;color:var(--text-secondary);white-space:nowrap;z-index:1}
/* 伏筆時間線樣式 */
.timeline-container{position:relative;padding:20px 0}
.timeline-item{position:relative;padding-left:40px;margin-bottom:24px}
.timeline-item::before{content:'';position:absolute;left:12px;top:30px;bottom:-24px;width:2px;background:var(--divider)}
.timeline-item:last-child::before{display:none}
.timeline-marker{position:absolute;left:0;top:0;width:28px;height:28px;border-radius:50%;background:var(--primary);color:white;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:600;border:3px solid var(--bg-primary);z-index:2}
.timeline-item.resolved .timeline-marker{background:var(--success)}
.timeline-item.warning .timeline-marker{background:var(--warning);animation:pulse 2s infinite}
.timeline-item.critical .timeline-marker{background:var(--error);animation:pulse 1s infinite}
@keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,.7)}50%{box-shadow:0 0 0 8px rgba(239,68,68,0)}}
.timeline-content{background:var(--bg-card);padding:12px;border-radius:8px;border:1px solid var(--divider)}
.timeline-title{font-size:14px;font-weight:600;margin-bottom:4px}
.timeline-meta{font-size:11px;color:var(--text-tertiary);margin-top:4px}
.timeline-resolved{font-size:12px;color:var(--success);margin-top:8px;padding-top:8px;border-top:1px solid var(--divider)}
/* 伏筆提醒橫幅 */
.foreshadow-reminder{position:fixed;top:52px;left:50%;transform:translateX(-50%);max-width:420px;width:calc(100% - 32px);padding:12px 16px;border-radius:0 0 12px 12px;display:flex;align-items:center;justify-content:space-between;gap:12px;z-index:999;font-size:13px;box-shadow:0 4px 12px rgba(0,0,0,.2)}
.foreshadow-reminder.warning{background:linear-gradient(135deg,#F59E0B,#EF4444);color:white}
.foreshadow-reminder button{background:rgba(255,255,255,.2);color:white;border:1px solid rgba(255,255,255,.3);padding:6px 12px;border-radius:6px;font-size:12px;cursor:pointer;transition:all .2s}
.foreshadow-reminder button:hover{background:rgba(255,255,255,.3)}
/* 建議項目樣式 */
.suggestions-list{padding:12px}
.suggestion-item{background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:12px;display:flex;gap:12px;align-items:flex-start;transition:all .2s}
.suggestion-item input[type="checkbox"]{margin-top:4px;width:18px;height:18px;cursor:pointer}
.suggestion-item label{flex:1;cursor:pointer}
.suggestion-item strong{display:block;font-size:14px;margin-bottom:4px}
.suggestion-item p{font-size:13px;color:var(--text-secondary);margin-bottom:4px}
.suggestion-item small{font-size:11px;color:var(--text-tertiary)}
/* 重複伏筆警告樣式 */
.suggestion-duplicate{background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.3)}
.duplicate-warning{margin-top:8px;padding:8px;background:rgba(239,68,68,.15);border-left:3px solid var(--error);border-radius:4px;font-size:12px;color:var(--error)}
.expression-item{position:relative;background:var(--bg-tertiary);border-radius:10px;padding:8px;cursor:pointer;border:2px solid transparent;transition:all .2s}
.expression-item:hover{background:var(--bg-card)}
.expression-item.selected{border-color:var(--primary);background:rgba(139,124,247,.1)}
.expression-item.default{border-color:var(--success)}
.expression-item .expr-img{width:100%;aspect-ratio:1;border-radius:8px;object-fit:cover;background:var(--bg-secondary)}
.expression-item .expr-name{font-size:11px;text-align:center;margin-top:6px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.expression-item .expr-badge{position:absolute;top:4px;left:4px;font-size:9px;padding:2px 5px;background:var(--success);color:white;border-radius:4px}
.expression-item .expr-delete{position:absolute;top:4px;right:4px;width:20px;height:20px;border-radius:50%;background:rgba(0,0,0,.5);color:white;border:none;cursor:pointer;font-size:10px;display:none;align-items:center;justify-content:center}
.expression-item:hover .expr-delete{display:flex}
.expression-edit-modal{background:var(--bg-secondary);border-radius:12px;padding:16px;margin-top:10px}
.char-expr-display{width:80px;height:80px;border-radius:12px;object-fit:cover;border:2px solid var(--primary);cursor:pointer;transition:transform .2s}
.char-expr-display:hover{transform:scale(1.05)}
.expr-selector{position:absolute;bottom:100%;left:50%;transform:translateX(-50%);background:var(--bg-card);border-radius:12px;padding:8px;display:none;flex-wrap:wrap;gap:6px;max-width:200px;box-shadow:0 4px 20px rgba(0,0,0,.3);z-index:100}
.expr-selector.active{display:flex}
.expr-selector-item{width:50px;height:50px;border-radius:8px;object-fit:cover;cursor:pointer;border:2px solid transparent;transition:all .2s}
.expr-selector-item:hover{border-color:var(--primary)}
.expr-selector-item.active{border-color:var(--primary);box-shadow:0 0 10px rgba(139,124,247,.5)}
.char-filter-bar{display:flex;gap:10px;padding:10px 16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider)}
.char-search-wrap{flex:1;position:relative}
.char-search-icon{position:absolute;left:12px;top:50%;transform:translateY(-50%);font-size:14px;opacity:.5}
.char-search-input{width:100%;padding:10px 12px 10px 36px;border:1px solid var(--divider);border-radius:10px;background:var(--bg-tertiary);color:var(--text-primary);-webkit-text-fill-color:var(--text-primary);font-size:14px}
.char-search-input:focus{outline:none;border-color:var(--primary)}
.char-search-input:-webkit-autofill,.char-search-input:-webkit-autofill:hover,.char-search-input:-webkit-autofill:focus{-webkit-text-fill-color:var(--text-primary)!important;-webkit-box-shadow:0 0 0 1000px var(--bg-tertiary) inset!important;transition:background-color 5000s ease-in-out 0s}
.char-filter-select{padding:10px 12px;border:1px solid var(--divider);border-radius:10px;background:var(--bg-tertiary);color:var(--text-primary);font-size:13px;min-width:100px}
.char-batch-bar{display:flex;align-items:center;gap:12px;padding:10px 16px;background:rgba(139,124,247,.1);border-bottom:1px solid var(--primary)}
.char-batch-select-all{display:flex;align-items:center;gap:6px;font-size:13px;cursor:pointer}
.char-batch-count{font-size:12px;color:var(--primary);font-weight:500}
.char-batch-actions{margin-left:auto;display:flex;gap:8px}
.char-batch-btn{padding:6px 12px;border:none;border-radius:6px;background:var(--bg-tertiary);color:var(--text-primary);font-size:12px;cursor:pointer;transition:background .2s}
.char-batch-btn:hover{background:var(--bg-card)}
.char-group{margin-bottom:16px}
.char-group-header{display:flex;align-items:center;gap:8px;padding:8px 16px;font-size:13px;font-weight:600;color:var(--text-secondary);cursor:pointer}
.char-group-header:hover{color:var(--text-primary)}
.char-group-arrow{transition:transform .2s}
.char-group.collapsed .char-group-arrow{transform:rotate(-90deg)}
.char-group.collapsed .char-group-list{display:none}
.char-group-count{font-size:11px;color:var(--text-tertiary);font-weight:normal}
.char-card{display:flex;align-items:center;gap:12px;padding:12px 16px;background:var(--bg-card);margin:0 16px 8px;border-radius:12px;cursor:pointer;transition:all .2s;position:relative}
.char-card:hover{background:var(--bg-tertiary);transform:translateX(4px)}
.char-card.selected{background:rgba(139,124,247,.15);border:1px solid var(--primary)}
.char-card-checkbox{width:20px;height:20px;border-radius:4px;border:2px solid var(--divider);display:none;align-items:center;justify-content:center;flex-shrink:0}
.char-card-checkbox.checked{background:var(--primary);border-color:var(--primary);color:white}
.batch-mode .char-card-checkbox{display:flex}
.char-card-avatar{width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,var(--primary),var(--primary-light));display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0;overflow:hidden}
.char-card-avatar img{width:100%;height:100%;object-fit:cover}
.char-card-info{flex:1;min-width:0}
.char-card-name{font-size:15px;font-weight:600;margin-bottom:2px;display:flex;align-items:center;gap:6px}
.char-card-title{font-size:12px;color:var(--text-secondary);margin-bottom:4px}
.char-card-tags{display:flex;flex-wrap:wrap;gap:4px}
.char-card-tag{font-size:10px;padding:2px 6px;background:var(--bg-tertiary);border-radius:4px;color:var(--text-secondary)}
.char-card-stats{display:flex;flex-direction:column;align-items:flex-end;gap:4px;flex-shrink:0}
.char-card-stat{font-size:11px;color:var(--text-secondary);display:flex;align-items:center;gap:4px}
.char-card-category{font-size:10px;padding:2px 6px;border-radius:4px;font-weight:500}
.char-card-category.protagonist{background:rgba(255,215,0,.2);color:#FFD700}
.char-card-category.supporting{background:rgba(139,124,247,.2);color:var(--primary)}
.char-card-category.npc{background:rgba(156,163,175,.2);color:#9ca3af}
.char-empty{text-align:center;padding:40px 20px;color:var(--text-tertiary)}
.char-empty-icon{font-size:48px;margin-bottom:12px;opacity:.5}
.char-empty-text{font-size:14px;margin-bottom:16px}
.char-form-row{display:flex;gap:12px}
.token-hint{font-size:11px;color:var(--text-tertiary);font-weight:normal}
.char-lore-entry{background:var(--bg-tertiary);border-radius:8px;padding:12px;position:relative}
.char-lore-entry .delete-btn{position:absolute;top:8px;right:8px;width:24px;height:24px;border-radius:50%;background:var(--error);color:white;border:none;cursor:pointer;font-size:12px;display:flex;align-items:center;justify-content:center}
.alt-greeting-item{display:flex;gap:8px;align-items:flex-start}
.alt-greeting-item textarea{flex:1;min-height:60px}
.alt-greeting-item .delete-btn{width:28px;height:28px;border-radius:6px;background:var(--bg-tertiary);color:var(--text-secondary);border:none;cursor:pointer;flex-shrink:0}
.alt-greeting-item .delete-btn:hover{background:var(--error);color:white}
.hidden{display:none!important}
/* PWA 安裝橫幅動畫 */
#install-banner>div{animation:slideUp .3s ease}
@keyframes slideUp{from{transform:translateY(100%);opacity:0}to{transform:translateY(0);opacity:1}}
/* 文字溢出修復 */
.scroll{word-break:break-word;overflow-wrap:break-word}
.lore-desc,.lore-name,.inst-preview,.card-preview,.save-card-preview{word-break:break-word;overflow-wrap:break-word}
/* ====== v7 角色卡片系統 CSS ====== */
.char-card{background:var(--bg-card);border-radius:16px;margin-bottom:12px;border:1px solid var(--divider);overflow:hidden;transition:all .3s}
.char-card.expanded{box-shadow:0 8px 32px rgba(139,124,247,.15)}
.char-header{display:flex;align-items:center;padding:14px;cursor:pointer;transition:background .2s}
.char-header:active{background:rgba(255,255,255,.03)}
.char-avatar{width:52px;height:52px;border-radius:12px;background:linear-gradient(135deg,var(--primary),var(--primary-light));display:flex;align-items:center;justify-content:center;font-size:22px;margin-right:12px;flex-shrink:0;position:relative;background-size:cover;background-position:center;overflow:hidden;cursor:pointer}
.char-avatar img{width:100%;height:100%;object-fit:cover}
.char-avatar-rank{position:absolute;bottom:-4px;right:-4px;background:var(--warning);color:#000;font-size:9px;padding:2px 6px;border-radius:8px;font-weight:600}
.char-info{flex:1;min-width:0}
.char-name{font-size:16px;font-weight:600;display:flex;align-items:center;gap:8px}
.char-title{font-size:10px;background:linear-gradient(135deg,#d4a574,#e8c9a0);color:#000;padding:2px 8px;border-radius:4px;font-weight:500}
.char-brief{font-size:12px;color:var(--text-secondary);margin-top:3px}
.char-quick{display:flex;gap:10px;margin-top:6px}
.char-quick-item{display:flex;align-items:center;gap:3px;font-size:11px}
.char-quick-val{font-weight:600}
.char-expand{width:28px;height:28px;border-radius:50%;background:var(--bg-secondary);display:flex;align-items:center;justify-content:center;transition:transform .3s;flex-shrink:0;font-size:12px}
.char-card.expanded .char-expand{transform:rotate(180deg)}
.char-content{max-height:0;overflow:hidden;transition:max-height .4s ease}
.char-card.expanded .char-content{max-height:800px}
.char-inner{padding:0 14px 14px}
.char-tabs{display:flex;gap:4px;background:var(--bg-secondary);padding:4px;border-radius:10px;margin-bottom:12px}
.char-tab{flex:1;padding:8px;border-radius:8px;font-size:12px;text-align:center;cursor:pointer;transition:all .2s;color:var(--text-secondary)}
.char-tab.active{background:var(--primary);color:white;font-weight:500}
.char-tab-content{display:none;animation:fadeIn .3s}
.char-tab-content.active{display:block}
@keyframes charFadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
.char-section{margin-bottom:14px}
.char-section-title{font-size:11px;color:var(--text-tertiary);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.char-section-title::after{content:'';flex:1;height:1px;background:var(--divider)}
.char-stat-bar{margin-bottom:10px}
.char-stat-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.char-stat-label{font-size:12px;color:var(--text-secondary);display:flex;align-items:center;gap:4px}
.char-stat-value{font-size:13px;font-weight:600}
.char-stat-track{height:5px;background:var(--bg-secondary);border-radius:3px;overflow:hidden}
.char-stat-fill{height:100%;border-radius:3px;transition:width .5s}
.char-stat-fill.purple{background:linear-gradient(90deg,#8b5cf6,#a78bfa)}
.char-stat-fill.gold{background:linear-gradient(90deg,#d4a574,#e8c9a0)}
.char-stat-fill.blue{background:linear-gradient(90deg,#3b82f6,#60a5fa)}
.char-stat-fill.red{background:linear-gradient(90deg,#ef4444,#f87171)}
.char-stat-fill.green{background:linear-gradient(90deg,#22c55e,#4ade80)}
.char-stat-fill.pink{background:linear-gradient(90deg,#ec4899,#f472b6)}
.char-favor{background:var(--bg-secondary);border-radius:12px;padding:12px;margin-bottom:10px}
.char-favor-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.char-favor-title{font-size:13px;font-weight:500}
.char-favor-level{font-size:11px;color:var(--warning);background:rgba(245,158,11,.15);padding:3px 8px;border-radius:10px}
.char-favor-item{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.char-favor-item:last-child{margin-bottom:0}
.char-favor-icon{width:26px;height:26px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0}
.char-favor-icon.surface{background:rgba(139,124,247,.2)}
.char-favor-icon.real{background:rgba(239,68,68,.2)}
.char-favor-info{flex:1}
.char-favor-label{font-size:11px;color:var(--text-secondary)}
.char-favor-track{height:4px;background:rgba(255,255,255,.1);border-radius:2px;margin-top:3px;overflow:hidden}
.char-favor-fill{height:100%;border-radius:2px;transition:width .5s}
.char-favor-fill.surface{background:var(--primary)}
.char-favor-fill.real{background:var(--error)}
.char-favor-fill.true{background:var(--success)}
.char-favor-val{font-size:13px;font-weight:600;min-width:28px;text-align:right}
.char-desc{font-size:12px;line-height:1.6;color:var(--text-secondary);background:var(--bg-secondary);padding:12px;border-radius:10px;border-left:3px solid var(--primary)}
.char-tags{display:flex;flex-wrap:wrap;gap:5px;margin-top:10px}
.char-tag{font-size:10px;padding:4px 8px;border-radius:10px;background:var(--bg-secondary);color:var(--text-secondary)}
.char-tag.danger{background:rgba(239,68,68,.15);color:#f87171}
.char-tag.warning{background:rgba(234,179,8,.15);color:#fbbf24}
.char-tag.info{background:rgba(59,130,246,.15);color:#60a5fa}
.char-tag.success{background:rgba(34,197,94,.15);color:#4ade80}
.char-mini-stats{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-top:10px}
.char-mini-stat{background:var(--bg-secondary);padding:8px;border-radius:8px;text-align:center}
.char-mini-val{font-size:16px;font-weight:600}
.char-mini-label{font-size:10px;color:var(--text-tertiary);margin-top:2px}
.char-relation{display:flex;align-items:center;padding:10px;background:var(--bg-secondary);border-radius:10px;margin-bottom:8px}
.char-relation-avatar{width:36px;height:36px;border-radius:10px;background:linear-gradient(135deg,#3b82f6,#60a5fa);display:flex;align-items:center;justify-content:center;font-size:16px;margin-right:10px}
.char-relation-info{flex:1}
.char-relation-name{font-size:13px;font-weight:500}
.char-relation-type{font-size:11px;color:var(--text-secondary)}
.char-relation-status{font-size:10px;padding:3px 8px;border-radius:10px}
.char-relation-status.ally{background:rgba(34,197,94,.2);color:var(--success)}
.char-relation-status.enemy{background:rgba(239,68,68,.2);color:var(--error)}
.char-relation-status.neutral{background:rgba(255,255,255,.1);color:var(--text-secondary)}
.char-actions{display:flex;gap:8px;margin-top:12px}
.char-action-btn{flex:1;padding:10px;border-radius:10px;border:none;font-size:12px;cursor:pointer;transition:all .2s}
.char-action-btn.primary{background:var(--primary);color:white}
.char-action-btn.secondary{background:var(--bg-secondary);color:var(--text-primary)}
.char-action-btn:active{transform:scale(.97)}
/* 數值變化動畫 */
.char-value-change{position:fixed;font-size:14px;font-weight:600;animation:charFloatUp 1.5s ease forwards;pointer-events:none;z-index:9999}
.char-value-change.up{color:var(--success)}
.char-value-change.down{color:var(--error)}
@keyframes charFloatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-24px)}}
/* 角色列表空狀態 */
.char-empty{text-align:center;padding:40px 20px;color:var(--text-secondary)}
.char-empty-icon{font-size:48px;margin-bottom:12px}
.char-empty-title{font-size:15px;font-weight:500;margin-bottom:6px;color:var(--text-primary)}
.char-empty-desc{font-size:13px}
/* 角色更新中提示 */
.char-updating{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.8);padding:12px 20px;border-radius:12px;font-size:13px;display:flex;align-items:center;gap:8px}
.char-updating-spin{width:16px;height:16px;border:2px solid var(--primary);border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite}
/* 指令生成向導樣式 */
.wizard-progress{display:flex;align-items:center;padding:16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider)}
.wizard-progress-bar{flex:1;height:6px;background:var(--bg-tertiary);border-radius:3px;overflow:hidden;margin-right:12px}
.wizard-progress-fill{height:100%;background:linear-gradient(90deg,var(--primary),var(--primary-light));border-radius:3px;transition:width .3s}
.wizard-progress-text{font-size:12px;color:var(--text-secondary);white-space:nowrap}
.wizard-content{flex:1;overflow-y:auto;padding:16px}
.wizard-section{margin-bottom:24px}
.wizard-section-title{font-size:16px;font-weight:600;margin-bottom:12px;display:flex;align-items:center;gap:8px}
.wizard-section-desc{font-size:13px;color:var(--text-secondary);margin-bottom:16px;line-height:1.6}
.wizard-options{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:16px}
.wizard-option{padding:10px 16px;background:var(--bg-tertiary);border:2px solid transparent;border-radius:10px;font-size:14px;cursor:pointer;transition:all .2s}
.wizard-option:hover{border-color:var(--primary-light)}
.wizard-option.selected{background:rgba(139,124,247,.2);border-color:var(--primary);color:var(--primary-light)}
.wizard-option.template{display:flex;flex-direction:column;padding:16px;min-width:calc(50% - 4px)}
.wizard-option.template .template-icon{font-size:28px;margin-bottom:8px}
.wizard-option.template .template-name{font-weight:600;margin-bottom:4px}
.wizard-option.template .template-desc{font-size:11px;color:var(--text-tertiary)}
.wizard-input{width:100%;padding:12px 16px;background:var(--bg-tertiary);border:1px solid var(--divider);border-radius:10px;font-size:14px;color:var(--text-primary);outline:none;margin-bottom:12px}
.wizard-input:focus{border-color:var(--primary)}
.wizard-textarea{min-height:100px;resize:vertical;font-family:inherit;line-height:1.6}
.wizard-ai-box{background:var(--bg-card);border-radius:12px;padding:16px;margin-top:16px;border-left:3px solid var(--primary)}
.wizard-ai-header{display:flex;align-items:center;gap:8px;margin-bottom:12px;font-size:13px;color:var(--primary-light)}
.wizard-ai-content{font-size:14px;line-height:1.7;color:var(--text-secondary)}
.wizard-ai-options{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
.wizard-ai-btn{padding:8px 16px;background:var(--bg-tertiary);border:none;border-radius:8px;font-size:13px;color:var(--text-primary);cursor:pointer;transition:all .2s}
.wizard-ai-btn:hover{background:var(--primary);color:white}
.wizard-ai-btn.loading{opacity:.6;pointer-events:none}
.wizard-char-list{margin-top:16px}
.wizard-char-card{background:var(--bg-card);border-radius:10px;padding:12px;margin-bottom:8px;display:flex;align-items:center;gap:12px}
.wizard-char-avatar{width:40px;height:40px;border-radius:10px;background:linear-gradient(135deg,var(--primary),var(--primary-light));display:flex;align-items:center;justify-content:center;font-size:18px}
.wizard-char-info{flex:1}
.wizard-char-name{font-size:14px;font-weight:600}
.wizard-char-role{font-size:12px;color:var(--text-secondary)}
.wizard-char-actions{display:flex;gap:8px}
.wizard-char-btn{width:28px;height:28px;border-radius:6px;background:var(--bg-tertiary);border:none;font-size:12px;cursor:pointer}
.wizard-example{background:var(--bg-tertiary);border-radius:10px;padding:12px;margin-top:12px;font-size:13px;color:var(--text-secondary);line-height:1.6;max-height:150px;overflow-y:auto}
.wizard-example-title{font-size:12px;color:var(--text-tertiary);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.wizard-footer{display:flex;gap:12px;padding:16px;background:var(--bg-secondary);border-top:1px solid var(--divider)}
.wizard-btn{flex:1;padding:14px;border:none;border-radius:12px;font-size:15px;font-weight:600;cursor:pointer;transition:all .2s}
.wizard-btn.primary{background:var(--primary);color:white}
.wizard-btn.secondary{background:var(--bg-tertiary);color:var(--text-secondary)}
.wizard-btn:disabled{opacity:.5;cursor:not-allowed}
.wizard-btn:active:not(:disabled){transform:scale(.98)}
.wizard-preview{background:var(--bg-card);border-radius:12px;padding:16px;margin-top:16px}
.wizard-preview-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.wizard-preview-title{font-size:14px;font-weight:600}
.wizard-preview-stats{font-size:12px;color:var(--text-tertiary)}
.wizard-preview-content{background:var(--bg-tertiary);border-radius:8px;padding:12px;font-size:13px;line-height:1.7;max-height:300px;overflow-y:auto;white-space:pre-wrap;font-family:monospace}
.wizard-chat{display:flex;flex-direction:column;gap:12px;margin-top:16px}
.wizard-chat-msg{max-width:85%;padding:12px 16px;border-radius:16px;font-size:14px;line-height:1.6}
.wizard-chat-msg.ai{background:var(--bg-card);border-bottom-left-radius:4px;align-self:flex-start}
.wizard-chat-msg.user{background:var(--primary);color:white;border-bottom-right-radius:4px;align-self:flex-end}
.wizard-chat-input{display:flex;gap:8px;margin-top:12px}
.wizard-chat-field{flex:1;padding:12px 16px;background:var(--bg-tertiary);border:none;border-radius:20px;font-size:14px;color:var(--text-primary);outline:none}
.wizard-chat-send{width:40px;height:40px;background:var(--primary);border:none;border-radius:50%;color:white;font-size:16px;cursor:pointer}
/* Prompt 分析功能樣式 */
.analyze-import{display:flex;gap:12px;margin-bottom:16px}
.analyze-import-btn{flex:1;padding:40px 16px;background:var(--bg-card);border:2px dashed var(--divider);border-radius:12px;cursor:pointer;text-align:center;transition:all .2s}
.analyze-import-btn:hover{border-color:var(--primary);background:rgba(139,124,247,.05)}
.analyze-import-btn .icon{font-size:32px;margin-bottom:8px}
.analyze-import-btn .label{font-size:14px;color:var(--text-secondary)}
.analyze-textarea{width:100%;min-height:200px;padding:16px;background:var(--bg-tertiary);border:1px solid var(--divider);border-radius:12px;font-size:14px;color:var(--text-primary);font-family:monospace;line-height:1.6;resize:vertical;outline:none}
.analyze-textarea:focus{border-color:var(--primary)}
.analyze-stats{display:flex;gap:16px;margin:16px 0;padding:12px 16px;background:var(--bg-card);border-radius:10px}
.analyze-stat{text-align:center}
.analyze-stat-value{font-size:20px;font-weight:700;color:var(--primary)}
.analyze-stat-label{font-size:11px;color:var(--text-tertiary)}
.analyze-score{text-align:center;padding:24px;background:var(--bg-card);border-radius:16px;margin-bottom:20px}
.analyze-score-ring{width:120px;height:120px;margin:0 auto 12px;position:relative}
.analyze-score-ring svg{transform:rotate(-90deg)}
.analyze-score-ring circle{fill:none;stroke-width:8}
.analyze-score-ring .bg{stroke:var(--bg-tertiary)}
.analyze-score-ring .fill{stroke:var(--primary);stroke-linecap:round;transition:stroke-dashoffset .5s}
.analyze-score-value{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center}
.analyze-score-num{font-size:36px;font-weight:700}
.analyze-score-label{font-size:12px;color:var(--text-tertiary)}
.analyze-score-text{font-size:14px;color:var(--text-secondary)}
.analyze-modules{margin-bottom:20px}
.analyze-module{background:var(--bg-card);border-radius:12px;margin-bottom:8px;overflow:hidden}
.analyze-module-header{display:flex;align-items:center;padding:14px 16px;cursor:pointer}
.analyze-module-icon{font-size:18px;margin-right:10px}
.analyze-module-name{flex:1;font-size:14px;font-weight:500}
.analyze-module-score{display:flex;align-items:center;gap:8px}
.analyze-module-bar{width:60px;height:6px;background:var(--bg-tertiary);border-radius:3px;overflow:hidden}
.analyze-module-bar-fill{height:100%;border-radius:3px;transition:width .3s}
.analyze-module-bar-fill.high{background:var(--success)}
.analyze-module-bar-fill.medium{background:var(--warning)}
.analyze-module-bar-fill.low{background:var(--error)}
.analyze-module-num{font-size:13px;font-weight:600;min-width:28px;text-align:right}
.analyze-module-status{font-size:14px;margin-left:4px}
.analyze-module-body{padding:0 16px 14px;display:none}
.analyze-module.expanded .analyze-module-body{display:block}
.analyze-module-issues{margin-bottom:12px}
.analyze-issue{display:flex;align-items:flex-start;gap:8px;padding:8px 0;border-bottom:1px solid var(--divider);font-size:13px}
.analyze-issue:last-child{border-bottom:none}
.analyze-issue-icon{flex-shrink:0}
.analyze-issue-text{flex:1;color:var(--text-secondary);line-height:1.5}
.analyze-module-actions{display:flex;gap:8px}
.analyze-module-btn{padding:8px 16px;background:var(--bg-tertiary);border:none;border-radius:8px;font-size:13px;color:var(--text-primary);cursor:pointer;transition:all .2s}
.analyze-module-btn:hover{background:var(--primary);color:white}
.analyze-module-btn.primary{background:var(--primary);color:white}
.analyze-suggestions{background:var(--bg-card);border-radius:12px;padding:16px;margin-bottom:20px;border-left:3px solid var(--primary)}
.analyze-suggestions-title{font-size:14px;font-weight:600;margin-bottom:12px;display:flex;align-items:center;gap:8px}
.analyze-suggestions-content{font-size:14px;line-height:1.7;color:var(--text-secondary)}
.analyze-compare{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:16px}
.analyze-compare-col{background:var(--bg-tertiary);border-radius:10px;padding:12px;max-height:300px;overflow-y:auto}
.analyze-compare-title{font-size:12px;font-weight:600;margin-bottom:8px;color:var(--text-tertiary);display:flex;align-items:center;gap:6px}
.analyze-compare-content{font-size:12px;line-height:1.6;white-space:pre-wrap;font-family:monospace;color:var(--text-secondary)}
.analyze-compare-content .added{background:rgba(16,185,129,.2);color:var(--success)}
.analyze-compare-content .removed{background:rgba(239,68,68,.2);color:var(--error);text-decoration:line-through}
.analyze-actions{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:16px}
.analyze-chat{margin-top:20px;padding-top:20px;border-top:1px solid var(--divider)}
/* 消息狀態卡片樣式 */
.msg-story{line-height:var(--line-height)}
.msg-status-section{margin-top:16px;border-top:1px solid var(--divider);padding-top:12px}
.msg-status-header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--bg-tertiary);border-radius:10px;cursor:pointer;transition:all .2s}
.msg-status-header:hover{background:var(--bg-card)}
.msg-status-header .title{display:flex;align-items:center;gap:8px;font-size:13px;font-weight:500;color:var(--text-secondary)}
.msg-status-header .toggle{font-size:12px;color:var(--text-tertiary);transition:transform .2s}
.msg-status-header.expanded .toggle{transform:rotate(180deg)}
.msg-status-cards{display:none;margin-top:10px;gap:10px}
.msg-status-header.expanded+.msg-status-cards{display:flex;flex-direction:column}
.status-card{background:var(--bg-card);border-radius:12px;padding:14px;border:1px solid var(--divider)}
.status-card-header{display:flex;align-items:center;gap:10px;margin-bottom:12px}
.status-card-avatar{width:42px;height:42px;border-radius:10px;background:linear-gradient(135deg,var(--primary),var(--primary-light));display:flex;align-items:center;justify-content:center;font-size:20px;color:white;flex-shrink:0}
.status-card-avatar img{width:100%;height:100%;object-fit:cover;border-radius:10px}
.status-card-info{flex:1;min-width:0}
.status-card-name{font-size:15px;font-weight:600;display:flex;align-items:center;gap:6px}
.status-card-title{font-size:12px;color:var(--primary-light);background:rgba(139,124,247,.15);padding:2px 8px;border-radius:4px}
.status-card-meta{font-size:12px;color:var(--text-tertiary);margin-top:2px}
.status-card-stats{display:flex;flex-direction:column;gap:8px}
.status-stat-row{display:flex;align-items:center;gap:10px}
.status-stat-label{font-size:12px;color:var(--text-secondary);min-width:70px}
.status-stat-bar{flex:1;height:6px;background:var(--bg-tertiary);border-radius:3px;overflow:hidden}
.status-stat-fill{height:100%;border-radius:3px;transition:width .3s}
.status-stat-fill.high{background:linear-gradient(90deg,var(--success),#34d399)}
.status-stat-fill.medium{background:linear-gradient(90deg,var(--warning),#fbbf24)}
.status-stat-fill.low{background:linear-gradient(90deg,var(--error),#f87171)}
.status-stat-fill.primary{background:linear-gradient(90deg,var(--primary),var(--primary-light))}
.status-stat-value{font-size:12px;font-weight:600;min-width:28px;text-align:right}
.status-card-footer{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px;padding-top:10px;border-top:1px solid var(--divider)}
.status-tag{font-size:11px;padding:3px 8px;background:var(--bg-tertiary);border-radius:4px;color:var(--text-secondary)}
.status-tag.mood{background:rgba(59,130,246,.15);color:var(--info)}
.status-tag.note{background:rgba(245,158,11,.15);color:var(--warning)}
.msg-format-warning{display:flex;align-items:center;gap:8px;padding:10px 14px;background:rgba(245,158,11,.1);border-radius:8px;margin-top:12px;font-size:12px;color:var(--warning)}
.msg-format-warning .icon{font-size:16px}

.form-group{margin-bottom:12px}
.form-group label{display:block;font-size:12px;color:var(--text-secondary);margin-bottom:6px}
.modal-textarea{width:100%;padding:10px;border:1px solid var(--divider);border-radius:8px;background:var(--bg-secondary);color:var(--text-primary);font-size:13px;resize:vertical;font-family:inherit}
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="status-bar">
    <span id="status-time">09:41</span>
    <div style="display:flex;gap:4px;font-size:12px"><span>📶</span><span>🔋</span></div>
  </div>
  <div class="views">
    <!-- 故事列表 -->
    <div class="view active" id="view-stories">
      <div class="list-nav">
        <span class="list-nav-title">織夢</span>
        <div style="display:flex;gap:4px">
          <div class="nav-btn" onclick="toggleScreen()" title="切換模式" role="button" tabindex="0">🖥️</div>
          <div class="nav-btn" onclick="importBook()" title="導入書籍" role="button" tabindex="0">📥</div>
          <div class="nav-btn" onclick="createStory()" title="新建" role="button" tabindex="0">➕</div>
        </div>
      </div>
      <div class="search-bar">
        <div class="search-wrap">
          <span style="color:var(--text-tertiary)">🔍</span>
          <input type="text" class="search-input" placeholder="搜索故事" id="story-search" oninput="filterStories()">
        </div>
      </div>
      <div class="scroll" id="story-list"></div>
      <div class="tab-bar">
        <div class="tab-item active" onclick="switchTab('stories')" role="button" tabindex="0"><span class="tab-icon">📚</span><span class="tab-label">故事</span></div>
        <div class="tab-item" onclick="switchTab('instructions')" role="button" tabindex="0"><span class="tab-icon">📜</span><span class="tab-label">指令</span></div>
        <div class="tab-item" onclick="switchTab('settings')" role="button" tabindex="0"><span class="tab-icon">⚙️</span><span class="tab-label">設置</span></div>
      </div>
    </div>
    <!-- 閱讀頁 -->
    <div class="view" id="view-reading">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title" id="reading-title">故事</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="goTo('view-characters')" title="角色狀態" id="btn-characters" role="button" tabindex="0">👥</div>
          <div class="nav-btn" onclick="goTo('view-lore')" title="資料庫" role="button" tabindex="0">📖</div>
          <div class="nav-btn" onclick="goTo('view-search')" title="搜索" role="button" tabindex="0">🔍</div>
          <div class="nav-btn" onclick="showSheet()" title="設置" role="button" tabindex="0">⚙️</div>
          <div class="nav-btn" onclick="showMore(event)" title="更多" role="button" tabindex="0">⋯</div>
        </div>
      </div>
      <!-- v19: 經營模式資源面板 -->
      <div class="sim-resource-bar" id="sim-resource-bar" style="display:none">
        <div class="sim-day-badge" id="sim-day-badge">📅 第 1 天</div>
        <!-- 資源項目動態渲染 -->
      </div>
      <div class="progress-wrap">
        <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
        <span class="progress-text" id="progress-text">0%</span>
      </div>
      <!-- 一致性修復提示條 -->
      <div id="consistency-fix-banner" style="display:none;background:linear-gradient(135deg,#F59E0B,#FBBF24);color:white;padding:10px 16px;font-size:13px;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(0,0,0,0.1)">
        <div style="display:flex;align-items:center;gap:8px;flex:1">
          <span style="font-size:16px">🔧</span>
          <div style="flex:1">
            <div style="font-weight:600;margin-bottom:2px">AI 一致性修復中</div>
            <div style="font-size:11px;opacity:0.9" id="consistency-fix-info">剩餘 3 次對話</div>
          </div>
        </div>
        <button onclick="cancelConsistencyFix()" style="background:rgba(255,255,255,0.2);border:none;color:white;padding:4px 12px;border-radius:6px;font-size:12px;cursor:pointer;font-weight:500">取消</button>
      </div>
      <div class="content" id="content-area"></div>
      <div class="quick-cmds" id="quick-cmds">
        <!-- 動態渲染 -->
      </div>
      <div class="persona-bar">
        <div class="persona-selector" onclick="showPersonaSelector()">
          <span class="persona-avatar" id="current-persona-avatar">👤</span>
          <div class="persona-info">
            <div class="persona-label">當前身份</div>
            <div class="persona-name" id="current-persona-name">無特定身份</div>
          </div>
          <span class="persona-dropdown">▼</span>
        </div>
      </div>
      <div class="input-bar">
        <div class="input-wrap"><input type="text" class="input-field" id="user-input" placeholder="輸入你的行動或對話..." onkeydown="handleInputKey(event)"></div>
        <button class="send-btn" id="send-btn" onclick="send()">↑</button>
      </div>
    </div>
    <!-- 資料庫 -->
    <div class="view" id="view-lore">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">世界觀資料庫</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="aiExtractLore()" role="button" tabindex="0" title="AI提取">🤖</div>
          <div class="nav-btn" onclick="addLore()" role="button" tabindex="0" title="添加">➕</div>
        </div>
      </div>
      <div class="search-bar">
        <div class="search-wrap">
          <span style="color:var(--text-tertiary)">🔍</span>
          <input type="text" class="search-input" placeholder="搜索資料" id="lore-search" oninput="filterLore()">
        </div>
      </div>
      <div class="scroll sys" id="lore-list" style="padding-bottom:20px"></div>
      <div class="input-bar" style="justify-content:center">
        <span style="font-size:12px;color:var(--text-tertiary)" id="lore-count">已選 0 項</span>
      </div>
    </div>
    <!-- 時間軸 -->
    <div class="view" id="view-timeline">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">故事時間軸</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="addTimeline()" role="button" tabindex="0" title="添加">➕</div>
          <div class="nav-btn" onclick="timeJump()" role="button" tabindex="0" title="時間跳躍">⏭️</div>
        </div>
      </div>
      <div class="scroll sys" id="timeline-content"></div>
    </div>
    <!-- 伏筆/事件 -->
    <div class="view" id="view-foreshadow">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">伏筆與事件</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="aiAnalyzeForeshadow()" role="button" tabindex="0" title="AI分析">🤖</div>
          <div class="nav-btn" onclick="addForeshadowOrEvent()" role="button" tabindex="0" title="添加">➕</div>
        </div>
      </div>
      <div class="tabs-bar">
        <button class="tab-btn active" onclick="switchFTab('foreshadow',this)">伏筆</button>
        <button class="tab-btn" onclick="switchFTab('events',this)">事件</button>
      </div>
      <div class="scroll sys" id="foreshadow-content"></div>
    </div>
    <!-- 存檔 -->
    <div class="view" id="view-saves">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">存檔管理</span>
        <div class="nav-right"><div class="nav-btn" onclick="toast(T('存檔設置'))" role="button" tabindex="0" title="設置">⚙️</div></div>
      </div>
      <div class="scroll sys" id="saves-content"></div>
      <div class="input-bar"><button class="action-btn primary" style="flex:1" onclick="createSave()">💾 創建新存檔</button></div>
    </div>
    <!-- 搜索 -->
    <div class="view" id="view-search">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">搜索</span>
        <div class="nav-right"><div class="nav-btn" style="font-size:13px;width:auto;padding:0 8px" onclick="showAdvancedSearch()" role="button" tabindex="0" title="高級搜索">高級</div></div>
      </div>
      <div style="display:flex;gap:8px;padding:8px 16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider)">
        <button class="modal-btn active" id="search-tab-search" onclick="switchSearchTab('search')" style="flex:1;padding:8px;font-size:13px">🔍 搜索</button>
        <button class="modal-btn" id="search-tab-important" onclick="switchSearchTab('important')" style="flex:1;padding:8px;font-size:13px">⭐ 重要消息</button>
      </div>
      <div id="search-panel-search" style="display:flex;flex-direction:column;flex:1;min-height:0">
        <div class="search-bar">
          <div class="search-wrap">
            <span style="color:var(--text-tertiary)">🔍</span>
            <input type="text" class="search-input" placeholder="搜索故事內容" id="content-search" oninput="doContentSearch()">
          </div>
        </div>
        <div class="scroll sys" id="search-results"><div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">輸入關鍵詞搜索</div></div></div>
      </div>
      <div id="search-panel-important" style="display:none;flex-direction:column;flex:1;min-height:0">
        <div class="scroll sys" id="important-results"><div class="empty"><div class="empty-icon">⭐</div><div class="empty-title">載入中...</div></div></div>
      </div>
    </div>
    <!-- 指令管理 -->
    <div class="view" id="view-instructions">
      <div class="list-nav">
        <span class="list-nav-title" style="background:none;-webkit-text-fill-color:var(--text-primary)">指令管理</span>
        <div style="display:flex;gap:4px">
          <div class="nav-btn" onclick="startAnalyze()" title="分析Prompt" role="button" tabindex="0">🔍</div>
          <div class="nav-btn" onclick="startWizard()" title="AI生成指令" role="button" tabindex="0">🪄</div>
          <div class="nav-btn" onclick="importInst()" role="button" tabindex="0" title="導入">➕</div>
        </div>
      </div>
      <div class="scroll sys" id="inst-list"></div>
      <div class="tab-bar">
        <div class="tab-item" onclick="switchTab('stories')" role="button" tabindex="0"><span class="tab-icon">📚</span><span class="tab-label">故事</span></div>
        <div class="tab-item active" onclick="switchTab('instructions')" role="button" tabindex="0"><span class="tab-icon">📜</span><span class="tab-label">指令</span></div>
        <div class="tab-item" onclick="switchTab('settings')" role="button" tabindex="0"><span class="tab-icon">⚙️</span><span class="tab-label">設置</span></div>
      </div>
    </div>
    <!-- 設置 -->
    <div class="view" id="view-settings">
      <div class="list-nav">
        <span class="list-nav-title" style="background:none;-webkit-text-fill-color:var(--text-primary)">設置</span>
      </div>
      <div class="scroll sys" style="padding-bottom:80px">
        <div class="settings-section">
          <div class="settings-section-title">🎨 外觀</div>
          <div class="settings-card">
            <div class="settings-item" onclick="toggleTheme()"><span class="settings-item-label">主題</span><span class="settings-item-value" id="theme-val">深色模式 ›</span></div>
            <div class="settings-item" onclick="toggleScreen()"><span class="settings-item-label">屏幕模式</span><span class="settings-item-value" id="screen-val">手機模擬器 ›</span></div>
            <div class="settings-item" onclick="setChatBackground()"><span class="settings-item-label">聊天背景</span><span class="settings-item-value" id="chat-bg-val">默認 ›</span></div>
            <div class="settings-item" onclick="showFontSettings()"><span class="settings-item-label">字體大小</span><span class="settings-item-value" id="font-size-val">16px ›</span></div>
            <div class="settings-item" onclick="showLineHeightSettings()"><span class="settings-item-label">行間距</span><span class="settings-item-value" id="line-height-val">1.8x ›</span></div>
            <div class="settings-item" onclick="showParagraphSpacingSettings()"><span class="settings-item-label">段落間距</span><span class="settings-item-value" id="paragraph-spacing-val">1em ›</span></div>
          </div>
        </div>
        <div class="settings-section">
          <div class="settings-section-title">🤖 AI設置</div>
          <div class="settings-card">
            <div class="settings-item" onclick="goTo('view-api')"><span class="settings-item-label">API 預設管理</span><span class="settings-item-value">›</span></div>
            <div class="settings-item" onclick="showContextSettings()"><span class="settings-item-label">上下文設置</span><span class="settings-item-value" id="context-val">20條消息 ›</span></div>
            <div class="settings-item" onclick="showCharacterSelectionSettings()"><span class="settings-item-label">👥 智能角色選擇</span><span class="settings-item-value" id="char-selection-val">已開啟 ›</span></div>
            <div class="settings-item" onclick="showMaxTokensSettings()"><span class="settings-item-label">最大生成長度</span><span class="settings-item-value" id="max-tokens-val">4096 ›</span></div>
            <div class="settings-item" onclick="showStreamingSettings()"><span class="settings-item-label">流式響應</span><span class="settings-item-value" id="streaming-val">已開啟 ›</span></div>
            <div class="settings-item" onclick="showDefaultAIParams()"><span class="settings-item-label">AI 參數默認值</span><span class="settings-item-value" id="ai-params-val">T:0.8 ›</span></div>
            <div class="settings-item" onclick="showTemplateVarsSettings()"><span class="settings-item-label">模板變量</span><span class="settings-item-value" id="template-vars-val">設置 ›</span></div>
            <div class="settings-item"><span class="settings-item-label">一致性檢查</span><div class="toggle active" id="tog-consist" onclick="toggleSet('consist')"></div></div>
            <div class="settings-item"><span class="settings-item-label">自動章節總結</span><div class="toggle active" id="tog-summary" onclick="toggleSet('summary')"></div></div>
            <div class="settings-item"><span class="settings-item-label">自動生成摘要</span><div class="toggle active" id="tog-autoSummary" onclick="toggleSet('autoSummary')"></div></div>
            <div class="settings-item" onclick="showAutoSummaryFrequencySettings()"><span class="settings-item-label">摘要生成頻率</span><span class="settings-item-value" id="auto-summary-freq-val">每15條消息 ›</span></div>
            <div class="settings-item"><span class="settings-item-label">🕐 AI自動檢測時間</span><div class="toggle active" id="tog-autoDetectTime" onclick="toggleSet('autoDetectTime')"></div></div>
            <div class="settings-item"><span class="settings-item-label">🤖 AI智能提取Lorebook</span><div class="toggle" id="tog-autoLorebook" onclick="toggleSet('autoLorebook')"></div></div>
            <div class="settings-item" onclick="showAutoLorebookFrequencySettings()"><span class="settings-item-label">📊 Lorebook提取頻率</span><span class="settings-item-value" id="auto-lorebook-freq-val">每10條消息 ›</span></div>
          </div>
        </div>
        <div class="settings-section">
          <div class="settings-section-title">⌨️ 輸入</div>
          <div class="settings-card">
            <div class="settings-item" onclick="showTypingSpeedSettings()"><span class="settings-item-label">打字機效果</span><span class="settings-item-value" id="typing-speed-val">30ms ›</span></div>
            <div class="settings-item" onclick="toggleSendKey()"><span class="settings-item-label">發送快捷鍵</span><span class="settings-item-value" id="send-key-val">Enter ›</span></div>
          </div>
        </div>
        <div class="settings-section">
          <div class="settings-section-title">🌐 語言</div>
          <div class="settings-card">
            <div class="settings-item" onclick="showChineseConvertSettings()"><span class="settings-item-label">語言設置</span><span class="settings-item-value" id="cn-convert-val">简体 ›</span></div>
          </div>
        </div>
        <div class="settings-section">
          <div class="settings-section-title">💾 數據</div>
          <div class="settings-card">
            <div class="settings-item" onclick="showCloudSyncSettings()"><span class="settings-item-label">☁️ 雲端同步設置</span><span class="settings-item-value" id="cloud-sync-status">未設置 ›</span></div>
            <div class="settings-item" onclick="uploadToCloud()"><span class="settings-item-label">☁️ 上傳到雲端</span><span class="settings-item-value">›</span></div>
            <div class="settings-item" onclick="downloadFromCloud()"><span class="settings-item-label">☁️ 從雲端下載</span><span class="settings-item-value">›</span></div>
            <div class="settings-item" onclick="exportAll()"><span class="settings-item-label">導出所有數據</span><span class="settings-item-value">›</span></div>
            <div class="settings-item" onclick="importAll()"><span class="settings-item-label">導入數據</span><span class="settings-item-value">›</span></div>
            <div class="settings-item" onclick="exportBookTemplate()"><span class="settings-item-label">📋 導出書籍格式模板</span><span class="settings-item-value">›</span></div>
            <div class="settings-item danger" onclick="clearAll()"><span class="settings-item-label">清空所有數據</span><span class="settings-item-value">›</span></div>
          </div>
        </div>
        <div class="settings-section">
          <div class="settings-section-title">📱 應用</div>
          <div class="settings-card">
            <div class="settings-item" onclick="installPWA()"><span class="settings-item-label">安裝到桌面</span><span class="settings-item-value" id="pwa-install-status">›</span></div>
            <div class="settings-item" onclick="debugApiTest()"><span class="settings-item-label">🔧 API 連接調試</span><span class="settings-item-value">›</span></div>
            <div class="settings-item"><span class="settings-item-label">關於織夢</span><span class="settings-item-value">v6.1 ›</span></div>
          </div>
        </div>
      </div>
      <div class="tab-bar">
        <div class="tab-item" onclick="switchTab('stories')" role="button" tabindex="0"><span class="tab-icon">📚</span><span class="tab-label">故事</span></div>
        <div class="tab-item" onclick="switchTab('instructions')" role="button" tabindex="0"><span class="tab-icon">📜</span><span class="tab-label">指令</span></div>
        <div class="tab-item active" onclick="switchTab('settings')" role="button" tabindex="0"><span class="tab-icon">⚙️</span><span class="tab-label">設置</span></div>
      </div>
    </div>
    <!-- API設置 -->
    <div class="view" id="view-api">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">API 預設管理</span>
        <div class="nav-right"><div class="nav-btn" onclick="addApi()" role="button" tabindex="0" title="添加">➕</div></div>
      </div>
      <div class="scroll sys" id="api-list"></div>
    </div>
    <!-- 章節管理 -->
    <div class="view" id="view-chapters">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">章節管理</span>
        <div class="nav-right"><div class="nav-btn" onclick="addChapter()" role="button" tabindex="0" title="添加章節">➕</div></div>
      </div>
      <div class="scroll sys" id="chapter-list"></div>
    </div>
    <!-- 書籤列表 -->
    <div class="view" id="view-bookmarks">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">書籤列表</span>
        <div class="nav-right"></div>
      </div>
      <div class="scroll sys" id="bookmark-list"></div>
    </div>
    <!-- 財產系統 -->
    <div class="view" id="view-inventory">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">💰 財產</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="aiSyncInventory()" title="AI智能同步" role="button" tabindex="0">🤖</div>
          <div class="nav-btn" onclick="addInventoryItem()" role="button" tabindex="0" title="添加資產">➕</div>
        </div>
      </div>
      <div style="padding:8px 16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider)">
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input type="text" class="form-input" id="inventory-search" placeholder="🔍 搜索資產..." style="flex:1;min-width:120px;padding:6px 10px;font-size:13px" oninput="filterInventory()">
          <select class="form-input" id="inventory-filter" style="padding:6px 10px;font-size:13px" onchange="filterInventory()">
            <option value="all">全部</option>
            <option value="money">💰 金錢</option>
            <option value="property">🏠 房產</option>
            <option value="vehicle">🚗 載具</option>
            <option value="valuable">💎 貴重物品</option>
            <option value="other">📋 其他</option>
          </select>
        </div>
      </div>
      <div class="scroll sys" id="inventory-list" style="padding:12px 16px"></div>
    </div>
    <!-- 行程系統 -->
    <div class="view" id="view-schedule">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">📋 行程</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="aiSyncSchedule()" title="AI智能同步" role="button" tabindex="0">🤖</div>
          <div class="nav-btn" onclick="addScheduleItem()" role="button" tabindex="0" title="添加行程">➕</div>
        </div>
      </div>
      <div style="padding:8px 16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider)">
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input type="text" class="form-input" id="schedule-search" placeholder="🔍 搜索行程..." style="flex:1;min-width:120px;padding:6px 10px;font-size:13px" oninput="filterSchedule()">
          <select class="form-input" id="schedule-filter" style="padding:6px 10px;font-size:13px" onchange="filterSchedule()">
            <option value="all">全部</option>
            <option value="pending">⏳ 待辦</option>
            <option value="in_progress">🔄 進行中</option>
            <option value="completed">✅ 已完成</option>
          </select>
        </div>
      </div>
      <div class="scroll sys" id="schedule-list" style="padding:12px 16px"></div>
    </div>
    <!-- 分支管理 -->
    <div class="view" id="view-branches">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">分支管理</span>
        <div class="nav-right"><div class="nav-btn" onclick="createBranch()" role="button" tabindex="0" title="創建分支">➕</div></div>
      </div>
      <div class="scroll sys" id="branch-list"></div>
    </div>
    <!-- Lorebook 設定庫 -->
    <div class="view" id="view-lorebook">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">🔮 Lorebook</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="showAiLorebookModal()" title="AI生成" role="button" tabindex="0">🤖</div>
          <div class="nav-btn" onclick="showLorebookMergeSelect()" title="AI合併條目" role="button" tabindex="0">🔗</div>
          <div class="nav-btn" onclick="importFromLore()" title="從資料庫導入" role="button" tabindex="0">📥</div>
          <div class="nav-btn" onclick="addLorebook()" role="button" tabindex="0" title="添加">➕</div>
        </div>
      </div>
      <div style="padding:8px 16px;background:var(--bg-secondary);border-bottom:1px solid var(--divider)">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <div style="flex:1;position:relative">
            <span style="position:absolute;left:10px;top:50%;transform:translateY(-50%);color:var(--text-tertiary)">🔍</span>
            <input type="text" id="lorebook-search-input" placeholder="搜索條目..." oninput="filterLorebook()" style="width:100%;padding:8px 8px 8px 32px;border:1px solid var(--divider);border-radius:8px;background:var(--bg-primary);font-size:14px;box-sizing:border-box">
          </div>
          <select id="lorebook-filter-status" onchange="filterLorebook()" style="padding:8px;border:1px solid var(--divider);border-radius:8px;background:var(--bg-primary);font-size:13px">
            <option value="all">全部</option>
            <option value="enabled">已啟用</option>
            <option value="disabled">已禁用</option>
          </select>
        </div>
        <div style="font-size:12px;color:var(--text-tertiary)">當對話包含關鍵詞時，自動注入相關設定到 AI 上下文</div>
      </div>
      <div class="scroll sys" id="lorebook-list"></div>
    </div>
    <!-- v7: 角色卡片視圖 -->
    <div class="view" id="view-characters">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">角色狀態</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="toggleCharBatchMode()" title="批量操作" id="char-batch-btn" role="button" tabindex="0">☑️</div>
          <div class="nav-btn" onclick="showCharacterMenu()" title="更多" role="button" tabindex="0">⋯</div>
          <div class="nav-btn" onclick="addCharacterManual()" title="手動添加" role="button" tabindex="0">➕</div>
        </div>
      </div>
      <!-- v25: 搜索和筛选栏 -->
      <div class="char-filter-bar">
        <div class="char-search-wrap">
          <span class="char-search-icon">🔍</span>
          <input type="text" class="char-search-input" id="char-search-input" placeholder="搜索角色..." oninput="filterCharacters()">
        </div>
        <select class="char-filter-select" id="char-filter-category" onchange="filterCharacters()">
          <option value="all">全部分類</option>
          <option value="protagonist">⭐ 主角</option>
          <option value="supporting">👤 配角</option>
          <option value="npc">👥 NPC</option>
        </select>
      </div>
      <!-- v25: 批量操作栏（默认隐藏） -->
      <div class="char-batch-bar" id="char-batch-bar" style="display:none">
        <label class="char-batch-select-all">
          <input type="checkbox" id="char-select-all" onchange="toggleSelectAllChars()">
          <span>全選</span>
        </label>
        <span class="char-batch-count" id="char-batch-count">已選 0 個</span>
        <div class="char-batch-actions">
          <button class="char-batch-btn" onclick="batchDeleteChars()">🗑️ 刪除</button>
          <button class="char-batch-btn" onclick="batchExportChars()">📤 導出</button>
        </div>
      </div>
      <div class="scroll sys" id="character-list" style="position:relative"></div>
      <div class="input-bar" style="justify-content:space-between;padding:8px 16px">
        <span style="font-size:12px;color:var(--text-tertiary)" id="char-count">0 位角色</span>
        <div style="display:flex;gap:8px">
          <button class="action-btn" style="padding:8px 12px;font-size:12px" onclick="aiExtractAllMeetings()">📝 批量提取見面</button>
          <button class="action-btn primary" style="padding:8px 16px;font-size:13px" onclick="showAICharacterUpdate()">🤖 AI 更新狀態</button>
        </div>
      </div>
    </div>
    <!-- 指令生成向導 -->
    <div class="view" id="view-wizard">
      <div class="nav">
        <div class="nav-back" onclick="exitWizard()" role="button" tabindex="0" aria-label="退出">‹</div>
        <span class="nav-title" id="wizard-title">指令生成向導</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="showWizardHelp()" title="幫助" role="button" tabindex="0">❓</div>
        </div>
      </div>
      <div class="wizard-progress">
        <div class="wizard-progress-bar"><div class="wizard-progress-fill" id="wizard-progress-fill" style="width:12.5%"></div></div>
        <span class="wizard-progress-text" id="wizard-progress-text">1/8 基礎設定</span>
      </div>
      <div class="wizard-content" id="wizard-content">
        <!-- 動態內容 -->
      </div>
      <div class="wizard-footer">
        <button class="wizard-btn secondary" id="wizard-prev" onclick="wizardPrev()" disabled>上一步</button>
        <button class="wizard-btn primary" id="wizard-next" onclick="wizardNext()">下一步</button>
      </div>
    </div>
    <!-- Prompt 分析頁面 -->
    <div class="view" id="view-analyze">
      <div class="nav">
        <div class="nav-back" onclick="goBack()" role="button" tabindex="0" aria-label="返回">‹</div>
        <span class="nav-title">Prompt 分析</span>
        <div class="nav-right">
          <div class="nav-btn" onclick="showAnalyzeHelp()" title="幫助" role="button" tabindex="0">❓</div>
        </div>
      </div>
      <div class="wizard-content" id="analyze-content">
        <!-- 動態內容 -->
      </div>
    </div>
  </div>
</div>
<!-- 隱藏的文件輸入 -->
<input type="file" id="image-upload" accept="image/*" style="display:none" onchange="handleImageUpload(event)">
<input type="file" id="analyze-file" accept=".txt,.md,.docx" style="display:none" onchange="handleAnalyzeFile(event)">
<!-- 遮罩 -->
<div class="overlay" id="overlay" onclick="closeAll()"></div>
<!-- 底部面板 -->
<div class="bottom-sheet" id="sheet">
  <div class="bottom-sheet-handle"></div>
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
    <div class="bottom-sheet-title" style="margin:0">故事設置</div>
    <button onclick="closeAll()" style="background:none;border:none;font-size:24px;color:var(--text-tertiary);cursor:pointer;padding:4px 8px;line-height:1">✕</button>
  </div>
  <div class="sheet-grid">
    <div class="sheet-item" onclick="renameCurrentStory()" role="button" tabindex="0"><div class="sheet-item-icon">✏️</div><div class="sheet-item-label">重命名</div></div>
    <div class="sheet-item" onclick="goTo('view-characters');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">👥</div><div class="sheet-item-label">角色狀態</div></div>
    <div class="sheet-item" onclick="showSceneManager()" role="button" tabindex="0"><div class="sheet-item-icon">🎬</div><div class="sheet-item-label">場景管理</div></div>
    <div class="sheet-item" onclick="showPlayerPanel()" role="button" tabindex="0"><div class="sheet-item-icon">👤</div><div class="sheet-item-label">我的狀態</div></div>
    <div class="sheet-item" onclick="goTo('view-inventory');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">💰</div><div class="sheet-item-label">財產</div></div>
    <div class="sheet-item" onclick="goTo('view-schedule');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">📋</div><div class="sheet-item-label">行程</div></div>
    <div class="sheet-item" onclick="goTo('view-timeline');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">📅</div><div class="sheet-item-label">時間軸</div></div>
    <div class="sheet-item" onclick="goTo('view-foreshadow');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">📌</div><div class="sheet-item-label">伏筆事件</div></div>
    <div class="sheet-item" onclick="goTo('view-chapters');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">📑</div><div class="sheet-item-label">章節管理</div></div>
    <div class="sheet-item" onclick="goTo('view-bookmarks');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">🔖</div><div class="sheet-item-label">書籤列表</div></div>
    <div class="sheet-item" onclick="goTo('view-saves');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">💾</div><div class="sheet-item-label">存檔管理</div></div>
    <div class="sheet-item" onclick="goTo('view-branches');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">🔀</div><div class="sheet-item-label">分支管理</div></div>
    <div class="sheet-item" onclick="goTo('view-lorebook');closeAll()" role="button" tabindex="0"><div class="sheet-item-icon">🔮</div><div class="sheet-item-label">Lorebook</div></div>
    <div class="sheet-item" onclick="showStoryAIParams()" role="button" tabindex="0"><div class="sheet-item-icon">🎛️</div><div class="sheet-item-label">AI參數</div></div>
    <div class="sheet-item" onclick="showMemoryManager()" role="button" tabindex="0"><div class="sheet-item-icon">🧠</div><div class="sheet-item-label">記憶管理</div></div>
    <div class="sheet-item" onclick="showFindReplace()" role="button" tabindex="0"><div class="sheet-item-icon">🔍</div><div class="sheet-item-label">查找替換</div></div>
    <div class="sheet-item" onclick="showStats()" role="button" tabindex="0"><div class="sheet-item-icon">📊</div><div class="sheet-item-label">統計面板</div></div>
    <div class="sheet-item" onclick="exportStory()" role="button" tabindex="0"><div class="sheet-item-icon">📄</div><div class="sheet-item-label">導出 Markdown</div></div>
    <div class="sheet-item" onclick="exportStoryJSON()" role="button" tabindex="0"><div class="sheet-item-icon">📦</div><div class="sheet-item-label">導出完整數據包</div></div>
    <div class="sheet-item" onclick="importStoryJSON()" role="button" tabindex="0"><div class="sheet-item-icon">📥</div><div class="sheet-item-label">導入故事數據包</div></div>
    <div class="sheet-item danger" onclick="restartStory()" role="button" tabindex="0"><div class="sheet-item-icon">🔄</div><div class="sheet-item-label">重新開始</div></div>
  </div>
</div>
<!-- 更多菜單 -->
<div class="context-menu" id="more-menu">
  <!-- v19: 經營模式選項 -->
  <div class="context-menu-item sim-only" onclick="showSimResourceModal();hideMenu()" style="display:none" role="menuitem" tabindex="0">🎮 資源管理</div>
  <div class="context-menu-item sim-only" onclick="simNextDay();hideMenu()" style="display:none" role="menuitem" tabindex="0">⏭️ 進入下一天</div>
  <div class="context-menu-item sim-only" onclick="showSimImportModal();hideMenu()" style="display:none" role="menuitem" tabindex="0">📥 導入存檔</div>
  <div class="context-menu-item sim-only" onclick="showSimExportModal();hideMenu()" style="display:none" role="menuitem" tabindex="0">📤 導出存檔</div>
  <div class="context-menu-divider sim-only" style="display:none"></div>
  <div class="context-menu-item" onclick="aiConsistencyCheck();hideMenu()" role="menuitem" tabindex="0">🔍 AI一致性檢查</div>
  <div class="context-menu-item" onclick="aiChapterSummary();hideMenu()" role="menuitem" tabindex="0">📝 AI章節總結</div>
</div>
<!-- 消息菜單 -->
<div class="context-menu" id="msg-menu">
  <div class="context-menu-item" onclick="editMsg()" role="menuitem" tabindex="0">✏️ 編輯</div>
  <div class="context-menu-item" onclick="regenerateMsg()" role="menuitem" tabindex="0">🔄 重新生成</div>
  <div class="context-menu-item" onclick="resendMsg()" role="menuitem" tabindex="0">📤 重新發送</div>
  <div class="context-menu-item" onclick="markForeshadow()" role="menuitem" tabindex="0">📌 標記伏筆</div>
  <div class="context-menu-item" onclick="addPlotTag()" role="menuitem" tabindex="0">🏷️ 添加標籤</div>
  <div class="context-menu-divider"></div>
  <div class="context-menu-item" onclick="rollbackTo()" role="menuitem" tabindex="0">↩️ 回溯到此</div>
  <div class="context-menu-item" onclick="copyMsg()" role="menuitem" tabindex="0">📋 複製</div>
  <div class="context-menu-item" onclick="addBookmark()" role="menuitem" tabindex="0">🔖 添加書籤</div>
  <div class="context-menu-divider"></div>
  <div class="context-menu-item danger" onclick="deleteMsg()" role="menuitem" tabindex="0">🗑️ 刪除消息</div>
</div>
<!-- 角色菜單 -->
<div class="context-menu" id="char-menu">
  <div class="context-menu-item" onclick="showAICharacterUpdate();hideMenu()" role="menuitem" tabindex="0">🔄 AI 更新狀態</div>
  <div class="context-menu-divider"></div>
  <div class="context-menu-item" onclick="importCharacterCard();hideMenu()" role="menuitem" tabindex="0">📥 導入角色卡（文件）</div>
  <div class="context-menu-item" onclick="importCharacterFromURL();hideMenu()" role="menuitem" tabindex="0">🔗 從 URL 導入</div>
  <div class="context-menu-item" onclick="exportAllCharacters();hideMenu()" role="menuitem" tabindex="0">📤 導出所有角色</div>
  <div class="context-menu-divider"></div>
  <div class="context-menu-item danger" onclick="clearAllCharacters();hideMenu()" role="menuitem" tabindex="0">🗑️ 清空所有角色</div>
</div>
<!-- 故事菜單 -->
<div class="context-menu" id="story-menu">
  <div class="context-menu-item" onclick="renameStoryFromMenu()" role="menuitem" tabindex="0">✏️ 重命名</div>
  <div class="context-menu-item" onclick="editStoryCover()" role="menuitem" tabindex="0">🖼️ 更換封面</div>
  <div class="context-menu-item" onclick="toggleStoryPin()" role="menuitem" tabindex="0">📌 置頂/取消置頂</div>
  <div class="context-menu-divider"></div>
  <div class="context-menu-item danger" onclick="deleteStoryFromMenu()" role="menuitem" tabindex="0">🗑️ 刪除故事</div>
</div>

<!-- 確認框 -->
<div class="modal" id="confirm-modal" style="z-index:110">
  <div class="modal-title" id="confirm-title">確認</div>
  <div class="modal-content" id="confirm-content">確定要執行此操作嗎？</div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="cancelConfirm()">取消</button>
    <button class="modal-btn confirm" id="confirm-btn" onclick="confirmAction()">確定</button>
  </div>
</div>
<!-- 輸入框 -->
<div class="modal" id="input-modal" style="z-index:110">
  <div class="modal-title" id="input-title">輸入</div>
  <div class="modal-content" id="input-desc"></div>
  <input type="text" class="modal-input" id="modal-input" placeholder="">
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('input-modal')">取消</button>
    <button class="modal-btn confirm" onclick="confirmInput()">確定</button>
  </div>
</div>
<!-- 新建故事 -->
<div class="modal" id="new-story-modal" style="max-width:420px">
  <div class="modal-title">新建故事</div>
  <div class="form-group"><label class="form-label">故事標題</label><input type="text" class="form-input" id="new-title" placeholder="輸入故事標題"></div>
  <div class="form-group"><label class="form-label">簡介（可選）</label><textarea class="form-textarea" id="new-desc" placeholder="簡單描述這個故事..."></textarea></div>
  <div class="form-group">
    <label class="form-label">故事模式</label>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <div class="mode-card active" id="mode-normal" onclick="selectStoryMode('normal')">
        <div style="font-size:24px;margin-bottom:4px">📖</div>
        <div style="font-weight:600;font-size:13px">普通模式</div>
        <div style="font-size:11px;color:var(--text-tertiary)">角色狀態追蹤</div>
      </div>
      <div class="mode-card" id="mode-simulation" onclick="selectStoryMode('simulation')">
        <div style="font-size:24px;margin-bottom:4px">🎮</div>
        <div style="font-weight:600;font-size:13px">經營模式</div>
        <div style="font-size:11px;color:var(--text-tertiary)">資源面板+存檔</div>
      </div>
    </div>
  </div>
  <div id="sim-mode-options" style="display:none">
    <div class="form-group">
      <label class="form-label">初始資源（可稍後編輯）</label>
      <div id="new-sim-resources" style="display:flex;flex-direction:column;gap:6px">
        <div style="display:flex;gap:6px;align-items:center">
          <input type="text" class="form-input" style="width:60px" placeholder="💰" maxlength="2" value="💰">
          <input type="text" class="form-input" style="flex:1" placeholder="名稱" value="金幣">
          <input type="number" class="form-input" style="width:80px" placeholder="數值" value="10000">
          <button onclick="removeSimResource(this)" style="background:none;border:none;color:var(--error);cursor:pointer">✕</button>
        </div>
      </div>
      <button onclick="addSimResource()" style="margin-top:8px;background:var(--bg-tertiary);border:none;padding:6px 12px;border-radius:6px;color:var(--text-secondary);cursor:pointer;font-size:12px">➕ 添加資源</button>
    </div>
  </div>
  <div class="form-group"><label class="form-label">標籤（空格分隔）</label><input type="text" class="form-input" id="new-tags" placeholder="宮鬥 古風 戀愛"></div>
  <div class="form-group"><label class="form-label">綁定指令</label><select class="form-select" id="new-inst"><option value="">不綁定指令</option></select></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('new-story-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveNewStory()">創建</button>
  </div>
</div>
<!-- API設置 -->
<div class="modal" id="api-modal" style="max-width:400px">
  <div class="modal-title">API 設置</div>
  <div class="form-group"><label class="form-label">預設名稱</label><input type="text" class="form-input" id="api-name" placeholder="例如: Claude API"></div>
  <div class="form-group"><label class="form-label">API 類型</label><select class="form-select" id="api-type" onchange="updateApiFields()"><option value="anthropic">Anthropic (Claude)</option><option value="openai">OpenAI (GPT)</option><option value="custom">自定義 API</option></select></div>
  <div class="form-group"><label class="form-label">API Key</label><input type="password" class="form-input" id="api-key" placeholder="sk-..."></div>
  <div class="form-group"><label class="form-label">模型</label><input type="text" class="form-input" id="api-model" list="model-list" placeholder="選擇或輸入模型名稱"><datalist id="model-list"><option value="claude-sonnet-4-20250514">Claude Sonnet 4</option><option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option><option value="claude-3-opus-20240229">Claude 3 Opus</option></datalist></div>
  <div class="form-group hidden" id="api-url-group"><label class="form-label">API URL</label><input type="text" class="form-input" id="api-url" placeholder="https://api.example.com"><div style="margin-top:6px"><label style="font-size:12px;color:var(--text-secondary);display:flex;align-items:center;gap:6px;cursor:pointer"><input type="checkbox" id="api-url-autocomplete" checked> 自動補全 /v1/chat/completions</label></div></div>
  <div class="form-group"><button type="button" class="action-btn secondary" style="width:100%" onclick="testApi()">🔗 測試連接</button><div id="api-test-result" style="margin-top:8px;font-size:12px;display:none"></div></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('api-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveApi()">保存</button>
  </div>
</div>
<!-- v19: 經營模式 - 資源管理 Modal -->
<div class="modal" id="sim-resource-modal" style="max-width:min(95%,420px)">
  <div class="modal-title">🎮 資源管理</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    自定義追蹤的資源數值，會顯示在頂部面板
  </div>
  <div class="form-group">
    <label class="form-label">當前天數/回合</label>
    <div style="display:flex;gap:8px;align-items:center">
      <input type="number" class="form-input" id="sim-current-day" min="1" value="1" style="width:100px">
      <button onclick="simDayMinus()" style="background:var(--bg-tertiary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer">−</button>
      <button onclick="simDayPlus()" style="background:var(--bg-tertiary);border:none;padding:8px 12px;border-radius:6px;cursor:pointer">+</button>
    </div>
  </div>
  <div class="form-group">
    <label class="form-label">資源列表</label>
    <div id="sim-resource-list" style="display:flex;flex-direction:column;gap:8px;max-height:250px;overflow-y:auto">
      <!-- 動態渲染 -->
    </div>
    <button onclick="addSimResourceInModal()" style="margin-top:10px;background:var(--bg-tertiary);border:none;padding:8px 14px;border-radius:6px;color:var(--text-secondary);cursor:pointer;font-size:13px;width:100%">➕ 添加新資源</button>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('sim-resource-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveSimResources()">保存</button>
  </div>
</div>
<!-- v19: 經營模式 - 存檔導入 Modal -->
<div class="modal" id="sim-import-modal" style="max-width:min(95%,500px)">
  <div class="modal-title">📥 導入存檔</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    貼入文遊 prompt 生成的存檔內容，會自動解析資源數值
  </div>
  <div class="form-group">
    <label class="form-label">存檔內容</label>
    <textarea class="form-input" id="sim-import-content" style="min-height:200px;font-family:monospace;font-size:12px" placeholder="貼入存檔內容..."></textarea>
  </div>
  <div class="form-group">
    <label class="form-label">解析規則（正則表達式，可選）</label>
    <input type="text" class="form-input" id="sim-import-regex" placeholder="例如：💰 現金：([\\d,]+)元">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">留空則使用默認規則解析常見格式</div>
  </div>
  <div id="sim-import-preview" style="display:none;background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:12px">
    <div style="font-size:12px;font-weight:600;margin-bottom:8px">📊 解析預覽</div>
    <div id="sim-import-preview-content"></div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn" style="background:var(--bg-tertiary);color:var(--text-secondary)" onclick="parseSimImport()">🔍 解析預覽</button>
    <button class="modal-btn cancel" onclick="closeModal('sim-import-modal')">取消</button>
    <button class="modal-btn confirm" onclick="applySimImport()">導入</button>
  </div>
</div>
<!-- v19: 經營模式 - 存檔導出 Modal -->
<div class="modal" id="sim-export-modal" style="max-width:min(95%,500px)">
  <div class="modal-title">📤 導出存檔</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    生成當前狀態的存檔，可貼到新對話繼續遊戲
  </div>
  <div class="form-group">
    <label class="form-label">存檔格式</label>
    <select class="form-select" id="sim-export-format" onchange="generateSimExport()">
      <option value="simple">簡潔格式</option>
      <option value="detailed">詳細格式</option>
      <option value="custom">自定義模板</option>
    </select>
  </div>
  <div class="form-group" id="sim-export-template-group" style="display:none">
    <label class="form-label">自定義模板</label>
    <textarea class="form-input" id="sim-export-template" style="min-height:100px;font-family:monospace;font-size:12px" placeholder="使用 {day} {resources} {summary} 等變量"></textarea>
  </div>
  <div class="form-group">
    <label class="form-label">存檔內容</label>
    <textarea class="form-input" id="sim-export-content" style="min-height:200px;font-family:monospace;font-size:12px" readonly></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn" style="background:var(--bg-tertiary);color:var(--text-secondary)" onclick="copySimExport()">📋 複製</button>
    <button class="modal-btn confirm" onclick="closeModal('sim-export-modal')">完成</button>
  </div>
</div>
<!-- Toast -->
<div class="toast" id="toast"><span id="toast-text"></span></div>
<!-- Loading -->
<div class="loading" id="loading"><div class="loading-spinner"></div><div class="loading-text" id="loading-text">處理中...</div></div>
<!-- 上下文設置 Modal -->
<div class="modal" id="context-modal">
  <div class="modal-title">上下文設置</div>

  <div class="form-group">
    <label class="form-label">上下文消息數量</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">發送給 AI 的歷史消息數量，越多越能理解上下文，但會消耗更多 Token</p>
    <input type="number" class="form-input" id="context-count" min="1" max="500" placeholder="輸入數量，例如：20">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">建議範圍：10-50，最大支持 500</div>
  </div>

  <div class="form-group" style="margin-top:16px">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="smart-context-enabled">
      <span class="form-label" style="margin:0">🧠 啟用智能上下文選擇</span>
    </label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-top:8px">
      智能選擇最相關的消息，而不只是最近的N條。包括：<br>
      • 最近的消息（保證連貫性）<br>
      • 重要標記的消息（⭐）<br>
      • 高分消息（包含角色名、關鍵詞等）
    </p>
  </div>

  <div id="smart-context-options" style="margin-top:16px;padding:12px;background:var(--bg-tertiary);border-radius:8px">
    <div class="form-group">
      <label class="form-label">必選最近消息數量</label>
      <input type="number" class="form-input" id="smart-context-recent" min="5" max="50" placeholder="例如：10">
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">保證對話連貫性，建議 5-15 條</div>
    </div>

    <div class="form-group" style="margin-top:12px">
      <label class="form-label">最低分數閾值</label>
      <input type="number" class="form-input" id="smart-context-min-score" min="0" max="100" placeholder="例如：30">
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">只選擇分數高於此值的消息，建議 20-40 分</div>
    </div>
  </div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('context-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveContextSettings()">保存</button>
  </div>
</div>

<!-- 智能角色選擇 Modal -->
<div class="modal" id="character-selection-modal">
  <div class="modal-title">👥 智能角色選擇</div>
  <p style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    只發送最近出場的角色信息給 AI，節省 tokens 消耗
  </p>

  <div class="form-group">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="smart-character-enabled">
      <span class="form-label" style="margin:0">🧠 啟用智能角色選擇</span>
    </label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-top:8px">
      智能選擇應該發送的角色，包括：<br>
      • 最近N條消息中提到的角色<br>
      • 用戶當前輸入中提到的角色<br>
      • 標記為主要角色的角色
    </p>
  </div>

  <div id="smart-character-options" style="margin-top:16px;padding:12px;background:var(--bg-tertiary);border-radius:8px">
    <div class="form-group">
      <label class="form-label">檢查最近消息數量</label>
      <input type="number" class="form-input" id="character-recent-messages" min="5" max="100" placeholder="例如：20">
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">檢查最近N條消息中提到的角色，建議 15-30 條</div>
    </div>

    <div class="form-group" style="margin-top:12px">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
        <input type="checkbox" id="always-include-main-chars">
        <span class="form-label" style="margin:0">總是包含主要角色</span>
      </label>
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">
        無論是否最近出場，都會包含標記為「主要」分類的角色
      </div>
    </div>
  </div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('character-selection-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveCharacterSelectionSettings()">保存</button>
  </div>
</div>

<!-- 最大 Token Modal -->
<div class="modal" id="max-tokens-modal">
  <div class="modal-title">最大生成長度</div>
  <div class="form-group">
    <label class="form-label">Max Tokens</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">AI 單次回復的最大長度，越大回復越長但也越慢</p>
    <input type="number" class="form-input" id="max-tokens-input" min="100" placeholder="輸入數量，例如：4096">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">建議範圍：1024-8192，可根據模型支持自行調整</div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('max-tokens-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveMaxTokensSettings()">保存</button>
  </div>
</div>
<!-- 打字機效果 Modal -->
<div class="modal" id="typing-modal">
  <div class="modal-title">打字機效果</div>
  <div class="form-group">
    <label class="form-label">打字速度</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">每個字顯示的間隔時間，0 為關閉打字機效果</p>
    <select class="form-select" id="typing-speed-select">
      <option value="0">關閉</option>
      <option value="10">10ms（快速）</option>
      <option value="20">20ms</option>
      <option value="30">30ms（推薦）</option>
      <option value="50">50ms</option>
      <option value="80">80ms（慢速）</option>
    </select>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('typing-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveTypingSpeedSettings()">保存</button>
  </div>
</div>
<!-- 流式響應設置 Modal -->
<div class="modal" id="streaming-modal">
  <div class="modal-title">⚡ 流式響應</div>
  <div class="form-group">
    <label class="form-label">啟用流式響應</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">AI 邊生成邊顯示，幾秒鐘就能開始閱讀，並可隨時停止生成</p>
    <div style="display:flex;align-items:center;gap:12px">
      <div class="toggle active" id="toggle-streaming" onclick="toggleStreamingEnabled()"></div>
      <span id="toggle-streaming-text" style="font-size:13px;color:var(--text-secondary)">已開啟</span>
    </div>
  </div>
  <div id="streaming-advanced-options">
    <div class="form-group">
      <label class="form-label">打字機延遲</label>
      <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">收到文字後的顯示延遲，讓流式顯示更平滑</p>
      <select class="form-select" id="streaming-chunk-delay-select">
        <option value="0">無延遲（立即顯示）</option>
        <option value="10">10ms（極快）</option>
        <option value="20">20ms（推薦）</option>
        <option value="30">30ms</option>
        <option value="50">50ms（平滑）</option>
      </select>
    </div>
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;font-size:12px;color:var(--text-secondary);margin-top:12px">
      <div style="font-weight:600;margin-bottom:6px">💡 提示</div>
      <div style="line-height:1.6">
        • 流式響應可大幅減少等待時間<br>
        • 部分 API 可能不支持流式，會自動降級<br>
        • 停止生成時會詢問是否保存已生成內容
      </div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('streaming-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveStreamingSettings()">保存</button>
  </div>
</div>
<!-- 字體大小 Modal -->
<div class="modal" id="font-size-modal">
  <div class="modal-title">📝 字體大小</div>
  <div class="form-group">
    <label class="form-label">選擇字體大小</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">調整故事內容的字體大小，找到最舒適的閱讀體驗</p>
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px">
      <button class="font-option" data-size="14" onclick="selectFontSize(14)">
        <span style="font-size:14px">小</span>
        <span style="font-size:11px;color:var(--text-tertiary)">14px</span>
      </button>
      <button class="font-option" data-size="16" onclick="selectFontSize(16)">
        <span style="font-size:16px">中</span>
        <span style="font-size:11px;color:var(--text-tertiary)">16px</span>
      </button>
      <button class="font-option" data-size="18" onclick="selectFontSize(18)">
        <span style="font-size:18px">大</span>
        <span style="font-size:11px;color:var(--text-tertiary)">18px</span>
      </button>
      <button class="font-option" data-size="20" onclick="selectFontSize(20)">
        <span style="font-size:20px">特大</span>
        <span style="font-size:11px;color:var(--text-tertiary)">20px</span>
      </button>
    </div>
    <div style="margin-top:16px;padding:16px;background:var(--bg-tertiary);border-radius:8px">
      <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">預覽效果</div>
      <div id="font-preview" style="font-family:'Noto Serif SC',Georgia,serif;line-height:1.8">
        陛下緩步行至御花園，只見桃花灼灼，嫣然綻放於枝頭。
      </div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('font-size-modal')">關閉</button>
  </div>
</div>
<!-- 行間距 Modal -->
<div class="modal" id="line-height-modal">
  <div class="modal-title">📏 行間距</div>
  <div class="form-group">
    <label class="form-label">選擇行間距</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">調整行與行之間的距離，影響閱讀節奏</p>
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px">
      <button class="font-option" data-lh="1.5" onclick="selectLineHeight(1.5)">
        <span>緊湊</span>
        <span style="font-size:11px;color:var(--text-tertiary)">1.5x</span>
      </button>
      <button class="font-option" data-lh="1.6" onclick="selectLineHeight(1.6)">
        <span>標準</span>
        <span style="font-size:11px;color:var(--text-tertiary)">1.6x</span>
      </button>
      <button class="font-option" data-lh="1.8" onclick="selectLineHeight(1.8)">
        <span>舒適</span>
        <span style="font-size:11px;color:var(--text-tertiary)">1.8x</span>
      </button>
      <button class="font-option" data-lh="2.0" onclick="selectLineHeight(2.0)">
        <span>寬鬆</span>
        <span style="font-size:11px;color:var(--text-tertiary)">2.0x</span>
      </button>
    </div>
    <div style="margin-top:16px;padding:16px;background:var(--bg-tertiary);border-radius:8px">
      <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">預覽效果</div>
      <div id="line-height-preview" style="font-family:'Noto Serif SC',Georgia,serif;font-size:16px">
        陛下緩步行至御花園，只見桃花灼灼，嫣然綻放於枝頭。花瓣隨風飄落，如粉色的雪，輕柔地落在你的肩頭。
      </div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('line-height-modal')">關閉</button>
  </div>
</div>
<!-- 段落間距 Modal -->
<div class="modal" id="paragraph-spacing-modal">
  <div class="modal-title">📐 段落間距</div>
  <div class="form-group">
    <label class="form-label">選擇段落間距</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">調整段落與段落之間的距離</p>
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px">
      <button class="font-option" data-ps="0.3" onclick="selectParagraphSpacing('0.3em')">
        <span>緊湊</span>
        <span style="font-size:11px;color:var(--text-tertiary)">0.3em</span>
      </button>
      <button class="font-option" data-ps="0.5" onclick="selectParagraphSpacing('0.5em')">
        <span>較小</span>
        <span style="font-size:11px;color:var(--text-tertiary)">0.5em</span>
      </button>
      <button class="font-option" data-ps="0.7" onclick="selectParagraphSpacing('0.7em')">
        <span>適中</span>
        <span style="font-size:11px;color:var(--text-tertiary)">0.7em</span>
      </button>
      <button class="font-option" data-ps="1" onclick="selectParagraphSpacing('1em')">
        <span>標準</span>
        <span style="font-size:11px;color:var(--text-tertiary)">1em</span>
      </button>
    </div>
    <div style="margin-top:16px;padding:16px;background:var(--bg-tertiary);border-radius:8px">
      <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">預覽效果</div>
      <div id="paragraph-spacing-preview" class="msg-ai-story" style="font-family:'Noto Serif SC',Georgia,serif;font-size:16px">
        <p style="text-indent:0">陛下緩步行至御花園，只見桃花灼灼，嫣然綻放於枝頭。</p>
        <p>花瓣隨風飄落，如粉色的雪，輕柔地落在你的肩頭。微風拂過，帶來陣陣花香。</p>
        <p>遠處傳來宮女的輕聲細語，為這靜謐的午後增添了幾分生氣。</p>
      </div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('paragraph-spacing-modal')">關閉</button>
  </div>
</div>
<!-- 自動摘要頻率 Modal -->
<div class="modal" id="auto-summary-freq-modal">
  <div class="modal-title">📝 自動摘要頻率</div>
  <div class="form-group">
    <label class="form-label">選擇生成頻率</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">每經過指定數量的消息後，自動生成一份滾動摘要</p>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
      <button class="font-option" data-freq="10" onclick="selectAutoSummaryFrequency(10)">
        <span>頻繁</span>
        <span style="font-size:11px;color:var(--text-tertiary)">10條</span>
      </button>
      <button class="font-option" data-freq="15" onclick="selectAutoSummaryFrequency(15)">
        <span>標準</span>
        <span style="font-size:11px;color:var(--text-tertiary)">15條</span>
      </button>
      <button class="font-option" data-freq="20" onclick="selectAutoSummaryFrequency(20)">
        <span>適中</span>
        <span style="font-size:11px;color:var(--text-tertiary)">20條</span>
      </button>
      <button class="font-option" data-freq="30" onclick="selectAutoSummaryFrequency(30)">
        <span>稀疏</span>
        <span style="font-size:11px;color:var(--text-tertiary)">30條</span>
      </button>
      <button class="font-option" data-freq="50" onclick="selectAutoSummaryFrequency(50)">
        <span>很少</span>
        <span style="font-size:11px;color:var(--text-tertiary)">50條</span>
      </button>
    </div>
    <div style="margin-top:16px;padding:12px;background:var(--bg-tertiary);border-radius:8px;font-size:12px;color:var(--text-secondary);line-height:1.6">
      💡 <strong>建議：</strong>較小的值會生成更多摘要，更好地保存細節，但會增加 API 調用次數。較大的值則相反。
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('auto-summary-freq-modal')">關閉</button>
  </div>
</div>
<!-- Lorebook提取頻率設置 Modal -->
<div class="modal" id="auto-lorebook-freq-modal">
  <div class="modal-title">🤖 AI提取Lorebook頻率</div>
  <div class="form-group">
    <label class="form-label">選擇提取頻率</label>
    <p style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">每經過指定數量的消息後，AI自動分析對話並提取Lorebook</p>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
      <button class="font-option" data-freq="5" onclick="selectAutoLorebookFrequency(5)">
        <span>頻繁</span>
        <span style="font-size:11px;color:var(--text-tertiary)">5條</span>
      </button>
      <button class="font-option" data-freq="10" onclick="selectAutoLorebookFrequency(10)">
        <span>標準</span>
        <span style="font-size:11px;color:var(--text-tertiary)">10條</span>
      </button>
      <button class="font-option" data-freq="15" onclick="selectAutoLorebookFrequency(15)">
        <span>適中</span>
        <span style="font-size:11px;color:var(--text-tertiary)">15條</span>
      </button>
      <button class="font-option" data-freq="20" onclick="selectAutoLorebookFrequency(20)">
        <span>稀疏</span>
        <span style="font-size:11px;color:var(--text-tertiary)">20條</span>
      </button>
      <button class="font-option" data-freq="30" onclick="selectAutoLorebookFrequency(30)">
        <span>很少</span>
        <span style="font-size:11px;color:var(--text-tertiary)">30條</span>
      </button>
    </div>
    <div style="margin-top:16px;padding:12px;background:var(--bg-tertiary);border-radius:8px;font-size:12px;color:var(--text-secondary);line-height:1.6">
      💡 <strong>建議：</strong>較小的值會更頻繁地提取信息，但會增加 API 調用次數和提示頻率。建議設置為10-15條。
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('auto-lorebook-freq-modal')">關閉</button>
  </div>
</div>
<!-- Lorebook 編輯 Modal -->
<div class="modal" id="lorebook-modal" style="max-width:min(95%,450px);max-height:85vh;overflow-y:auto">
  <div class="modal-title">🔮 編輯 Lorebook 條目</div>
  <input type="hidden" id="lorebook-id">
  <div class="form-group">
    <label class="form-label">名稱</label>
    <input type="text" class="form-input" id="lorebook-name" placeholder="例如：夜寒 - 基本人設">
  </div>
  <div class="form-group">
    <label class="form-label">觸發關鍵詞（逗號分隔）</label>
    <input type="text" class="form-input" id="lorebook-keywords" placeholder="例如：夜寒, 皇夫, 長樂宮主人">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">當對話中出現這些詞時會觸發注入</div>
  </div>
  <div class="form-group">
    <label class="form-label">內容</label>
    <textarea class="form-input" id="lorebook-content" style="min-height:120px" placeholder="要注入的設定內容..."></textarea>
  </div>
  <div class="form-group">
    <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="toggleLorebookAdvanced()">
      <label class="form-label" style="margin:0">⚙️ 進階設置</label>
      <span id="lorebook-advanced-toggle" style="color:var(--text-tertiary)">▼</span>
    </div>
    <div id="lorebook-advanced" style="display:none;margin-top:12px">
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
        <div>
          <label style="font-size:12px;color:var(--text-secondary)">檢測深度</label>
          <select class="form-select" id="lorebook-depth" style="margin-top:4px">
            <option value="1">最近 1 條消息</option>
            <option value="2" selected>最近 2 條消息</option>
            <option value="3">最近 3 條消息</option>
            <option value="5">最近 5 條消息</option>
          </select>
        </div>
        <div>
          <label style="font-size:12px;color:var(--text-secondary)">優先級</label>
          <input type="number" class="form-input" id="lorebook-priority" value="100" style="margin-top:4px">
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
        <div>
          <label style="font-size:12px;color:var(--text-secondary)">冷卻（消息數）</label>
          <input type="number" class="form-input" id="lorebook-cooldown" value="0" min="0" style="margin-top:4px">
        </div>
        <div>
          <label style="font-size:12px;color:var(--text-secondary)">最大觸發次數</label>
          <input type="number" class="form-input" id="lorebook-max-triggers" value="0" min="0" style="margin-top:4px" placeholder="0=無限">
        </div>
      </div>
      <label style="font-size:13px;color:var(--text-secondary);display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="lorebook-one-time"> 一次性觸發（觸發後自動禁用）
      </label>
    </div>
  </div>
  <div class="form-group">
    <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="toggleLorebookConditions()">
      <label class="form-label" style="margin:0">🔐 觸發條件（可選）</label>
      <span id="lorebook-conditions-toggle" style="color:var(--text-tertiary)">▼</span>
    </div>
    <div id="lorebook-conditions" style="display:none;margin-top:12px">
      <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">除了關鍵詞匹配，還需滿足以下條件才會觸發</div>
      <div id="lorebook-condition-list"></div>
      <button class="action-btn secondary" style="width:100%;margin-top:8px" onclick="addLorebookCondition()">➕ 添加條件</button>
      <div style="margin-top:12px">
        <label style="font-size:12px;color:var(--text-secondary)">條件邏輯</label>
        <div style="display:flex;gap:16px;margin-top:6px">
          <label style="font-size:13px;display:flex;align-items:center;gap:4px;cursor:pointer">
            <input type="radio" name="lorebook-logic" value="AND" checked> 全部滿足 (AND)
          </label>
          <label style="font-size:13px;display:flex;align-items:center;gap:4px;cursor:pointer">
            <input type="radio" name="lorebook-logic" value="OR"> 任一滿足 (OR)
          </label>
        </div>
      </div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('lorebook-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveLorebook()">保存</button>
  </div>
</div>
<!-- 編輯指令 Modal -->
<div class="modal" id="edit-inst-modal" style="max-width:500px">
  <div class="modal-title">✏️ 編輯指令</div>
  <div class="form-group">
    <label class="form-label">指令名稱</label>
    <input type="text" class="form-input" id="edit-inst-name" placeholder="輸入指令名稱">
  </div>
  <div class="form-group">
    <label class="form-label">指令內容</label>
    <textarea class="form-input" id="edit-inst-content" style="min-height:300px;resize:vertical;font-family:monospace;font-size:13px" placeholder="輸入指令內容..."></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('edit-inst-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveEditInst()">保存</button>
  </div>
</div>
<!-- 編輯消息 Modal -->
<div class="modal" id="edit-msg-modal" style="max-width:min(90%,400px)">
  <div class="modal-title">編輯消息</div>
  <div class="form-group">
    <textarea class="form-input" id="edit-msg-content" style="min-height:200px;resize:vertical" placeholder="編輯消息內容..."></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('edit-msg-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveEditMsg()">保存</button>
  </div>
</div>
<!-- 重新生成 Modal -->
<div class="modal" id="regen-modal">
  <div class="modal-title">🔄 重新生成</div>
  <div class="form-group">
    <label class="form-label">補充說明（可選）</label>
    <textarea class="form-input" id="regen-note" style="min-height:80px" placeholder="例如：描寫更細膩一些、語氣更強硬..."></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('regen-modal')">取消</button>
    <button class="modal-btn confirm" onclick="doRegenerate()">重新生成</button>
  </div>
</div>
<!-- 記憶管理 Modal -->
<div class="modal" id="memory-modal" style="max-width:min(95%,480px)">
  <div class="modal-title">🧠 記憶管理</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    管理故事記憶，壓縮舊消息或生成滾動摘要，保持 AI 對劇情的連貫理解。
  </div>
  <div class="form-group">
    <label class="form-label">📊 當前狀態</label>
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;font-size:13px">
      <div style="display:flex;justify-content:space-between;margin-bottom:4px">
        <span>總消息數：<strong id="memory-msg-count">0</strong> 條</span>
        <span id="memory-token-estimate" style="color:var(--text-tertiary)"></span>
      </div>
      <div>已壓縮：<span id="memory-compressed">0</span> 條</div>
      <div>摘要數：<span id="memory-summary-count">0</span> 條 
        <span style="color:var(--primary);cursor:pointer;margin-left:8px" onclick="viewSummaries()">📖 查看</span>
        <span style="color:var(--primary);cursor:pointer;margin-left:8px" onclick="searchSummaries()">🔍 搜索</span>
      </div>
      <div>滾動摘要：<span id="memory-rolling-count">0</span> 條 <span style="color:var(--text-tertiary);font-size:11px">(不刪除原文)</span></div>
      <div id="memory-protected-info" style="color:var(--warning);font-size:12px;margin-top:6px"></div>
    </div>
  </div>

  <!-- 功能選項卡 -->
  <div style="display:flex;gap:8px;margin-bottom:12px">
    <button class="modal-btn secondary" id="mem-tab-compress" onclick="switchMemTab('compress')" style="flex:1;font-size:11px;padding:8px">🗜️ 壓縮</button>
    <button class="modal-btn" id="mem-tab-rolling" onclick="switchMemTab('rolling')" style="flex:1;font-size:11px;padding:8px;background:var(--bg-tertiary)">📜 滾動</button>
    <button class="modal-btn" id="mem-tab-search" onclick="switchMemTab('search')" style="flex:1;font-size:11px;padding:8px;background:var(--bg-tertiary)">🔎 搜尋</button>
    <button class="modal-btn" id="mem-tab-viz" onclick="switchMemTab('viz')" style="flex:1;font-size:11px;padding:8px;background:var(--bg-tertiary)">📊 可視化</button>
    <button class="modal-btn" id="mem-tab-analyze" onclick="switchMemTab('analyze')" style="flex:1;font-size:11px;padding:8px;background:var(--bg-tertiary)">🔍 分析</button>
  </div>

  <!-- 壓縮選項 -->
  <div id="mem-panel-compress">
    <div class="form-group">
      <label class="form-label">壓縮方式</label>
      <select class="form-select" id="compress-mode" onchange="updateCompressOptions()">
        <option value="count">按消息數量</option>
        <option value="chapter">按章節壓縮</option>
        <option value="manual">手動選擇消息</option>
      </select>
    </div>
    <div class="form-group" id="compress-count-group">
      <label class="form-label">壓縮數量</label>
      <select class="form-select" id="compress-count">
        <option value="10">壓縮最早 10 條消息</option>
        <option value="20">壓縮最早 20 條消息</option>
        <option value="50">壓縮最早 50 條消息</option>
        <option value="all">壓縮所有舊消息（保留最近20條）</option>
      </select>
    </div>
    <div class="form-group" id="compress-chapter-group" style="display:none">
      <label class="form-label">選擇章節</label>
      <select class="form-select" id="compress-chapter"></select>
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">將壓縮該章節之前的所有消息</div>
    </div>
    <div class="form-group" id="compress-manual-group" style="display:none">
      <label class="form-label">選擇要壓縮的消息</label>
      <div style="font-size:11px;color:var(--text-secondary);margin-bottom:8px">
        點擊「選擇消息」按鈕，勾選要合併壓縮的消息（已選 <span id="manual-select-count">0</span> 條）
      </div>
      <button class="modal-btn secondary" onclick="showManualSelectModal()" style="width:100%">📋 選擇消息</button>
    </div>
    <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;padding:8px;background:var(--bg-tertiary);border-radius:6px">
      💡 帶有伏筆標記、書籤、劇情標籤的重要消息會自動跳過保護。
    </div>
  </div>
  
  <!-- 滾動摘要選項 -->
  <div id="mem-panel-rolling" style="display:none">
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
      自動為對話生成背景摘要，<strong>不刪除原文</strong>，幫助 AI 更好地理解上下文。
    </div>
    <div class="form-group">
      <label class="form-label">自動滾動摘要</label>
      <div style="display:flex;align-items:center;gap:12px">
        <div class="toggle" id="tog-rolling-summary" onclick="toggleRollingSummary()"></div>
        <span style="font-size:13px;color:var(--text-secondary)">每 <input type="number" id="rolling-interval" value="30" min="10" max="100" onchange="saveRollingInterval()" style="width:50px;padding:4px;border:1px solid var(--divider);border-radius:4px;background:var(--bg-tertiary);color:var(--text-primary)"> 條消息自動生成</span>
      </div>
    </div>
    <div class="form-group">
      <label class="form-label">手動操作</label>
      <button class="modal-btn secondary" onclick="generateRollingSummary()" style="width:100%;margin-bottom:8px">📜 立即生成滾動摘要</button>
      <button class="modal-btn" onclick="mergeSummaries()" style="width:100%;background:var(--bg-tertiary);margin-bottom:8px">🔗 合併多條摘要</button>
      <button class="modal-btn" onclick="showManualMergeSummariesModal()" style="width:100%;background:var(--bg-tertiary)">✅ 手動選擇摘要合併</button>
    </div>
  </div>

  <!-- 記憶搜尋面板 -->
  <div id="mem-panel-search" style="display:none">
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
      搜尋歷史消息、摘要和Lorebook，快速找到需要的信息
    </div>

    <!-- 搜尋輸入框 -->
    <div class="form-group">
      <label class="form-label">🔎 關鍵詞搜尋</label>
      <div class="search-wrap" style="margin:0">
        <input type="text" id="memory-search-input" class="search-input" placeholder="輸入關鍵詞搜尋..." style="width:100%">
        <span style="font-size:18px;cursor:pointer" onclick="executeMemorySearch()">🔍</span>
      </div>
    </div>

    <!-- 搜尋選項 -->
    <div class="form-group">
      <label class="form-label">🎯 搜尋範圍</label>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
          <input type="checkbox" id="search-messages" checked style="cursor:pointer">
          <span style="font-size:13px">💬 消息</span>
        </label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
          <input type="checkbox" id="search-summaries" checked style="cursor:pointer">
          <span style="font-size:13px">📚 摘要</span>
        </label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
          <input type="checkbox" id="search-lorebook" checked style="cursor:pointer">
          <span style="font-size:13px">📖 Lorebook</span>
        </label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
          <input type="checkbox" id="search-important-only" style="cursor:pointer">
          <span style="font-size:13px">⭐ 只搜重要</span>
        </label>
      </div>
    </div>

    <!-- 角色篩選 -->
    <div class="form-group">
      <label class="form-label">👤 角色篩選 <span style="font-size:11px;color:var(--text-tertiary)">(選填)</span></label>
      <select class="form-select" id="search-role-filter">
        <option value="all">全部</option>
        <option value="user">僅用戶消息</option>
        <option value="assistant">僅AI消息</option>
      </select>
    </div>

    <!-- 搜尋按鈕 -->
    <button class="modal-btn confirm" onclick="executeMemorySearch()" style="width:100%;margin-bottom:12px">
      🔍 開始搜尋
    </button>

    <!-- 搜尋結果 -->
    <div id="search-results-container" style="display:none;margin-top:12px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <span style="font-size:13px;font-weight:600">📋 搜尋結果</span>
        <span id="search-result-count" style="font-size:12px;color:var(--text-tertiary)">找到 0 筆</span>
      </div>
      <div id="search-results-list" style="max-height:400px;overflow-y:auto;border:1px solid var(--divider);border-radius:8px;padding:8px;background:var(--bg-tertiary)">
      </div>
    </div>
  </div>

  <!-- 記憶可視化面板 -->
  <div id="mem-panel-viz" style="display:none">
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
      可視化查看當前記憶系統的使用情況和分佈
    </div>

    <!-- 記憶類型統計 -->
    <div class="form-group">
      <label class="form-label">📦 記憶類型分佈</label>
      <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px">
        <div class="mem-viz-item">
          <div class="mem-viz-label">⭐ 重要記憶</div>
          <div class="mem-viz-bar-container">
            <div class="mem-viz-bar" id="viz-bar-important" style="width:0%;background:#FFD700"></div>
          </div>
          <div class="mem-viz-value"><span id="viz-count-important">0</span> 條</div>
        </div>
        <div class="mem-viz-item">
          <div class="mem-viz-label">📚 故事摘要</div>
          <div class="mem-viz-bar-container">
            <div class="mem-viz-bar" id="viz-bar-summaries" style="width:0%;background:var(--primary)"></div>
          </div>
          <div class="mem-viz-value"><span id="viz-count-summaries">0</span> 條</div>
        </div>
        <div class="mem-viz-item">
          <div class="mem-viz-label">📜 滾動摘要</div>
          <div class="mem-viz-bar-container">
            <div class="mem-viz-bar" id="viz-bar-rolling" style="width:0%;background:var(--info)"></div>
          </div>
          <div class="mem-viz-value"><span id="viz-count-rolling">0</span> 條</div>
        </div>
        <div class="mem-viz-item">
          <div class="mem-viz-label">💬 原始消息</div>
          <div class="mem-viz-bar-container">
            <div class="mem-viz-bar" id="viz-bar-messages" style="width:0%;background:var(--text-tertiary)"></div>
          </div>
          <div class="mem-viz-value"><span id="viz-count-messages">0</span> 條</div>
        </div>
      </div>
    </div>

    <!-- Token 使用估算 -->
    <div class="form-group">
      <label class="form-label">🔢 Token 使用估算</label>
      <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;font-size:13px">
        <div style="display:flex;justify-content:space-between;margin-bottom:6px">
          <span>重要記憶</span>
          <span id="viz-tokens-important" style="color:var(--primary)">~0 tokens</span>
        </div>
        <div style="display:flex;justify-content:space-between;margin-bottom:6px">
          <span>摘要系統</span>
          <span id="viz-tokens-summaries" style="color:var(--primary)">~0 tokens</span>
        </div>
        <div style="display:flex;justify-content:space-between;margin-bottom:6px">
          <span>最近上下文 (<span id="viz-context-count">20</span>條)</span>
          <span id="viz-tokens-context" style="color:var(--primary)">~0 tokens</span>
        </div>
        <div style="border-top:1px solid var(--divider);margin-top:8px;padding-top:8px;display:flex;justify-content:space-between">
          <strong>預估總計</strong>
          <strong id="viz-tokens-total" style="color:var(--success)">~0 tokens</strong>
        </div>
      </div>
    </div>

    <!-- 記憶健康度 -->
    <div class="form-group">
      <label class="form-label">💚 記憶健康度</label>
      <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;font-size:13px">
        <div style="margin-bottom:8px">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px">
            <span>整體評分</span>
            <strong id="viz-health-score" style="color:var(--success)">良好</strong>
          </div>
          <div style="height:8px;background:var(--bg-primary);border-radius:4px;overflow:hidden">
            <div id="viz-health-bar" style="height:100%;background:var(--success);width:80%;transition:all .3s"></div>
          </div>
        </div>
        <div id="viz-health-tips" style="font-size:12px;color:var(--text-secondary);line-height:1.6"></div>
      </div>
    </div>

    <!-- 快捷操作 -->
    <div class="form-group">
      <label class="form-label">⚡ 快捷操作</label>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <button class="modal-btn secondary" onclick="showImportantMessages()" style="font-size:12px">⭐ 查看重要</button>
        <button class="modal-btn secondary" onclick="viewSummaries()" style="font-size:12px">📚 查看摘要</button>
        <button class="modal-btn secondary" onclick="generateRollingSummary()" style="font-size:12px">📜 生成摘要</button>
        <button class="modal-btn secondary" onclick="updateMemoryViz()" style="font-size:12px">🔄 刷新數據</button>
      </div>
    </div>
  </div>

  <!-- 智能分析選項 -->
  <div id="mem-panel-analyze" style="display:none">
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
      讓 AI 分析當前對話，識別哪些內容重要、哪些可以安全壓縮。
    </div>
    <button class="modal-btn secondary" onclick="analyzeMemory()" style="width:100%;margin-bottom:12px">🔍 AI 智能分析</button>
    <div id="memory-analysis-result" style="display:none;background:var(--bg-tertiary);padding:12px;border-radius:8px;font-size:13px;max-height:200px;overflow-y:auto"></div>
  </div>
  
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('memory-modal')">取消</button>
    <button class="modal-btn confirm" id="mem-compress-btn" onclick="compressMemory()">🤖 智能壓縮</button>
  </div>
</div>
<!-- 摘要查看 Modal -->
<div class="modal" id="summaries-modal" style="max-width:min(95%,500px)">
  <div class="modal-title">📚 記憶摘要</div>
  <div id="summaries-list" style="max-height:60vh;overflow-y:auto"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('summaries-modal')">關閉</button>
    <button class="modal-btn" style="background:var(--error)" onclick="clearAllSummaries()">🗑️ 清空摘要</button>
  </div>
</div>
<!-- 摘要編輯 Modal -->
<div class="modal" id="edit-summary-modal" style="max-width:min(95%,550px)">
  <div class="modal-title" id="edit-summary-title">✏️ 編輯摘要</div>
  <div class="modal-content" style="padding:0">
    <textarea id="edit-summary-content" class="form-input" style="min-height:250px;max-height:50vh;font-size:14px;line-height:1.6" placeholder="摘要內容..."></textarea>
    <div style="font-size:12px;color:var(--text-tertiary);margin-top:8px">
      💡 編輯摘要內容會影響 AI 對故事的理解，請謹慎修改。
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('edit-summary-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveSummaryEdit()">保存</button>
  </div>
</div>
<!-- 摘要搜索 Modal -->
<div class="modal" id="summary-search-modal" style="max-width:min(95%,500px)">
  <div class="modal-title">🔍 搜索記憶摘要</div>
  <div class="form-group">
    <input type="text" class="form-input" id="summary-search-input" placeholder="輸入關鍵詞搜索摘要內容" oninput="doSummarySearch()">
  </div>
  <div id="summary-search-results" style="max-height:50vh;overflow-y:auto">
    <div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">輸入關鍵詞搜索</div></div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('summary-search-modal')">關閉</button>
  </div>
</div>
<!-- 摘要預覽 Modal -->
<div class="modal" id="summary-preview-modal" style="max-width:min(95%,550px)">
  <div class="modal-title" id="summary-preview-title">📝 記憶摘要預覽</div>
  <div class="modal-content" style="padding:0">
    <div style="font-size:12px;color:var(--text-secondary);margin-bottom:12px;padding:0 4px" id="summary-preview-desc">
      AI 已生成以下摘要，你可以編輯後再確認壓縮：
    </div>
    <textarea id="summary-preview-content" class="form-input" style="min-height:200px;max-height:40vh;font-size:14px;line-height:1.6" placeholder="摘要內容..."></textarea>
    <div style="background:var(--bg-tertiary);border-radius:8px;padding:10px 12px;margin-top:12px;font-size:12px;color:var(--text-secondary)" id="summary-preview-tips">
      <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px">
        <span>💡</span>
        <span style="font-weight:600">提示</span>
      </div>
      <div>確認後將刪除原始消息並保存此摘要。壓縮後仍可在「📊 查看」中編輯摘要內容。</div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="cancelSummaryPreview()">取消</button>
    <button class="modal-btn confirm" id="summary-preview-confirm-btn" onclick="confirmSummaryCompress()">確認並壓縮</button>
  </div>
</div>

<!-- 手動選擇消息壓縮 Modal -->
<div class="modal" id="manual-select-modal" style="max-width:min(95%,700px);max-height:85vh">
  <div class="modal-title">📋 選擇要壓縮的消息</div>
  <p style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
    勾選要合併壓縮的消息，AI 會將它們合併成一條摘要
  </p>

  <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">
    <button class="action-btn secondary" onclick="selectAllMessages()" style="padding:6px 12px;font-size:12px">✅ 全選</button>
    <button class="action-btn secondary" onclick="unselectAllMessages()" style="padding:6px 12px;font-size:12px">❌ 取消全選</button>
    <button class="action-btn secondary" onclick="selectOldMessages()" style="padding:6px 12px;font-size:12px">⏪ 選擇前50條</button>
    <div style="flex:1"></div>
    <span style="font-size:12px;color:var(--text-tertiary);display:flex;align-items:center">
      已選 <span id="modal-selected-count" style="color:var(--primary);font-weight:600;margin:0 4px">0</span> 條
    </span>
  </div>

  <div id="manual-select-list" style="max-height:50vh;overflow-y:auto;border:1px solid var(--divider);border-radius:8px;padding:8px"></div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('manual-select-modal')">取消</button>
    <button class="modal-btn confirm" onclick="confirmManualSelection()">確認選擇</button>
  </div>
</div>

<!-- 手動選擇摘要合併 Modal -->
<div class="modal" id="manual-merge-summaries-modal" style="max-width:min(95%,700px);max-height:85vh">
  <div class="modal-title">✅ 手動選擇摘要合併</div>
  <p style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
    勾選要合併的壓縮摘要，AI 會將它們合併成一條新的摘要
  </p>

  <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">
    <button class="action-btn secondary" onclick="selectAllSummaries()" style="padding:6px 12px;font-size:12px">✅ 全選</button>
    <button class="action-btn secondary" onclick="unselectAllSummaries()" style="padding:6px 12px;font-size:12px">❌ 取消全選</button>
    <div style="flex:1"></div>
    <span style="font-size:12px;color:var(--text-tertiary);display:flex;align-items:center">
      已選 <span id="summary-selected-count" style="color:var(--primary);font-weight:600;margin:0 4px">0</span> 條
    </span>
  </div>

  <div id="manual-merge-summaries-list" style="max-height:50vh;overflow-y:auto;border:1px solid var(--divider);border-radius:8px;padding:8px"></div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('manual-merge-summaries-modal')">取消</button>
    <button class="modal-btn secondary" onclick="confirmCompressSummaries()" style="background:var(--warning)">🗜️ 壓縮精簡</button>
    <button class="modal-btn confirm" onclick="confirmManualMergeSummaries()">🔗 合併</button>
  </div>
</div>

<!-- AI 同步預覽 Modal -->
<div class="modal" id="ai-preview-modal" style="max-width:min(95%,550px)">
  <div class="modal-title" id="ai-preview-title">🤖 AI 同步預覽</div>
  <div class="modal-content" style="padding:0">
    <div id="ai-preview-content" style="max-height:50vh;overflow-y:auto"></div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('ai-preview-modal')">取消</button>
    <button class="modal-btn confirm" id="ai-preview-confirm-btn">確認</button>
  </div>
</div>
<!-- 財產資產編輯 Modal -->
<div class="modal" id="inventory-item-modal" style="max-width:min(95%,450px)">
  <div class="modal-title" id="inventory-modal-title">➕ 添加資產</div>
  <div class="form-group">
    <label class="form-label">資產圖標</label>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px" id="inventory-icon-picker">
      <span class="icon-option" onclick="selectInventoryIcon('💰')">💰</span>
      <span class="icon-option" onclick="selectInventoryIcon('💵')">💵</span>
      <span class="icon-option" onclick="selectInventoryIcon('💴')">💴</span>
      <span class="icon-option" onclick="selectInventoryIcon('🏠')">🏠</span>
      <span class="icon-option" onclick="selectInventoryIcon('🏢')">🏢</span>
      <span class="icon-option" onclick="selectInventoryIcon('🏬')">🏬</span>
      <span class="icon-option" onclick="selectInventoryIcon('🚗')">🚗</span>
      <span class="icon-option" onclick="selectInventoryIcon('🏎️')">🏎️</span>
      <span class="icon-option" onclick="selectInventoryIcon('🚁')">🚁</span>
      <span class="icon-option" onclick="selectInventoryIcon('🛥️')">🛥️</span>
      <span class="icon-option" onclick="selectInventoryIcon('💎')">💎</span>
      <span class="icon-option" onclick="selectInventoryIcon('👑')">👑</span>
      <span class="icon-option" onclick="selectInventoryIcon('💍')">💍</span>
      <span class="icon-option" onclick="selectInventoryIcon('🎨')">🎨</span>
      <span class="icon-option" onclick="selectInventoryIcon('📋')">📋</span>
    </div>
    <input type="text" class="form-input" id="inventory-item-icon" placeholder="或輸入自定義圖標/emoji" maxlength="4" style="width:80px">
  </div>
  <div class="form-group">
    <label class="form-label">資產名稱 *</label>
    <input type="text" class="form-input" id="inventory-item-name" placeholder="例：市中心公寓">
  </div>
  <div class="form-group">
    <label class="form-label">數量/金額</label>
    <input type="number" class="form-input" id="inventory-item-quantity" value="1" min="1" style="width:100px">
  </div>
  <div class="form-group">
    <label class="form-label">分類</label>
    <select class="form-input" id="inventory-item-category">
      <option value="money">💰 金錢</option>
      <option value="property">🏠 房產</option>
      <option value="vehicle">🚗 載具</option>
      <option value="valuable">💎 貴重物品</option>
      <option value="other">📋 其他</option>
    </select>
  </div>
  <div class="form-group">
    <label class="form-label">存放位置</label>
    <select class="form-input" id="inventory-item-location">
      <option value="on_person">👤 身上</option>
      <option value="home">🏠 家中</option>
      <option value="bank">🏦 銀行</option>
      <option value="warehouse">📦 倉庫</option>
      <option value="other_location">📍 其他地點</option>
    </select>
  </div>
  <div class="form-group">
    <label class="form-label">描述</label>
    <textarea class="form-input" id="inventory-item-desc" placeholder="資產描述（可選）" rows="2"></textarea>
  </div>
  <div class="form-group">
    <label class="form-label" style="display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="inventory-item-lorebook"> 同步到 Lorebook（AI可識別此資產）
    </label>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('inventory-item-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveInventoryItem()">保存</button>
  </div>
</div>
<!-- 行程編輯 Modal -->
<div class="modal" id="schedule-item-modal" style="max-width:min(95%,450px)">
  <div class="modal-title" id="schedule-modal-title">➕ 添加行程</div>
  <div class="form-group">
    <label class="form-label">排序時間（用於排序）</label>
    <input type="datetime-local" class="form-input" id="schedule-item-timestamp" style="color-scheme:dark">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">選填，用於行程排序。留空則按創建時間排序</div>
  </div>
  <div class="form-group">
    <label class="form-label">日期時間描述 *</label>
    <input type="text" class="form-input" id="schedule-item-datetime" placeholder="例：第三天下午、明天早上8點">
  </div>
  <div class="form-group">
    <label class="form-label">事件 *</label>
    <input type="text" class="form-input" id="schedule-item-event" placeholder="例：與王子會面">
  </div>
  <div class="form-group">
    <label class="form-label">地點</label>
    <input type="text" class="form-input" id="schedule-item-location" placeholder="例：皇宮大廳">
  </div>
  <div class="form-group">
    <label class="form-label">參與角色</label>
    <input type="text" class="form-input" id="schedule-item-participants" placeholder="例：王子、侍衛長（用逗號分隔）">
  </div>
  <div class="form-group">
    <label class="form-label">狀態</label>
    <select class="form-input" id="schedule-item-status">
      <option value="pending">⏳ 待辦</option>
      <option value="in_progress">🔄 進行中</option>
      <option value="completed">✅ 已完成</option>
    </select>
  </div>
  <div class="form-group">
    <label class="form-label">備註</label>
    <textarea class="form-input" id="schedule-item-notes" placeholder="備註（可選）" rows="2"></textarea>
  </div>
  <div class="form-group">
    <label class="form-label" style="display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="schedule-item-lorebook"> 同步到 Lorebook（AI可識別此行程）
    </label>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('schedule-item-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveScheduleItem()">保存</button>
  </div>
</div>
<!-- AI分析範圍選擇 Modal -->
<div class="modal" id="ai-range-modal" style="max-width:min(95%,350px)">
  <div class="modal-title" id="ai-range-modal-title">🤖 AI 智能分析</div>
  <div class="form-group">
    <label class="form-label">選擇分析的對話範圍</label>
    <div style="display:flex;align-items:center;gap:12px">
      <input type="range" id="ai-range-slider" min="5" max="100" value="20" style="flex:1" oninput="updateAiRangeLabel()">
      <span id="ai-range-label" style="min-width:60px;font-weight:600;color:var(--primary)">20 條</span>
    </div>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">範圍越大分析越全面，但耗時更長</div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('ai-range-modal')">取消</button>
    <button class="modal-btn confirm" id="ai-range-confirm-btn" onclick="confirmAiRange()">開始分析</button>
  </div>
</div>
<!-- 查找替換 Modal -->
<div class="modal" id="find-replace-modal">
  <div class="modal-title">🔍 查找與替換</div>
  <div class="form-group">
    <label class="form-label">查找</label>
    <input type="text" class="form-input" id="find-text" placeholder="輸入要查找的文字">
  </div>
  <div class="form-group">
    <label class="form-label">替換為</label>
    <input type="text" class="form-input" id="replace-text" placeholder="輸入替換後的文字">
  </div>
  <div class="form-group">
    <label style="font-size:13px;color:var(--text-secondary);display:flex;align-items:center;gap:6px;cursor:pointer">
      <input type="checkbox" id="find-case-sensitive"> 區分大小寫
    </label>
  </div>
  <div id="find-result" style="font-size:13px;color:var(--text-tertiary);margin-bottom:12px"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('find-replace-modal')">關閉</button>
    <button class="modal-btn secondary" onclick="findNext()">查找下一個</button>
    <button class="modal-btn confirm" onclick="replaceAll()">全部替換</button>
  </div>
</div>
<!-- 統計面板 Modal -->
<div class="modal" id="stats-modal">
  <div class="modal-title">📊 統計面板</div>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:var(--primary)" id="stats-chars">0</div>
      <div style="font-size:12px;color:var(--text-tertiary)">總字數</div>
    </div>
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:var(--primary)" id="stats-msgs">0</div>
      <div style="font-size:12px;color:var(--text-tertiary)">消息數</div>
    </div>
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:var(--primary)" id="stats-tokens">0</div>
      <div style="font-size:12px;color:var(--text-tertiary)">總 Tokens</div>
    </div>
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:var(--primary)" id="stats-time">0h</div>
      <div style="font-size:12px;color:var(--text-tertiary)">遊玩時長</div>
    </div>
  </div>
  <div style="margin-top:16px;padding:12px;background:var(--bg-tertiary);border-radius:8px;font-size:13px">
    <div style="margin-bottom:8px"><strong>用戶輸入：</strong><span id="stats-user-chars">0</span> 字</div>
    <div><strong>AI 生成：</strong><span id="stats-ai-chars">0</span> 字</div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn confirm" onclick="closeModal('stats-modal')">關閉</button>
  </div>
</div>
<!-- 添加章節 Modal -->
<div class="modal" id="chapter-modal">
  <div class="modal-title">📑 添加章節</div>
  <div class="form-group">
    <label class="form-label">章節標題</label>
    <input type="text" class="form-input" id="chapter-title" placeholder="例如：第一章・入宮">
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('chapter-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveChapter()">保存</button>
  </div>
</div>
<!-- 添加書籤 Modal -->
<div class="modal" id="bookmark-modal">
  <div class="modal-title">🔖 添加書籤</div>
  <div class="form-group">
    <label class="form-label">書籤名稱</label>
    <input type="text" class="form-input" id="bookmark-name" placeholder="例如：重要劇情點">
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('bookmark-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveBookmark()">保存</button>
  </div>
</div>
<!-- 添加標籤 Modal -->
<div class="modal" id="tag-modal">
  <div class="modal-title">🏷️ 添加劇情標籤</div>
  <div class="form-group">
    <label class="form-label">標籤類型</label>
    <select class="form-select" id="tag-type">
      <option value="key">🔑 關鍵劇情</option>
      <option value="scene">🎬 名場面</option>
      <option value="clue">🔍 線索</option>
      <option value="turning">🔄 轉折點</option>
      <option value="emotion">💕 情感戲</option>
    </select>
  </div>
  <div class="form-group">
    <label class="form-label">備註（可選）</label>
    <input type="text" class="form-input" id="tag-note" placeholder="簡短描述">
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('tag-modal')">取消</button>
    <button class="modal-btn confirm" onclick="savePlotTag()">保存</button>
  </div>
</div>
<!-- 創建分支 Modal -->
<div class="modal" id="branch-modal">
  <div class="modal-title">🔀 創建分支</div>
  <div class="form-group">
    <label class="form-label">分支名稱</label>
    <input type="text" class="form-input" id="branch-name" placeholder="例如：選擇幫助夜寒">
  </div>
  <div class="form-group">
    <label class="form-label">分支描述（可選）</label>
    <textarea class="form-input" id="branch-desc" style="min-height:60px" placeholder="這個分支的特點..."></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('branch-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveBranch()">創建</button>
  </div>
</div>
<!-- AI 一致性檢查 Modal -->
<div class="modal" id="ai-check-modal" style="max-width:min(90%,400px)">
  <div class="modal-title">🔍 AI 一致性檢查</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
    AI 將分析故事內容，檢查是否存在設定矛盾、時間線錯誤、角色行為不一致等問題。
  </div>
  <div id="ai-check-result" style="background:var(--bg-tertiary);padding:12px;border-radius:8px;min-height:100px;max-height:300px;overflow-y:auto;font-size:13px;white-space:pre-wrap">
    點擊「開始檢查」進行分析...
  </div>
  <div class="modal-actions" style="flex-wrap:wrap;gap:8px">
    <button class="modal-btn secondary" id="ai-fix-btn" style="display:none;flex:0 0 auto" onclick="showAiFix()">🔧 應用修復</button>
    <button class="modal-btn cancel" onclick="closeModal('ai-check-modal')">關閉</button>
    <button class="modal-btn confirm" onclick="doAiConsistencyCheck()">開始檢查</button>
  </div>
</div>
<!-- AI 修復建議 Modal -->
<div class="modal" id="ai-fix-modal" style="max-width:min(90%,400px)">
  <div class="modal-title">🔧 AI 修復建議</div>
  <div style="font-size:14px;margin-bottom:16px">
    選擇如何處理發現的問題：
  </div>
  <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px">
    <button class="action-btn secondary" style="text-align:left;padding:12px" onclick="applyAiFix('auto')">🤖 <strong>AI 自動修復</strong><br><span style="font-size:12px;color:var(--text-secondary)">在下次 AI 回覆中自然地糾正問題</span></button>
    <button class="action-btn secondary" style="text-align:left;padding:12px" onclick="applyAiFix('note')">📝 <strong>添加設定筆記</strong><br><span style="font-size:12px;color:var(--text-secondary)">記錄到世界觀資料庫供日後參考</span></button>
    <button class="action-btn secondary" style="text-align:left;padding:12px" onclick="applyAiFix('ignore')">🔕 <strong>忽略這次</strong><br><span style="font-size:12px;color:var(--text-secondary)">這個「問題」可能是故意設計的</span></button>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('ai-fix-modal')">取消</button>
  </div>
</div>
<!-- v7: 角色狀態更新 Modal -->
<div class="modal" id="char-update-modal" style="max-width:min(90%,420px)">
  <div class="modal-title">🤖 AI 角色分析</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
    AI 會分析故事內容，自動識別角色並提取屬性。這可能需要一些時間。
  </div>
  <div id="char-update-result" style="background:var(--bg-tertiary);padding:12px;border-radius:8px;min-height:80px;max-height:250px;overflow-y:auto;font-size:12px;white-space:pre-wrap">
    點擊「開始分析」讓 AI 識別角色...
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('char-update-modal')">取消</button>
    <button class="modal-btn confirm" id="char-update-btn" onclick="doCharacterUpdate()">開始分析</button>
  </div>
</div>
<!-- v8: 角色添加/編輯 Modal（重構版 - 折疊面板） -->
<div class="modal" id="char-add-modal" style="max-width:min(95%,480px);max-height:85vh;display:flex;flex-direction:column">
  <div class="modal-title" style="flex-shrink:0">
    <span id="char-modal-title">➕ 添加角色</span>
    <span id="char-token-count" style="font-size:12px;color:var(--text-secondary);font-weight:normal;margin-left:8px"></span>
  </div>
  <div style="flex:1;overflow-y:auto;padding-right:4px" id="char-edit-scroll">
    <!-- 📋 基本信息（默認展開） -->
    <div class="char-panel" data-panel="basic">
      <div class="char-panel-header" onclick="toggleCharPanel('basic')">
        <span>📋 基本信息</span>
        <span class="char-panel-arrow">▼</span>
      </div>
      <div class="char-panel-content" style="display:block">
        <div class="char-form-row">
          <div class="form-group" style="flex:1">
            <label class="form-label">角色名稱 *</label>
            <input type="text" class="form-input" id="char-add-name" placeholder="例如：夜寒" oninput="updateCharTokenCount()">
          </div>
          <div class="form-group" style="width:120px">
            <label class="form-label">頭像</label>
            <div style="display:flex;gap:4px">
              <input type="text" class="form-input" id="char-add-avatar" placeholder="🌙" maxlength="4" style="text-align:center;font-size:20px;flex:1">
              <button type="button" class="action-btn secondary" style="padding:8px;font-size:12px" onclick="uploadCharAvatarInEdit()" title="上傳圖片">🖼️</button>
            </div>
            <div id="char-avatar-preview" style="display:none;margin-top:6px;text-align:center">
              <img id="char-avatar-img" style="width:48px;height:48px;border-radius:10px;object-fit:cover">
              <button type="button" style="display:block;margin:4px auto 0;font-size:11px;color:var(--error);background:none;border:none;cursor:pointer" onclick="clearCharAvatarImage()">清除圖片</button>
            </div>
          </div>
        </div>
        <div class="form-group">
          <label class="form-label">頭銜/身份</label>
          <input type="text" class="form-input" id="char-add-title" placeholder="例如：月光莊園老闆">
        </div>
        <div class="form-group">
          <label class="form-label">分類</label>
          <select class="form-input" id="char-add-category">
            <option value="protagonist">⭐ 主角</option>
            <option value="supporting" selected>👤 配角</option>
            <option value="npc">👥 NPC</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">描述 <span class="token-hint" id="desc-tokens"></span></label>
          <textarea class="form-textarea" id="char-add-desc" rows="4" placeholder="詳細描述角色的外貌、性格、背景故事...&#10;支持 Markdown 格式" oninput="updateCharTokenCount()"></textarea>
        </div>
        <div class="form-group">
          <label class="form-label">性格摘要</label>
          <input type="text" class="form-input" id="char-add-personality" placeholder="例如：外冷內熱、佔有欲強、對舊愛念念不忘">
        </div>
        <div class="form-group">
          <label class="form-label">標籤（用逗號分隔）</label>
          <input type="text" class="form-input" id="char-add-tags" placeholder="例如：霸道總裁, 前任, 深情">
        </div>
      </div>
    </div>
    
    <!-- 💬 對話設置（默認折疊） -->
    <div class="char-panel" data-panel="dialogue">
      <div class="char-panel-header" onclick="toggleCharPanel('dialogue')">
        <span>💬 對話設置</span>
        <span class="char-panel-arrow">▶</span>
      </div>
      <div class="char-panel-content" style="display:none">
        <div class="form-group">
          <label class="form-label">開場白 <span class="token-hint" id="firstmes-tokens"></span></label>
          <textarea class="form-textarea" id="char-add-firstmes" rows="4" placeholder="角色的第一條消息，用於開始新對話時...&#10;例如：*他抬眼看向你，嘴角微微上揚* 「你終於來了。」" oninput="updateCharTokenCount()"></textarea>
        </div>
        <div class="form-group">
          <label class="form-label">替代開場白</label>
          <div id="char-alt-greetings" style="display:flex;flex-direction:column;gap:8px"></div>
          <button class="modal-btn secondary" style="margin-top:8px;padding:6px 12px;font-size:12px" onclick="addAltGreeting()">+ 添加替代開場白</button>
        </div>
        <div class="form-group">
          <label class="form-label">場景描述</label>
          <textarea class="form-textarea" id="char-add-scenario" rows="2" placeholder="對話發生的背景情境..."></textarea>
        </div>
        <div class="form-group">
          <label class="form-label">對話示例 <span class="token-hint" id="example-tokens"></span></label>
          <textarea class="form-textarea" id="char-add-example" rows="4" placeholder="示範角色如何說話，幫助 AI 學習語氣...&#10;格式：用 &lt;START&gt; 分隔多段示例" oninput="updateCharTokenCount()"></textarea>
          <div style="margin-top:8px">
            <button class="modal-btn secondary" style="padding:6px 12px;font-size:12px" onclick="openVisualExampleEditor()">📝 可視化編輯器</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ⚙️ 高級設置（默認折疊） -->
    <div class="char-panel" data-panel="advanced">
      <div class="char-panel-header" onclick="toggleCharPanel('advanced')">
        <span>⚙️ 高級設置</span>
        <span class="char-panel-arrow">▶</span>
      </div>
      <div class="char-panel-content" style="display:none">
        <div class="form-group">
          <label class="form-label">角色專屬系統提示詞 <span class="token-hint" id="sysprompt-tokens"></span></label>
          <textarea class="form-textarea" id="char-add-sysprompt" rows="3" placeholder="覆蓋或補充默認系統提示詞...&#10;僅在該角色出場時生效" oninput="updateCharTokenCount()"></textarea>
        </div>
        <div class="form-group">
          <label class="form-label">後歷史指令</label>
          <textarea class="form-textarea" id="char-add-posthistory" rows="2" placeholder="在對話歷史之後注入的指令..."></textarea>
        </div>
        <div class="form-group">
          <label class="form-label">創作者筆記</label>
          <textarea class="form-textarea" id="char-add-creatornotes" rows="2" placeholder="使用說明、技巧等..."></textarea>
        </div>
        <div class="char-form-row">
          <div class="form-group" style="flex:1">
            <label class="form-label">創作者</label>
            <input type="text" class="form-input" id="char-add-creator" placeholder="你的名字">
          </div>
          <div class="form-group" style="width:100px">
            <label class="form-label">版本號</label>
            <input type="text" class="form-input" id="char-add-version" placeholder="1.0">
          </div>
        </div>
      </div>
    </div>
    
    <!-- 📚 角色 Lorebook（默認折疊） -->
    <div class="char-panel" data-panel="lorebook">
      <div class="char-panel-header" onclick="toggleCharPanel('lorebook')">
        <span>📚 角色專屬 Lorebook</span>
        <span class="char-panel-arrow">▶</span>
      </div>
      <div class="char-panel-content" style="display:none">
        <div style="font-size:12px;color:var(--text-secondary);margin-bottom:12px">
          為該角色創建專屬的世界書條目，僅在角色出場時觸發。
        </div>
        <div class="form-group">
          <label class="form-label">觸發模式</label>
          <select class="form-input" id="char-add-lore-trigger">
            <option value="scene">僅在當前場景中觸發</option>
            <option value="always">只要故事包含該角色就始終觸發</option>
          </select>
        </div>
        <div id="char-lorebook-entries" style="display:flex;flex-direction:column;gap:8px"></div>
        <button class="modal-btn secondary" style="margin-top:8px;padding:6px 12px;font-size:12px" onclick="addCharLorebookEntry()">+ 添加條目</button>
      </div>
    </div>
    
    <!-- 👥 角色關係（默認折疊） -->
    <div class="char-panel" data-panel="relations">
      <div class="char-panel-header" onclick="toggleCharPanel('relations')">
        <span>👥 角色關係</span>
        <span class="char-panel-arrow">▶</span>
      </div>
      <div class="char-panel-content" style="display:none">
        <div style="font-size:12px;color:var(--text-secondary);margin-bottom:12px">
          定義此角色與其他角色的關係，AI會參考這些信息。
        </div>
        <div id="char-relationships-list" style="display:flex;flex-direction:column;gap:10px"></div>
        <button class="modal-btn secondary" style="margin-top:10px;padding:6px 12px;font-size:12px" onclick="addCharRelationship()">+ 添加關係</button>
      </div>
    </div>
    
    <!-- 🎨 表情立繪（默認折疊） -->
    <div class="char-panel" data-panel="expressions">
      <div class="char-panel-header" onclick="toggleCharPanel('expressions')">
        <span>🎨 表情立繪</span>
        <span class="char-panel-arrow">▶</span>
      </div>
      <div class="char-panel-content" style="display:none">
        <div style="font-size:12px;color:var(--text-secondary);margin-bottom:12px">
          上傳角色的不同表情圖片，AI可根據對話內容自動切換。
        </div>
        <div class="form-group">
          <label class="form-label">表情模式</label>
          <select class="form-input" id="char-add-expr-mode" style="width:100%">
            <option value="manual">手動切換</option>
            <option value="auto">AI 自動切換</option>
          </select>
        </div>
        <div id="char-expressions-list" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:12px"></div>
        <button class="modal-btn secondary" style="margin-top:12px;padding:6px 12px;font-size:12px;width:100%" onclick="addCharExpression()">+ 添加表情</button>
        <input type="file" id="expr-file-input" accept="image/*" style="display:none" onchange="handleExpressionUpload(event)">
      </div>
    </div>
    
    <!-- 📊 狀態屬性（默認折疊） -->
    <div class="char-panel" data-panel="stats">
      <div class="char-panel-header" onclick="toggleCharPanel('stats')">
        <span>📊 狀態屬性</span>
        <span class="char-panel-arrow">▶</span>
      </div>
      <div class="char-panel-content" style="display:none">
        <div class="form-group">
          <label class="form-label">屬性（每行一個，格式：屬性名:數值）</label>
          <textarea class="form-textarea" id="char-add-stats" rows="4" placeholder="好感:50&#10;忠誠:60&#10;野心:30"></textarea>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button type="button" class="action-btn secondary" style="font-size:12px" onclick="setCurrentAsInitialStats()">💾 設為初始狀態</button>
            <button type="button" class="action-btn secondary" style="font-size:12px" onclick="resetToInitialStats()">🔄 恢復初始狀態</button>
          </div>
          <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">💡 設為初始狀態後，「重新開始」時會恢復到此數值</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="modal-actions" style="flex-shrink:0;border-top:1px solid var(--divider);padding-top:12px;margin-top:8px">
    <button class="modal-btn secondary" onclick="aiGenerateCharFields()" style="margin-right:auto">🤖 AI 輔助</button>
    <button class="modal-btn secondary" onclick="setCurrentAsInitialState()" title="將當前所有設定保存為初始設定，重新開始時會恢復到此版本">💾 存為初始</button>
    <button class="modal-btn cancel" onclick="closeCharEditModal()">取消</button>
    <button class="modal-btn confirm" onclick="saveCharacterManual()">保存</button>
  </div>
</div>
<!-- v7: 角色詳情/編輯 Modal -->
<div class="modal" id="char-detail-modal" style="max-width:min(90%,420px)">
  <div class="modal-title" id="char-detail-title">角色詳情</div>
  <div id="char-detail-content" style="max-height:50vh;overflow-y:auto"></div>
  <div class="modal-actions" style="flex-wrap:wrap;gap:8px">
    <button class="modal-btn cancel" onclick="closeModal('char-detail-modal')">關閉</button>
    <button class="modal-btn" onclick="showCharExportOptions()">📤 導出</button>
    <button class="modal-btn secondary" onclick="editCharacter()">編輯</button>
    <button class="modal-btn" style="background:var(--error);color:white" onclick="deleteCharacter()">刪除</button>
  </div>
</div>
<!-- v26: 見面記錄編輯 Modal -->
<div class="modal" id="meeting-edit-modal" style="max-width:min(90%,380px)">
  <div class="modal-title" id="meeting-edit-title">📝 添加見面記錄</div>
  <div class="form-group">
    <label class="form-label">時間</label>
    <input type="text" class="form-input" id="meeting-time" placeholder="如：第三天下午、一月十日">
  </div>
  <div class="form-group">
    <label class="form-label">地點（可選）</label>
    <input type="text" class="form-input" id="meeting-location" placeholder="如：皇宮花園、咖啡廳">
  </div>
  <div class="form-group">
    <label class="form-label">內容摘要</label>
    <textarea class="form-input" id="meeting-summary" rows="4" placeholder="簡述這次見面的主要內容、談話要點、重要事件等"></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('meeting-edit-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveMeeting()">保存</button>
  </div>
</div>
<!-- v8: 角色導出選項 Modal -->
<div class="modal" id="char-export-modal" style="max-width:min(90%,320px)">
  <div class="modal-title">📤 導出角色卡</div>
  <div style="padding:16px 0">
    <div style="display:flex;flex-direction:column;gap:12px">
      <button class="modal-btn" style="padding:16px;font-size:15px" onclick="exportCurrentCharacterJSON()">
        📄 JSON 格式<br><span style="font-size:12px;color:var(--text-secondary)">通用格式，可在其他平台導入</span>
      </button>
      <button class="modal-btn" style="padding:16px;font-size:15px" onclick="exportCurrentCharacterPNG()">
        🖼️ PNG 圖片<br><span style="font-size:12px;color:var(--text-secondary)">SillyTavern 兼容，帶角色圖片</span>
      </button>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('char-export-modal')">取消</button>
  </div>
</div>
<!-- v8: URL 導入角色卡 Modal -->
<div class="modal" id="char-url-import-modal" style="max-width:min(90%,380px)">
  <div class="modal-title">🔗 從 URL 導入角色卡</div>
  <div style="padding:16px 0">
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
      支持的格式：<br>
      • 直接 JSON/PNG 鏈接<br>
      • Chub.ai 角色頁面<br>
      • CharacterHub 角色頁面
    </div>
    <input type="text" id="char-url-input" placeholder="請輸入角色卡 URL..." style="width:100%;padding:12px;border:1px solid var(--divider);border-radius:8px;background:var(--bg-tertiary);color:var(--text-primary);font-size:14px">
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('char-url-import-modal')">取消</button>
    <button class="modal-btn" onclick="doImportFromURL()">導入</button>
  </div>
</div>
<!-- v7: 角色歷史記錄 Modal -->
<div class="modal" id="char-history-modal" style="max-width:min(90%,400px)">
  <div class="modal-title">📜 屬性變化歷史</div>
  <div id="char-history-content" style="max-height:50vh;overflow-y:auto"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('char-history-modal')">關閉</button>
  </div>
</div>
<!-- v25: 開場白選擇 Modal -->
<div class="modal" id="greeting-select-modal" style="max-width:min(90%,420px)">
  <div class="modal-title">💬 選擇開場白</div>
  <div id="greeting-select-content" style="max-height:60vh;overflow-y:auto;padding:8px 0"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('greeting-select-modal');skipGreeting()">不使用開場白</button>
    <button class="modal-btn confirm" onclick="confirmGreeting()">使用選中的開場白</button>
  </div>
</div>
<!-- 伏筆詳情 Modal -->
<div class="modal" id="foreshadow-detail-modal" style="max-width:min(95%,500px);max-height:85vh">
  <div class="modal-title">📌 伏筆詳情</div>
  <div style="max-height:60vh;overflow-y:auto;padding:4px">
    <div class="form-group">
      <label class="form-label">標題</label>
      <input type="text" class="form-input" id="f-detail-title" placeholder="伏筆標題">
    </div>

    <div class="form-group">
      <label class="form-label">描述</label>
      <textarea class="form-textarea" id="f-detail-desc" rows="3" placeholder="詳細描述這個伏筆..."></textarea>
    </div>

    <div class="form-group">
      <label class="form-label">埋下時間</label>
      <div style="font-size:13px;color:var(--text-secondary);padding:8px;background:var(--bg-tertiary);border-radius:6px" id="f-detail-time">未知</div>
      <button class="action-btn secondary" style="margin-top:8px;width:100%" onclick="jumpToForeshadowMessage()">📍 跳轉到原消息</button>
    </div>

    <div class="form-group">
      <label class="form-label">狀態</label>
      <select class="form-select" id="f-detail-status">
        <option value="false">📌 未回收</option>
        <option value="true">✅ 已回收</option>
      </select>
    </div>

    <div class="form-group">
      <label class="form-label">優先級</label>
      <select class="form-select" id="f-detail-priority">
        <option value="low">🟢 低</option>
        <option value="medium">🟡 中</option>
        <option value="high">🟠 高</option>
        <option value="urgent">🔴 緊急</option>
      </select>
    </div>

    <div class="form-group">
      <label class="form-label">標籤</label>
      <input type="text" class="form-input" id="f-detail-tags" placeholder="用逗號分隔，如：懸疑,伏筆,重要">
    </div>

    <div class="form-group">
      <label class="form-label">回收計劃</label>
      <textarea class="form-textarea" id="f-detail-plan" rows="3" placeholder="計劃如何回收這個伏筆..."></textarea>
      <button class="action-btn secondary" style="margin-top:8px;width:100%" onclick="aiGenerateRecoveryPlan()">🤖 AI 生成回收方案</button>
    </div>

    <div class="form-group">
      <label class="form-label">相關角色</label>
      <select class="form-select" id="f-detail-characters" multiple style="height:80px">
        <!-- 動態填充 -->
      </select>
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">按住 Ctrl/Cmd 可多選</div>
    </div>

    <div class="form-group">
      <label class="form-label">統計信息</label>
      <div style="font-size:12px;color:var(--text-secondary);padding:8px;background:var(--bg-tertiary);border-radius:6px">
        <div>📊 已過對話：<span id="f-detail-count">0</span> 條</div>
        <div style="margin-top:4px">📅 創建時間：<span id="f-detail-created">-</span></div>
        <div id="f-detail-resolved-info" style="margin-top:4px;display:none">✅ 回收時間：<span id="f-detail-resolved-time">-</span></div>
      </div>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('foreshadow-detail-modal')">取消</button>
    <button class="modal-btn secondary" onclick="deleteForeshadowDetail()">🗑️ 刪除</button>
    <button class="modal-btn confirm" onclick="saveForeshadowDetail()">保存</button>
  </div>
</div>
<!-- AI 智能分析 Modal -->
<div class="modal" id="foreshadow-smart-analysis-modal" style="max-width:min(95%,700px);max-height:90vh">
  <div class="modal-title">🤖 AI 智能分析結果</div>
  <div id="smart-analysis-content" style="max-height:70vh;overflow-y:auto;padding:4px"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('foreshadow-smart-analysis-modal')">關閉</button>
    <button class="modal-btn confirm" onclick="confirmSmartAnalysis()">確認選中項目</button>
  </div>
</div>
<!-- 伏筆建議 Modal -->
<div class="modal" id="foreshadow-suggestions-modal" style="max-width:min(95%,600px);max-height:85vh">
  <div class="modal-title">🤖 AI 識別的伏筆</div>
  <div id="suggestions-content" style="max-height:60vh;overflow-y:auto"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('foreshadow-suggestions-modal')">取消</button>
    <button class="modal-btn confirm" onclick="confirmForeshadowSuggestions()">添加選中的伏筆</button>
  </div>
</div>

<!-- 伏筆回收確認 Modal -->
<div class="modal" id="foreshadow-resolved-confirm-modal" style="max-width:min(95%,650px);max-height:85vh">
  <div class="modal-title">✅ AI 檢測到已回收的伏筆</div>
  <p style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    AI 分析發現以下伏筆可能已在對話中回收，請確認是否標記為已回收。
  </p>

  <!-- 分析摘要 -->
  <div id="foreshadow-analysis-summary" style="margin-bottom:16px"></div>

  <!-- 已回收的伏筆列表 -->
  <div style="margin-bottom:16px">
    <div style="font-weight:600;margin-bottom:10px;display:flex;align-items:center;justify-content:space-between">
      <span>選擇要標記的伏筆</span>
      <span style="font-size:12px;color:var(--text-tertiary)">（默認全選）</span>
    </div>
    <div id="resolved-foreshadow-list" style="max-height:300px;overflow-y:auto"></div>
  </div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('foreshadow-resolved-confirm-modal')">取消</button>
    <button class="modal-btn confirm" onclick="batchMarkForeshadowResolved()">標記為已回收</button>
  </div>
</div>

<!-- 伏筆時間線 Modal -->
<div class="modal" id="foreshadow-timeline-modal" style="max-width:min(95%,700px);max-height:85vh">
  <div class="modal-title">📅 伏筆時間線</div>
  <div id="foreshadow-timeline-content" style="max-height:60vh;overflow-y:auto;padding:12px"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('foreshadow-timeline-modal')">關閉</button>
  </div>
</div>
<!-- AI 章節總結 Modal -->
<div class="modal" id="ai-summary-modal" style="max-width:min(90%,400px)">
  <div class="modal-title">📝 AI 章節總結</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
    AI 將自動生成當前故事進度的摘要，包括主要事件、角色狀態變化等。
  </div>
  <div id="ai-summary-result" style="background:var(--bg-tertiary);padding:12px;border-radius:8px;min-height:100px;max-height:300px;overflow-y:auto;font-size:13px;white-space:pre-wrap">
    點擊「生成總結」開始...
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('ai-summary-modal')">關閉</button>
    <button class="modal-btn secondary" onclick="copySummary()">複製</button>
    <button class="modal-btn confirm" onclick="doAiChapterSummary()">生成總結</button>
  </div>
</div>
<!-- 高級搜索 Modal -->
<div class="modal" id="advanced-search-modal">
  <div class="modal-title">🔍 高級搜索</div>
  <div class="form-group">
    <label class="form-label">關鍵詞</label>
    <input type="text" class="form-input" id="adv-search-keyword" placeholder="輸入搜索關鍵詞">
  </div>
  <div class="form-group">
    <label class="form-label">搜索範圍</label>
    <select class="form-select" id="adv-search-scope">
      <option value="all">全部內容</option>
      <option value="user">僅用戶輸入</option>
      <option value="ai">僅 AI 回復</option>
    </select>
  </div>
  <div class="form-group">
    <label style="font-size:13px;color:var(--text-secondary);display:flex;align-items:center;gap:6px;cursor:pointer">
      <input type="checkbox" id="adv-search-case"> 區分大小寫
    </label>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('advanced-search-modal')">取消</button>
    <button class="modal-btn confirm" onclick="doAdvancedSearch()">搜索</button>
  </div>
</div>
<!-- 資料編輯 Modal -->
<div class="modal" id="lore-modal">
  <div class="modal-title">📖 資料設定</div>
  <div class="form-group">
    <label class="form-label">名稱</label>
    <input type="text" class="form-input" id="lore-name" placeholder="例如：夜寒、鳳儀宮">
  </div>
  <div class="form-group">
    <label class="form-label">類型</label>
    <select class="form-select" id="lore-category">
      <option value="character">👥 角色</option>
      <option value="location">🗺️ 地點</option>
      <option value="item">📦 物品</option>
      <option value="setting">📜 設定</option>
    </select>
  </div>
  <div class="form-group">
    <label class="form-label">簡介</label>
    <input type="text" class="form-input" id="lore-desc" placeholder="簡短描述">
  </div>
  <div class="form-group">
    <label class="form-label">詳細內容</label>
    <textarea class="form-input" id="lore-content-input" style="min-height:100px" placeholder="詳細設定內容，會作為上下文發送給 AI"></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('lore-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveLore()">保存</button>
  </div>
</div>
<!-- 時間軸編輯 Modal -->
<div class="modal" id="timeline-modal">
  <div class="modal-title">📅 添加時間點</div>
  <div class="form-group">
    <label class="form-label">日期分組</label>
    <input type="text" class="form-input" id="timeline-date" placeholder="例如：第一天、一月二日、Day 1">
  </div>
  <div class="form-group">
    <label class="form-label">時間標記</label>
    <input type="text" class="form-input" id="timeline-label" placeholder="例如：早上、中午、下午三點">
  </div>
  <div class="form-group">
    <label class="form-label">事件描述</label>
    <textarea class="form-input" id="timeline-event" style="min-height:60px" placeholder="這個時間點發生了什麼"></textarea>
  </div>
  <div class="form-group">
    <label class="form-label">劇情摘要 <span style="font-size:11px;color:var(--text-tertiary)">(可選，AI 可自動生成)</span></label>
    <textarea class="form-input" id="timeline-summary" style="min-height:80px" placeholder="這段時間玩家做了什麼..."></textarea>
    <button class="modal-btn secondary" onclick="generateTimelineSummary()" style="margin-top:8px;font-size:12px;padding:6px 12px">🤖 AI 生成摘要</button>
  </div>
  <div class="form-group">
    <label style="font-size:13px;color:var(--text-secondary);display:flex;align-items:center;gap:6px;cursor:pointer">
      <input type="checkbox" id="timeline-set-current" checked> 設為當前故事時間
    </label>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('timeline-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveTimeline()">保存</button>
  </div>
</div>
<!-- iOS 安裝指引 Modal -->
<div class="modal" id="ios-install-modal">
  <div class="modal-title">📱 在 iPhone 上安裝</div>
  <div class="modal-content" style="text-align:center">
    <p style="margin-bottom:16px;font-size:15px">請按照以下步驟安裝到主畫面：</p>
    <div style="text-align:left;background:var(--bg-tertiary);padding:16px;border-radius:8px;margin-bottom:16px">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
        <span style="font-size:24px">1️⃣</span>
        <span>點擊底部的 <strong>分享按鈕</strong> <span style="font-size:18px">⬆️</span></span>
      </div>
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
        <span style="font-size:24px">2️⃣</span>
        <span>向下滑動，點擊 <strong>「加入主畫面」</strong></span>
      </div>
      <div style="display:flex;align-items:center;gap:12px">
        <span style="font-size:24px">3️⃣</span>
        <span>點擊 <strong>「新增」</strong> 完成安裝</span>
      </div>
    </div>
    <p style="font-size:12px;color:var(--text-tertiary)">安裝後，織夢會像普通 App 一樣出現在您的主畫面</p>
  </div>
  <div class="modal-actions">
    <button class="modal-btn confirm" onclick="closeModal('ios-install-modal')">知道了</button>
  </div>
</div>
<!-- 向導角色編輯 Modal -->
<div class="modal" id="wizard-char-modal">
  <div class="modal-title">👤 角色設定</div>
  <input type="hidden" id="wiz-char-idx" value="-1">
  <div class="form-group">
    <label class="form-label">角色名稱</label>
    <input type="text" class="form-input" id="wiz-char-name" placeholder="如：夜寒、雲惜...">
  </div>
  <div class="form-group">
    <label class="form-label">身份地位</label>
    <input type="text" class="form-input" id="wiz-char-role" placeholder="如：皇夫、貼身侍女...">
  </div>
  <div class="form-group">
    <label class="form-label">性格特點</label>
    <input type="text" class="form-input" id="wiz-char-personality" placeholder="如：深沉腹黑、忠誠機敏...">
  </div>
  <div class="form-group">
    <label class="form-label">與主角關係</label>
    <input type="text" class="form-input" id="wiz-char-relation" placeholder="如：表面恭順暗懷野心、絕對忠誠...">
  </div>
  <div class="form-group">
    <label class="form-label">詳細描述（可選）</label>
    <textarea class="form-input" id="wiz-char-desc" style="min-height:80px" placeholder="角色的更多細節..."></textarea>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('wizard-char-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveWizardChar()">保存</button>
  </div>
</div>
<!-- 聊天背景 Modal -->
<div class="modal" id="chat-bg-modal">
  <div class="modal-title">🖼️ 聊天背景設置</div>
  <div class="form-group">
    <label class="form-label">選擇背景</label>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
      <div class="bg-option" data-bg="none" onclick="selectBg('none')" style="aspect-ratio:3/4;background:var(--bg-primary);border:2px solid var(--divider);border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--text-tertiary)">默認</div>
      <div class="bg-option" data-bg="gradient1" onclick="selectBg('gradient1')" style="aspect-ratio:3/4;background:linear-gradient(135deg,#1a1a2e,#16213e);border:2px solid var(--divider);border-radius:8px;cursor:pointer"></div>
      <div class="bg-option" data-bg="gradient2" onclick="selectBg('gradient2')" style="aspect-ratio:3/4;background:linear-gradient(135deg,#0f0f1a,#1e1e32);border:2px solid var(--divider);border-radius:8px;cursor:pointer"></div>
      <div class="bg-option" data-bg="gradient3" onclick="selectBg('gradient3')" style="aspect-ratio:3/4;background:linear-gradient(135deg,#1a0a0a,#2a1515);border:2px solid var(--divider);border-radius:8px;cursor:pointer"></div>
      <div class="bg-option" data-bg="gradient4" onclick="selectBg('gradient4')" style="aspect-ratio:3/4;background:linear-gradient(135deg,#0a1a0a,#152a15);border:2px solid var(--divider);border-radius:8px;cursor:pointer"></div>
      <div class="bg-option" data-bg="custom" onclick="uploadChatBg()" style="aspect-ratio:3/4;background:var(--bg-tertiary);border:2px dashed var(--divider);border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:20px">📷</div>
    </div>
    <div id="current-bg-preview" style="display:none;margin-bottom:12px">
      <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:6px">當前自定義背景：</div>
      <div id="bg-preview-img" style="width:100%;aspect-ratio:16/9;background-size:cover;background-position:center;border-radius:8px"></div>
      <button class="modal-btn cancel" style="margin-top:8px;width:100%" onclick="clearChatBg()">清除自定義背景</button>
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('chat-bg-modal')">關閉</button>
  </div>
</div>
<!-- 故事級別 AI 參數設置 Modal -->
<div class="modal" id="story-ai-params-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">🎛️ 本故事 AI 參數</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">為當前故事設置獨立的 AI 參數，不影響其他故事</div>
  
  <div style="padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="story-ai-use-custom" onchange="toggleStoryAICustom(this.checked)" style="width:18px;height:18px">
      <span style="font-size:13px">使用自定義參數（否則使用全局默認值）</span>
    </label>
  </div>
  
  <div id="story-ai-params-container" style="opacity:0.5;pointer-events:none">
    <div class="form-group">
      <label class="form-label" style="display:flex;justify-content:space-between;align-items:center">
        <span>🎨 創意度 (Temperature)</span>
        <span id="story-temp-value" style="color:var(--primary);font-weight:600">0.8</span>
      </label>
      <input type="range" id="story-temp-slider" min="0" max="200" value="80" style="width:100%" oninput="updateStoryAIParam('temperature',this.value/100)">
      <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text-tertiary);margin-top:4px">
        <span>保守穩定</span>
        <span>創意奔放</span>
      </div>
    </div>
    
    <div class="form-group">
      <label class="form-label" style="display:flex;justify-content:space-between;align-items:center">
        <span>📊 詞彙多樣性 (Top P)</span>
        <span id="story-topp-value" style="color:var(--primary);font-weight:600">0.9</span>
      </label>
      <input type="range" id="story-topp-slider" min="0" max="100" value="90" style="width:100%" oninput="updateStoryAIParam('topP',this.value/100)">
      <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text-tertiary);margin-top:4px">
        <span>精準</span>
        <span>多樣</span>
      </div>
    </div>
    
    <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
      <div style="font-size:12px;font-weight:600;margin-bottom:8px">🎯 快速預設</div>
      <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
        <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyStoryAIPreset('creative')">🎨 創意寫作</button>
        <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyStoryAIPreset('balanced')">⚖️ 平衡模式</button>
        <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyStoryAIPreset('precise')">🎯 精準敘事</button>
        <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyStoryAIPreset('wild')">🌪️ 天馬行空</button>
      </div>
    </div>
  </div>
  
  <div id="story-ai-current-info" style="padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px;font-size:12px">
    <div style="font-weight:600;margin-bottom:6px">📋 當前生效參數</div>
    <div id="story-ai-effective-params" style="color:var(--text-secondary)"></div>
  </div>
  
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('story-ai-params-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveStoryAIParams()">保存</button>
  </div>
</div>
<!-- AI 參數設置 Modal（全局默認值） -->
<div class="modal" id="ai-params-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">🎛️ AI 參數默認值</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">設置新故事的默認 AI 參數，已有故事可在故事設置中單獨調整</div>
  
  <div class="form-group">
    <label class="form-label" style="display:flex;justify-content:space-between;align-items:center">
      <span>🎨 創意度 (Temperature)</span>
      <span id="temp-value" style="color:var(--primary);font-weight:600">0.8</span>
    </label>
    <input type="range" id="temp-slider" min="0" max="200" value="80" style="width:100%" oninput="updateAIParam('temperature',this.value/100)">
    <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text-tertiary);margin-top:4px">
      <span>保守穩定</span>
      <span>創意奔放</span>
    </div>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">0.0-0.5 適合劇情推進，0.7-1.0 適合創意寫作，1.0+ 更隨機</div>
  </div>
  
  <div class="form-group">
    <label class="form-label" style="display:flex;justify-content:space-between;align-items:center">
      <span>📊 詞彙多樣性 (Top P)</span>
      <span id="topp-value" style="color:var(--primary);font-weight:600">0.9</span>
    </label>
    <input type="range" id="topp-slider" min="0" max="100" value="90" style="width:100%" oninput="updateAIParam('topP',this.value/100)">
    <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--text-tertiary);margin-top:4px">
      <span>精準</span>
      <span>多樣</span>
    </div>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">控制詞彙選擇範圍，0.9-1.0 較常用</div>
  </div>
  
  <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
    <div style="font-size:12px;font-weight:600;margin-bottom:8px">🎯 推薦預設</div>
    <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
      <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyAIPreset('creative')">🎨 創意寫作</button>
      <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyAIPreset('balanced')">⚖️ 平衡模式</button>
      <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyAIPreset('precise')">🎯 精準敘事</button>
      <button class="modal-btn" style="padding:8px;font-size:12px" onclick="applyAIPreset('wild')">🌪️ 天馬行空</button>
    </div>
  </div>
  
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('ai-params-modal')">關閉</button>
  </div>
</div>
<!-- 快捷指令管理 Modal -->
<div class="modal" id="quick-cmd-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">⚡ 快捷指令管理</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    自定義快捷按鈕，點擊後會自動發送對應指令給 AI
  </div>
  
  <div id="quick-cmd-list" style="margin-bottom:16px">
    <!-- 動態渲染 -->
  </div>
  
  <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
    <div style="font-size:12px;font-weight:600;margin-bottom:10px">➕ 添加新指令</div>
    <div class="form-group" style="margin-bottom:10px">
      <input type="text" class="form-input" id="new-cmd-label" placeholder="按鈕顯示文字（如：回憶）" maxlength="10">
    </div>
    <div class="form-group" style="margin-bottom:10px">
      <input type="text" class="form-input" id="new-cmd-content" placeholder="發送給AI的指令（如：回憶過去的事情）">
    </div>
    <button class="modal-btn confirm" style="width:100%" onclick="addQuickCommand()">添加</button>
  </div>
  
  <div style="padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px;font-size:11px;color:var(--text-tertiary)">
    <div style="font-weight:600;margin-bottom:6px">💡 提示</div>
    <div>• 拖動指令可調整順序</div>
    <div>• 顯示文字建議 2-4 個字</div>
    <div>• 指令內容會直接發送給 AI</div>
  </div>
  
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="resetQuickCommands()">恢復默認</button>
    <button class="modal-btn confirm" onclick="closeModal('quick-cmd-modal')">完成</button>
  </div>
</div>
<!-- 編輯快捷指令 Modal -->
<div class="modal" id="edit-cmd-modal">
  <div class="modal-title">✏️ 編輯快捷指令</div>
  <input type="hidden" id="edit-cmd-id">
  <div class="form-group">
    <label class="form-label">按鈕顯示文字</label>
    <input type="text" class="form-input" id="edit-cmd-label" placeholder="如：回憶" maxlength="10">
  </div>
  <div class="form-group">
    <label class="form-label">發送給AI的指令</label>
    <input type="text" class="form-input" id="edit-cmd-content" placeholder="如：回憶過去的事情">
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('edit-cmd-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveEditQuickCommand()">保存</button>
  </div>
</div>
<!-- 場景管理 Modal -->
<div class="modal" id="scene-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">🎬 場景管理</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    設置當前場景中在場的角色，AI 會讓這些角色互動
  </div>
  
  <div style="margin-bottom:16px">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <span style="font-size:13px;font-weight:600">當前場景</span>
      <select class="form-select" id="current-scene" style="width:auto;min-width:120px" onchange="switchScene(this.value)">
        <option value="">無場景</option>
      </select>
    </div>
    <div style="font-size:11px;color:var(--text-tertiary)">選擇場景後，AI 會根據在場角色進行多角色互動</div>
  </div>
  
  <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
    <div style="font-size:12px;font-weight:600;margin-bottom:10px">📋 場景列表</div>
    <div id="scene-list" style="max-height:200px;overflow-y:auto">
      <!-- 動態渲染 -->
    </div>
    <button class="modal-btn" style="width:100%;margin-top:10px" onclick="createNewScene()">➕ 創建新場景</button>
  </div>
  
  <div id="scene-detail-section" style="display:none">
    <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
      <div style="font-size:12px;font-weight:600;margin-bottom:10px">👥 在場角色</div>
      <div id="scene-characters" style="max-height:200px;overflow-y:auto">
        <!-- 動態渲染 -->
      </div>
    </div>
  </div>
  
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('scene-modal')">關閉</button>
  </div>
</div>
<!-- 創建/編輯場景 Modal -->
<div class="modal" id="scene-edit-modal">
  <div class="modal-title" id="scene-edit-title">創建場景</div>
  <input type="hidden" id="scene-edit-id">
  <div class="form-group">
    <label class="form-label">場景名稱</label>
    <input type="text" class="form-input" id="scene-edit-name" placeholder="如：早朝、宴會、後宮花園...">
  </div>
  <div class="form-group">
    <label class="form-label">場景描述（可選）</label>
    <textarea class="form-textarea" id="scene-edit-desc" rows="2" placeholder="描述這個場景的氛圍、時間、地點等..."></textarea>
  </div>
  <div class="form-group">
    <label class="form-label">選擇在場角色</label>
    <div id="scene-char-selector" style="max-height:200px;overflow-y:auto;padding:8px;background:var(--bg-tertiary);border-radius:8px">
      <!-- 動態渲染角色複選框 -->
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('scene-edit-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveScene()">保存</button>
  </div>
</div>
<!-- 玩家面板 Modal -->
<div class="modal" id="player-panel-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">👤 我的狀態</div>
  <div id="player-panel-content">
    <div style="text-align:center;padding:24px;color:var(--text-tertiary)">
      <div style="font-size:32px;margin-bottom:12px">📋</div>
      <div style="font-size:14px">還沒有設置狀態面板</div>
      <div style="font-size:12px;margin-top:4px">點擊下方按鈕創建</div>
    </div>
  </div>
  <button class="player-sync-btn" id="player-sync-btn" onclick="aiSyncPlayerStatus()" style="display:none">
    🤖 AI 智能同步（從對話中解析數值變化）
  </button>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('player-panel-modal')">關閉</button>
    <button class="modal-btn" style="background:var(--bg-tertiary);color:var(--text-primary)" onclick="showPlayerPanelSetup()">⚙️ 設置面板</button>
    <button class="modal-btn confirm" onclick="manualUpdatePlayerPanel()">✏️ 更新數值</button>
  </div>
</div>
<!-- 玩家面板設置 Modal -->
<div class="modal" id="player-panel-setup-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">⚙️ 設置我的狀態面板</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    自定義要追蹤的屬性，AI 會在回覆中自動更新這些數值
  </div>
  <div class="form-group">
    <label class="form-label">面板名稱</label>
    <input type="text" class="form-input" id="player-panel-name" placeholder="如：角色狀態、我的資料...">
  </div>
  <div class="form-group">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <label class="form-label" style="margin:0">屬性列表</label>
      <button class="action-btn secondary" style="padding:4px 10px;font-size:12px" onclick="addPlayerAttribute()">➕ 添加</button>
    </div>
    <div id="player-attr-list" style="max-height:300px;overflow-y:auto">
      <div style="text-align:center;padding:16px;color:var(--text-tertiary);font-size:13px">還沒有屬性，點擊添加</div>
    </div>
  </div>
  <div class="form-group">
    <button class="action-btn secondary" style="width:100%" onclick="aiGeneratePlayerPanel()">🤖 AI 根據設定自動生成</button>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px;text-align:center">AI 會根據故事的 System Prompt 和 Lorebook 自動推薦適合的屬性</div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('player-panel-setup-modal')">取消</button>
    <button class="modal-btn confirm" onclick="savePlayerPanelSetup()">保存</button>
  </div>
</div>
<!-- 添加/編輯玩家屬性 Modal -->
<div class="modal" id="player-attr-modal">
  <div class="modal-title" id="player-attr-modal-title">➕ 添加屬性</div>
  <input type="hidden" id="player-attr-edit-index" value="-1">
  <div class="form-group">
    <label class="form-label">屬性名稱</label>
    <input type="text" class="form-input" id="player-attr-name" placeholder="如：現金、體力、好感度...">
  </div>
  <div class="form-group">
    <label class="form-label">圖標</label>
    <input type="text" class="form-input" id="player-attr-icon" placeholder="💰" maxlength="2" style="width:60px">
  </div>
  <div class="form-group">
    <label class="form-label">所屬分組</label>
    <div id="player-attr-group-selector" class="group-selector">
      <span class="group-chip active" data-group="default" onclick="selectAttrGroup(this)">📊 預設</span>
      <span class="group-chip" data-group="stats" onclick="selectAttrGroup(this)">💪 基礎屬性</span>
      <span class="group-chip" data-group="status" onclick="selectAttrGroup(this)">❤️ 當前狀態</span>
      <span class="group-chip" data-group="finance" onclick="selectAttrGroup(this)">💰 財務</span>
      <span class="group-chip" data-group="custom" onclick="selectAttrGroup(this)">✨ 自定義</span>
    </div>
    <input type="hidden" id="player-attr-group" value="default">
    <div id="player-attr-custom-group" style="display:none;margin-top:8px">
      <input type="text" class="form-input" id="player-attr-custom-group-name" placeholder="輸入自定義分組名稱">
    </div>
  </div>
  <div class="form-group">
    <label class="form-label">類型</label>
    <select class="form-select" id="player-attr-type" onchange="updatePlayerAttrTypeUI()">
      <option value="number">數字（如：金錢、天數）</option>
      <option value="percent">百分比（如：體力、好感度）</option>
      <option value="text">文字（如：職位、稱號）</option>
    </select>
  </div>
  <div class="form-group">
    <label class="form-label">顏色</label>
    <div class="group-selector">
      <span class="group-chip active" data-color="default" onclick="selectAttrColor(this)" style="border-left:3px solid var(--primary)">預設</span>
      <span class="group-chip" data-color="red" onclick="selectAttrColor(this)" style="border-left:3px solid #EF4444">紅</span>
      <span class="group-chip" data-color="orange" onclick="selectAttrColor(this)" style="border-left:3px solid #F59E0B">橙</span>
      <span class="group-chip" data-color="green" onclick="selectAttrColor(this)" style="border-left:3px solid #10B981">綠</span>
      <span class="group-chip" data-color="blue" onclick="selectAttrColor(this)" style="border-left:3px solid #3B82F6">藍</span>
      <span class="group-chip" data-color="purple" onclick="selectAttrColor(this)" style="border-left:3px solid #8B5CF6">紫</span>
      <span class="group-chip" data-color="pink" onclick="selectAttrColor(this)" style="border-left:3px solid #EC4899">粉</span>
    </div>
    <input type="hidden" id="player-attr-color" value="default">
  </div>
  <div id="player-attr-type-options">
    <div class="form-group">
      <label class="form-label">初始值</label>
      <input type="text" class="form-input" id="player-attr-default" placeholder="0">
    </div>
    <div class="form-group" id="player-attr-max-group">
      <label class="form-label">最大值（百分比用）</label>
      <input type="number" class="form-input" id="player-attr-max" value="100">
    </div>
  </div>
  <div class="form-group">
    <label class="form-label">觸發關鍵詞（用於自動解析）</label>
    <input type="text" class="form-input" id="player-attr-keywords" placeholder="如：現金, 餘額, 金錢">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">AI 回覆中包含這些詞時會嘗試更新此屬性</div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('player-attr-modal')">取消</button>
    <button class="modal-btn confirm" onclick="savePlayerAttribute()">保存</button>
  </div>
</div>
<!-- 手動更新玩家數值 Modal -->
<div class="modal" id="player-update-modal" style="max-height:85vh;overflow-y:auto">
  <div class="modal-title">✏️ 更新我的狀態</div>
  <div id="player-update-fields"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('player-update-modal')">取消</button>
    <button class="modal-btn confirm" onclick="savePlayerUpdate()">保存</button>
  </div>
</div>
<!-- AI生成Lorebook Modal -->
<div class="modal" id="ai-lorebook-modal" style="max-width:min(95%,500px);max-height:85vh;overflow-y:auto">
  <div class="modal-title">🤖 AI 智能提取 Lorebook</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    AI 會從最近的對話劇情中自動提取角色、地點、物品、事件等信息，生成 Lorebook 條目
  </div>
  <div class="form-group">
    <label class="form-label">📊 分析範圍</label>
    <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px">
      <div style="margin-bottom:8px;color:var(--text-primary);font-size:13px">
        <span id="ai-lorebook-range-display">最近 20 條對話消息</span>
      </div>
      <input type="range" id="ai-lorebook-range" min="5" max="50" value="20" step="5" style="width:100%;margin:8px 0" oninput="updateLorebookRangeDisplay(this.value)">
      <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text-tertiary)">
        <span>5條</span>
        <span>50條</span>
      </div>
    </div>
  </div>
  <div class="form-group">
    <label class="form-label">🎯 提取選項</label>
    <div style="display:flex;flex-direction:column;gap:8px">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;cursor:pointer">
        <input type="checkbox" id="ai-lorebook-chars" checked> 提取角色設定為角色卡
      </label>
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;cursor:pointer">
        <input type="checkbox" id="ai-lorebook-player" checked> 提取玩家屬性到狀態面板
      </label>
    </div>
  </div>
  <div id="ai-lorebook-preview" style="display:none;margin-bottom:16px">
    <div style="font-size:13px;font-weight:600;margin-bottom:8px">📋 預覽</div>
    <div id="ai-lorebook-preview-content" style="max-height:200px;overflow-y:auto;background:var(--bg-tertiary);border-radius:8px;padding:12px;font-size:12px"></div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('ai-lorebook-modal')">取消</button>
    <button class="modal-btn" id="ai-lorebook-generate-btn" style="background:var(--primary);color:white" onclick="generateAiLorebook()">🤖 開始提取</button>
  </div>
</div>
<!-- Lorebook 合併選擇 Modal -->
<div class="modal" id="lorebook-merge-select-modal" style="max-width:min(95%,500px);max-height:85vh;overflow-y:auto">
  <div class="modal-title">🔗 選擇要合併的 Lorebook 條目</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">
    勾選 2 個或以上的條目，AI 會將它們合併為一個條目並去除重複內容。
  </div>
  <div style="display:flex;gap:8px;margin-bottom:12px">
    <button class="action-btn secondary" onclick="lorebookMergeSelectAll()" style="font-size:12px;padding:6px 10px">✅ 全選</button>
    <button class="action-btn secondary" onclick="lorebookMergeDeselectAll()" style="font-size:12px;padding:6px 10px">❌ 取消全選</button>
    <span style="margin-left:auto;font-size:13px;color:var(--text-secondary);display:flex;align-items:center">已選 <strong id="lorebook-merge-count" style="margin:0 4px">0</strong> 項</span>
  </div>
  <div style="position:relative;margin-bottom:12px">
    <span style="position:absolute;left:10px;top:50%;transform:translateY(-50%);color:var(--text-tertiary)">🔍</span>
    <input type="text" id="lorebook-merge-search" placeholder="搜索條目名稱或關鍵詞..." oninput="filterLorebookMergeList()" style="width:100%;padding:8px 8px 8px 32px;border:1px solid var(--divider);border-radius:8px;background:var(--bg-primary);font-size:13px;box-sizing:border-box">
  </div>
  <div id="lorebook-merge-list" style="max-height:400px;overflow-y:auto;border:1px solid var(--divider);border-radius:8px;padding:8px;background:var(--bg-tertiary)"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('lorebook-merge-select-modal')">取消</button>
    <button class="modal-btn confirm" onclick="startLorebookMerge()">🤖 AI 合併</button>
  </div>
</div>
<!-- Lorebook 合併預覽 Modal -->
<div class="modal" id="lorebook-merge-preview-modal" style="max-width:min(95%,500px);max-height:85vh;overflow-y:auto">
  <div class="modal-title">📝 合併預覽</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px">
    請確認合併結果，可直接編輯內容。確認後將刪除原條目並建立新條目。
  </div>
  <div class="form-group">
    <label class="form-label">名稱</label>
    <input type="text" class="form-input" id="lorebook-merge-name">
  </div>
  <div class="form-group">
    <label class="form-label">觸發關鍵詞（逗號分隔）</label>
    <input type="text" class="form-input" id="lorebook-merge-keywords">
  </div>
  <div class="form-group">
    <label class="form-label">內容</label>
    <textarea class="form-input" id="lorebook-merge-content" style="min-height:200px;resize:vertical"></textarea>
  </div>
  <div id="lorebook-merge-source-info" style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;padding:8px;background:var(--bg-tertiary);border-radius:6px"></div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('lorebook-merge-preview-modal')">取消</button>
    <button class="modal-btn confirm" onclick="confirmLorebookMerge()">✅ 確認合併</button>
  </div>
</div>
<!-- 雲端同步設置 Modal -->
<div class="modal" id="cloud-sync-modal" style="max-width:min(95%,500px)">
  <div class="modal-title">☁️ 雲端同步設置</div>
  <div style="font-size:13px;color:var(--text-secondary);margin-bottom:16px">
    使用 GitHub Gist 作為雲端存儲，實現跨設備同步
  </div>

  <div class="form-group">
    <label class="form-label">GitHub Personal Access Token</label>
    <input type="password" class="form-input" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">
      需要 <code style="background:var(--bg-tertiary);padding:2px 4px;border-radius:3px">gist</code> 權限
    </div>
  </div>

  <div class="form-group">
    <label class="form-label">Gist ID（可選）</label>
    <input type="text" class="form-input" id="gist-id" placeholder="留空將自動創建新 Gist">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">
      如果已有 Gist，填入 ID 可繼續使用
    </div>
  </div>

  <div class="form-group">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="auto-sync-enabled">
      <span class="form-label" style="margin:0">啟用自動同步</span>
    </label>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">
      每次保存故事時自動上傳到雲端
    </div>
  </div>

  <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:16px">
    <div style="font-size:12px;font-weight:600;margin-bottom:8px">📖 如何獲取 GitHub Token？</div>
    <ol style="font-size:11px;color:var(--text-secondary);margin:0;padding-left:20px;line-height:1.6">
      <li>訪問 <a href="https://github.com/settings/tokens/new" target="_blank" style="color:var(--primary)">GitHub Token 設置頁面</a></li>
      <li>Note 填寫：<code style="background:var(--bg-secondary);padding:2px 4px">織夢雲端同步</code></li>
      <li>Expiration 選擇：<code style="background:var(--bg-secondary);padding:2px 4px">No expiration</code></li>
      <li>勾選權限：<code style="background:var(--bg-secondary);padding:2px 4px">gist</code></li>
      <li>點擊底部 <code style="background:var(--bg-secondary);padding:2px 4px">Generate token</code></li>
      <li>複製生成的 Token（以 ghp_ 開頭）</li>
    </ol>
  </div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('cloud-sync-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveCloudSyncSettings()">保存</button>
  </div>
</div>
<!-- 簡繁轉換設置 Modal -->
<div class="modal" id="cn-convert-modal">
  <div class="modal-title">🌐 语言设置</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    设置界面语言和 AI 输出语言
  </div>
  <div class="form-group">
    <label class="form-label">界面语言</label>
    <select class="form-select" id="ui-language-mode" onchange="updateCnConvertPreview()">
      <option value="sc">简体中文</option>
      <option value="tc">繁體中文</option>
    </select>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">
      切换织梦界面的显示语言
    </div>
  </div>
  <div class="form-group">
    <label class="form-label">AI 输出语言</label>
    <select class="form-select" id="cn-convert-mode" onchange="updateCnConvertPreview()">
      <option value="follow">跟随界面语言</option>
      <option value="none">不指定（AI 默认）</option>
      <option value="s2t">繁體中文（台灣/香港）</option>
      <option value="t2s">简体中文（中国大陆）</option>
    </select>
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">
      指示 AI 用哪种中文回复
    </div>
  </div>
  <div style="padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px;font-size:12px">
    <div style="font-weight:600;margin-bottom:6px">💡 效果说明</div>
    <div id="cn-convert-preview" style="color:var(--text-secondary)">
      界面和 AI 都使用简体中文
    </div>
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('cn-convert-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveChineseConvert()">保存</button>
  </div>
</div>
<!-- 模板變量設置 Modal -->
<div class="modal" id="template-vars-modal">
  <div class="modal-title">📝 模板變量設置</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    設置這些變量後，可以在指令和 Lorebook 中使用 <code style="background:var(--bg-tertiary);padding:2px 4px;border-radius:3px">{{變量名}}</code> 引用
  </div>
  
  <div class="form-group">
    <label class="form-label">{{user}} - 玩家稱呼</label>
    <input type="text" class="form-input" id="var-player-name" placeholder="你、陛下、少俠..." value="">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">AI 稱呼玩家時使用的名字</div>
  </div>
  
  <div class="form-group">
    <label class="form-label">{{location}} - 當前地點</label>
    <input type="text" class="form-input" id="var-location" placeholder="長樂宮、聚賢莊..." value="">
    <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">故事當前發生的地點</div>
  </div>
  
  <div style="padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px">
    <div style="font-size:12px;font-weight:600;margin-bottom:8px">📋 可用變量列表</div>
    <div style="font-size:11px;color:var(--text-secondary);line-height:1.8">
      <div><code>{{user}}</code> → 玩家稱呼</div>
      <div><code>{{location}}</code> → 當前地點</div>
      <div><code>{{time}}</code> → 故事時間（從時間軸讀取）</div>
      <div><code>{{date}}</code> → 現實日期</div>
      <div><code>{{char:角色名}}</code> → 指定角色的信息</div>
    </div>
  </div>
  
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('template-vars-modal')">取消</button>
    <button class="modal-btn confirm" onclick="saveTemplateVars()">保存</button>
  </div>
</div>
<!-- Persona 選擇器 Modal -->
<div class="modal" id="persona-selector-modal">
  <div class="modal-title">👤 選擇身份</div>
  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px">
    選擇你在故事中扮演的角色身份，AI 會根據你的身份調整回應
  </div>
  <div id="persona-list" style="max-height:calc(85vh - 200px);overflow-y:auto;margin-bottom:16px">
    <!-- 動態渲染 -->
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('persona-selector-modal')">取消</button>
    <button class="modal-btn" onclick="showPersonaManager()" style="background:var(--bg-tertiary);color:var(--text-primary)">⚙️ 管理身份</button>
  </div>
</div>
<!-- Persona 編輯 Modal -->
<div class="modal" id="persona-edit-modal">
  <div class="modal-title" id="persona-edit-title">✨ 創建新身份</div>
  <input type="hidden" id="persona-edit-id" value="">

  <div style="max-height:calc(85vh - 160px);overflow-y:auto;margin-bottom:16px">
    <div class="form-group">
      <label class="form-label">頭像</label>
      <input type="text" class="form-input" id="persona-avatar" placeholder="👸" maxlength="2">
      <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">輸入一個 emoji 或留空使用默認 👤</div>
    </div>

    <div class="form-group">
      <label class="form-label">名稱 *</label>
      <input type="text" class="form-input" id="persona-name" placeholder="林婉儿">
    </div>

    <div class="form-group">
      <label class="form-label">簡介</label>
      <input type="text" class="form-input" id="persona-description" placeholder="江南富商之女，知書達理，溫婉可人">
    </div>

    <div class="form-group">
      <label class="form-label">背景故事</label>
      <textarea class="form-input" id="persona-background" placeholder="林家是江南首富，婉儿自幼飽讀詩書..." rows="3"></textarea>
    </div>

    <div class="form-group">
      <label class="form-label">說話風格</label>
      <input type="text" class="form-input" id="persona-speech-style" placeholder="說話溫柔，常用「奴家」自稱">
    </div>

    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;font-size:12px;color:var(--text-secondary)">
      <div style="font-weight:600;margin-bottom:6px">💡 提示</div>
      <div style="line-height:1.6">
        • 設置詳細的背景故事可以讓 AI 更好地理解你的角色<br>
        • 說話風格會影響 AI 對你的回應方式<br>
        • 切換身份後，建議開啟新對話以獲得最佳效果
      </div>
    </div>
  </div>

  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('persona-edit-modal')">取消</button>
    <button class="modal-btn confirm" onclick="savePersona()">保存</button>
  </div>
</div>
<!-- Persona 管理 Modal -->
<div class="modal" id="persona-manager-modal">
  <div class="modal-title">⚙️ 管理身份</div>
  <div id="persona-manager-list" style="max-height:calc(85vh - 200px);overflow-y:auto;margin-bottom:16px">
    <!-- 動態渲染 -->
  </div>
  <div class="modal-actions">
    <button class="modal-btn cancel" onclick="closeModal('persona-manager-modal')">關閉</button>
    <button class="modal-btn confirm" onclick="createNewPersona()">+ 創建新身份</button>
  </div>
</div>
<!-- 隱藏輸入 -->
<input type="file" id="file-input" accept=".md,.txt,.json" style="display:none">
<input type="file" id="import-input" accept=".json" style="display:none">
<script>
// 全局状态管理
// 注意：为了减少全局命名空间污染，新代码应该使用 window.App 对象
// 现有代码为了兼容性暂时保留独立的全局变量

// 数据库和核心状态
let db, story=null, msgs=[], hist=['view-stories'];
let currentPlayerPanel = null; // 玩家狀態面板（用於消息中顯示玩家狀態卡片）

// UI状态和标志
let generating=false, loadingStoryId=null;

// 控制器和回调
let typingCtrl=null, selMsgId=null, confirmCb=null, inputCb=null, editApiId=null;

// 定时器
let timeUpdateInterval=null;

// OpenCC 转换器全局变量
let openccT2S = null;  // 繁体转简体
let openccS2T = null;  // 简体转繁体

// 【推荐】统一的状态访问接口（用于未来重构）
window.App = {
  // 状态访问器（返回当前值）
  getDB: () => db,
  getStory: () => story,
  getMsgs: () => msgs,
  getHist: () => hist,
  isGenerating: () => generating,

  // 便捷方法
  reset: () => {
    story = null;
    msgs = [];
    generating = false;
    loadingStoryId = null;
    console.log('[App] 状态已重置');
  }
};
let settings={theme:'dark',screen:'phone',consist:true,summary:true,suggest:true,typingSpeed:30,contextCount:20,maxTokens:4096,sendKey:'enter',chatBg:'none',chatBgImage:'',fontSize:16,lineHeight:1.6,paragraphSpacing:'1em',
  // AI 參數
  temperature:0.8,topP:0.9,frequencyPenalty:0.3,presencePenalty:0.1,
  // 模板變量
  playerName:'你',currentLocation:'',
  // 簡繁轉換
  chineseConvert:'t2s',
  uiLanguage:'sc',  // sc=简体, tc=繁体
  // 流式響應
  enableStreaming:true,streamingChunkDelay:20,
  // 自動摘要
  autoSummary:true,autoSummaryFrequency:15,maxRollingSummaries:10,
  // AI智能提取Lorebook
  autoLorebook:false,autoLorebookFrequency:10,lastLorebookExtractMsg:0,
  // AI自動一致性檢查
  autoConsistencyCheck:false,consistencyCheckFrequency:30,lastConsistencyCheckMsg:0,
  // AI自動檢測時間變化
  autoDetectTime:true,
  // 智能上下文選擇
  smartContext:true,smartContextRecent:10,smartContextMinScore:30,
  // 智能角色選擇
  smartCharacterSelection:true,characterRecentMessages:20,alwaysIncludeMainCharacters:true
};

// ============================================
// 工具函数定义（必须在使用前定义）
// ============================================

// 防抖函数
function debounce(func, wait){
  let timeout;
  return function executedFunction(...args){
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 初始化 OpenCC 转换器
async function initOpenCC(){
  if(typeof OpenCC !== 'undefined'){
    try {
      openccT2S = OpenCC.Converter({ from: 'tw', to: 'cn' });
      openccS2T = OpenCC.Converter({ from: 'cn', to: 'tw' });
      console.log('[OpenCC] 转换器初始化成功');
      return true;
    } catch(e) {
      console.error('[OpenCC] 转换器初始化失败:', e);
      return false;
    }
  }
  return false;
}

// 初始化
document.addEventListener('DOMContentLoaded',async()=>{
  await initDB();
  await loadSettings();

  // 初始化 OpenCC 并等待完成后再转换界面
  const tryTranslate = async (retries = 5) => {
    if(!openccT2S && typeof OpenCC !== 'undefined'){
      await initOpenCC();
    }
    if(openccT2S){
      translateUI();
      console.log('[OpenCC] 界面翻譯成功');
    } else if(retries > 0){
      console.log(`[OpenCC] 等待加載... 剩餘重試次數: ${retries}`);
      setTimeout(() => tryTranslate(retries - 1), 100);
    } else {
      // 达到最大重试次数，记录警告但不影响应用运行
      console.warn('[OpenCC] OpenCC 加載失敗，將使用默認語言');
    }
  };
  await tryTranslate();

  await renderStories();
  await renderInst();
  await renderApi();
  await renderQuickCommands();
  initTypingCancel(); // 初始化打字機取消功能
  initDraftAutoSave(); // 初始化草稿自动保存
  updateTime();
  // 存储定时器引用，便于清理
  if(timeUpdateInterval) clearInterval(timeUpdateInterval);
  timeUpdateInterval = setInterval(updateTime,60000);
});

// ============================================
// 草稿自动保存功能
// ============================================

// 保存草稿到数据库（使用防抖，1秒后保存）
const saveDraftToDB = debounce(async (storyId, content) => {
  try {
    await db.stories.update(storyId, {
      draft: content,
      updatedAt: Date.now()
    });
    console.log('[Draft] 草稿已自动保存');
  } catch(e) {
    console.error('[Draft] 保存失败:', e);
  }
}, 1000);

// 初始化草稿自动保存
let draftAutoSaveInitialized = false;
function initDraftAutoSave(){
  if(draftAutoSaveInitialized) {
    console.log('[Draft] 草稿自动保存已经初始化，跳过重复初始化');
    return;
  }

  const input = document.getElementById('user-input');
  if(!input) {
    console.warn('[Draft] 未找到输入框，草稿自动保存未启用');
    return;
  }

  // 监听输入事件
  input.addEventListener('input', (e) => {
    if(story && e.target.value) {
      saveDraftToDB(story.id, e.target.value).catch(err => {
        console.error('[Draft] 保存草稿失败:', err);
        toast(T('草稿保存失敗'));
      });
    }
  });

  draftAutoSaveInitialized = true;
  console.log('[Draft] 草稿自动保存已启用');
}

// 页面关闭前提醒（如果有未发送的内容）
window.addEventListener('beforeunload', (e) => {
  const input = document.getElementById('user-input');
  if(input && input.value.trim() && story) {
    e.preventDefault();
    e.returnValue = '您有未发送的内容，确定要离开吗？（内容已自动保存为草稿）';
    return e.returnValue;
  }
});

// 數據庫
async function initDB(){
  db=new Dexie('ZhimengDB');
  db.version(7).stores({
    stories:'id,title,createdAt,updatedAt,isPinned',
    messages:'id,storyId,branchId,[storyId+branchId],createdAt',
    branches:'id,storyId,parentBranchId,createdAt',
    instructions:'id,createdAt',
    storyInstructions:'[storyId+instructionId],storyId,instructionId',
    loreEntries:'id,storyId,category,createdAt',
    foreshadowing:'id,storyId,messageId,isResolved,createdAt',
    events:'id,storyId,messageId,createdAt',
    characterStates:'id,storyId,loreEntryId',
    timeline:'id,storyId,messageId,order',
    saves:'id,storyId,slotIndex,isAuto,createdAt',
    apiPresets:'id,isActive,createdAt',
    settings:'key',
    chapters:'id,storyId,messageId,order,createdAt',
    bookmarks:'id,storyId,messageId,createdAt',
    plotTags:'id,storyId,messageId,type,createdAt',
    // v7 新增：角色系統
    characters:'id,storyId,name,createdAt,updatedAt',
    characterSnapshots:'id,storyId,createdAt',
    characterHistory:'id,storyId,characterId,createdAt',
    // v13 新增：Lorebook 系統
    lorebook:'id,storyId,name,isEnabled,priority,createdAt',
    lorebookTriggerLog:'id,storyId,lorebookId,createdAt',
    // v16 新增：快捷指令
    quickCommands:'id,order,createdAt',
    // v16 新增：場景系統
    scenes:'id,storyId,name,isActive,createdAt',
    // v22 新增：Persona 系統
    personas:'id,name,createdAt',
    // v23 新增：玩家面板系統
    playerPanels:'id,storyId,createdAt'
  });
  
  // v8 新增：角色卡 V2 字段（Character Card V2 規範）
  // Dexie 會自動處理升級，舊數據會保留
  db.version(8).stores({
    stories:'id,title,createdAt,updatedAt,isPinned',
    messages:'id,storyId,branchId,[storyId+branchId],createdAt',
    branches:'id,storyId,parentBranchId,createdAt',
    instructions:'id,createdAt',
    storyInstructions:'[storyId+instructionId],storyId,instructionId',
    loreEntries:'id,storyId,category,createdAt',
    foreshadowing:'id,storyId,messageId,isResolved,createdAt',
    events:'id,storyId,messageId,createdAt',
    characterStates:'id,storyId,loreEntryId',
    timeline:'id,storyId,messageId,order',
    saves:'id,storyId,slotIndex,isAuto,createdAt',
    apiPresets:'id,isActive,createdAt',
    settings:'key',
    chapters:'id,storyId,messageId,order,createdAt',
    bookmarks:'id,storyId,messageId,createdAt',
    plotTags:'id,storyId,messageId,type,createdAt',
    // v8 升級：角色系統 V2（支持 Character Card V2 規範）
    // 新增字段：category, relationships, scenario, first_mes, alternate_greetings,
    //          mes_example, system_prompt, post_history_instructions, character_book,
    //          expressions, creator_notes, creator, character_version
    characters:'id,storyId,name,category,createdAt,updatedAt',
    characterSnapshots:'id,storyId,createdAt',
    characterHistory:'id,storyId,characterId,createdAt',
    lorebook:'id,storyId,name,isEnabled,priority,createdAt',
    lorebookTriggerLog:'id,storyId,lorebookId,createdAt',
    quickCommands:'id,order,createdAt',
    scenes:'id,storyId,name,isActive,createdAt',
    personas:'id,name,createdAt',
    playerPanels:'id,storyId,createdAt'
  });

  await db.open();
  // 初始化默認快捷指令
  await initDefaultQuickCommands();
  // 初始化默認 Persona
  await initDefaultPersona();
}

// 設置
async function loadSettings(){
  try{
    const s=await db.settings.toArray();
    s.forEach(x=>{if(x.key in settings)settings[x.key]=x.value});
    applySettings();
  }catch(e){
    console.error('[Settings] 載入設置失敗:', e);
    // 使用默認設置繼續運行
    applySettings();
  }
}
async function saveSetting(k,v){
  if(!db){
    console.error('[Settings] 數據庫未初始化，無法保存設置');
    return;
  }
  try {
    await db.settings.put({key:k,value:v});
    settings[k]=v;
  } catch(e) {
    console.error('[Settings] 保存設置失敗:', e);
    toast(T('設置保存失敗'), 'error');
  }
}
function applySettings(){
  const isSC = settings.uiLanguage === 'sc';
  document.documentElement.setAttribute('data-theme',settings.theme);

  const themeVal = document.getElementById('theme-val');
  if(themeVal) themeVal.textContent=settings.theme==='dark'?'深色模式 ›':(isSC?'浅色模式 ›':'淺色模式 ›');

  const app=document.getElementById('app');
  const screenVal = document.getElementById('screen-val');
  if(app){
    if(settings.screen==='fullscreen'){
      app.classList.add('fullscreen');
      if(screenVal) screenVal.textContent=isSC?'全屏模式 ›':'全屏模式 ›';
    } else {
      app.classList.remove('fullscreen');
      if(screenVal) screenVal.textContent=isSC?'手机模拟器 ›':'手機模擬器 ›';
    }
  }

  ['consist','summary','suggest','autoSummary','autoDetectTime','autoLorebook'].forEach(k=>{const t=document.getElementById('tog-'+k);if(t){if(settings[k])t.classList.add('active');else t.classList.remove('active');}});
  // 新增設置項的顯示
  const ctxVal=document.getElementById('context-val');if(ctxVal)ctxVal.textContent=settings.contextCount+(isSC?'条消息 ›':'條消息 ›');
  const autoSummFreqVal=document.getElementById('auto-summary-freq-val');if(autoSummFreqVal)autoSummFreqVal.textContent=(isSC?'每':'每')+settings.autoSummaryFrequency+(isSC?'条消息 ›':'條消息 ›');
  const autoLorebookFreqVal=document.getElementById('auto-lorebook-freq-val');if(autoLorebookFreqVal)autoLorebookFreqVal.textContent=(isSC?'每':'每')+settings.autoLorebookFrequency+(isSC?'条消息 ›':'條消息 ›');
  const maxVal=document.getElementById('max-tokens-val');if(maxVal)maxVal.textContent=settings.maxTokens+' ›';
  const typVal=document.getElementById('typing-speed-val');if(typVal)typVal.textContent=settings.typingSpeed===0?(isSC?'关闭 ›':'關閉 ›'):settings.typingSpeed+'ms ›';
  const keyVal=document.getElementById('send-key-val');if(keyVal)keyVal.textContent=settings.sendKey==='enter'?'Enter ›':'Ctrl+Enter ›';
  // 聊天背景顯示
  const bgVal=document.getElementById('chat-bg-val');
  if(bgVal){
    if(settings.chatBg==='custom'&&settings.chatBgImage)bgVal.textContent=isSC?'自定义 ›':'自定義 ›';
    else if(settings.chatBg==='none')bgVal.textContent=isSC?'默认 ›':'默認 ›';
    else bgVal.textContent=isSC?'渐变色 ›':'漸變色 ›';
  }
  // 字體大小和行間距
  const fontVal=document.getElementById('font-size-val');if(fontVal)fontVal.textContent=settings.fontSize+'px ›';
  const lhVal=document.getElementById('line-height-val');if(lhVal)lhVal.textContent=settings.lineHeight+'x ›';
  const psVal=document.getElementById('paragraph-spacing-val');if(psVal)psVal.textContent=settings.paragraphSpacing+' ›';
  // 應用字體和行高到 CSS 變量
  document.documentElement.style.setProperty('--font-size', settings.fontSize + 'px');
  document.documentElement.style.setProperty('--line-height', settings.lineHeight);
  document.documentElement.style.setProperty('--paragraph-spacing', settings.paragraphSpacing);
  // AI 參數顯示
  const aiParamsVal=document.getElementById('ai-params-val');if(aiParamsVal)aiParamsVal.textContent=`T:${settings.temperature} ›`;
  // 模板變量顯示
  const templateVal=document.getElementById('template-vars-val');if(templateVal)templateVal.textContent=settings.playerName?settings.playerName+' ›':(isSC?'设置 ›':'設置 ›');
  // 簡繁轉換顯示
  const cnVal=document.getElementById('cn-convert-val');
  if(cnVal){
    if(settings.uiLanguage==='sc')cnVal.textContent='简体 ›';
    else cnVal.textContent='繁體 ›';
  }
  // 流式響應顯示
  const streamVal=document.getElementById('streaming-val');if(streamVal)streamVal.textContent=settings.enableStreaming?(isSC?'已开启 ›':'已開啟 ›'):(isSC?'已关闭 ›':'已關閉 ›');
  // 智能角色選擇顯示
  const charSelVal=document.getElementById('char-selection-val');if(charSelVal)charSelVal.textContent=settings.smartCharacterSelection?(isSC?'已开启 ›':'已開啟 ›'):(isSC?'已关闭 ›':'已關閉 ›');
}
function toggleTheme(){settings.theme=settings.theme==='dark'?'light':'dark';saveSetting('theme',settings.theme);applySettings();toast(T('主題已切換'));}
function toggleScreen(){settings.screen=settings.screen==='phone'?'fullscreen':'phone';saveSetting('screen',settings.screen);applySettings();}
function toggleSet(k){settings[k]=!settings[k];saveSetting(k,settings[k]);applySettings();}
function toggleSendKey(){settings.sendKey=settings.sendKey==='enter'?'ctrl+enter':'enter';saveSetting('sendKey',settings.sendKey);applySettings();toast(T('發送快捷鍵已切換'));}

// 字體大小設置
function showFontSettings(){
  showModal('font-size-modal');
  updateFontOptions();
  document.getElementById('font-preview').style.fontSize = settings.fontSize + 'px';
}
function updateFontOptions(){
  document.querySelectorAll('#font-size-modal .font-option').forEach(btn=>{
    const size = parseInt(btn.dataset.size);
    if(size === settings.fontSize) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function selectFontSize(size){
  settings.fontSize = size;
  saveSetting('fontSize', size);
  applySettings();
  updateFontOptions();
  document.getElementById('font-preview').style.fontSize = size + 'px';
  toast('字體大小已更改為 ' + size + 'px');
}

// 行間距設置
function showLineHeightSettings(){
  showModal('line-height-modal');
  updateLineHeightOptions();
  document.getElementById('line-height-preview').style.lineHeight = settings.lineHeight;
}
function updateLineHeightOptions(){
  document.querySelectorAll('#line-height-modal .font-option').forEach(btn=>{
    const lh = parseFloat(btn.dataset.lh);
    if(lh === settings.lineHeight) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function selectLineHeight(lh){
  settings.lineHeight = lh;
  saveSetting('lineHeight', lh);
  applySettings();
  updateLineHeightOptions();
  document.getElementById('line-height-preview').style.lineHeight = lh;
  toast('行間距已更改為 ' + lh + 'x');
}

// 段落間距設置
function showParagraphSpacingSettings(){
  showModal('paragraph-spacing-modal');
  updateParagraphSpacingOptions();
  const preview = document.getElementById('paragraph-spacing-preview');
  if(preview){
    preview.querySelectorAll('p').forEach(p => {
      p.style.marginBottom = settings.paragraphSpacing;
    });
  }
}
function updateParagraphSpacingOptions(){
  document.querySelectorAll('#paragraph-spacing-modal .font-option').forEach(btn=>{
    const ps = btn.dataset.ps + 'em';
    if(ps === settings.paragraphSpacing) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function selectParagraphSpacing(ps){
  settings.paragraphSpacing = ps;
  saveSetting('paragraphSpacing', ps);
  applySettings();
  updateParagraphSpacingOptions();
  const preview = document.getElementById('paragraph-spacing-preview');
  if(preview){
    preview.querySelectorAll('p').forEach(p => {
      p.style.marginBottom = ps;
    });
  }
  toast('段落間距已更改為 ' + ps);
}

// 自動摘要頻率設置
function showAutoSummaryFrequencySettings(){
  showModal('auto-summary-freq-modal');
  updateAutoSummaryFrequencyOptions();
}
function updateAutoSummaryFrequencyOptions(){
  document.querySelectorAll('#auto-summary-freq-modal .font-option').forEach(btn=>{
    const freq = parseInt(btn.dataset.freq);
    if(freq === settings.autoSummaryFrequency) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function selectAutoSummaryFrequency(freq){
  settings.autoSummaryFrequency = freq;
  saveSetting('autoSummaryFrequency', freq);
  applySettings();
  updateAutoSummaryFrequencyOptions();
  toast('摘要生成頻率已更改為每 ' + freq + ' 條消息');
}

// AI自動提取Lorebook頻率設置
function showAutoLorebookFrequencySettings(){
  showModal('auto-lorebook-freq-modal');
  updateAutoLorebookFrequencyOptions();
}
function updateAutoLorebookFrequencyOptions(){
  document.querySelectorAll('#auto-lorebook-freq-modal .font-option').forEach(btn=>{
    const freq = parseInt(btn.dataset.freq);
    if(freq === settings.autoLorebookFrequency) btn.classList.add('active');
    else btn.classList.remove('active');
  });
}
function selectAutoLorebookFrequency(freq){
  settings.autoLorebookFrequency = freq;
  saveSetting('autoLorebookFrequency', freq);
  applySettings();
  updateAutoLorebookFrequencyOptions();
  toast('Lorebook提取頻率已更改為每 ' + freq + ' 條消息');
}

// ============ AI 參數設置 ============
function showAIParamsSettings(){
  showModal('ai-params-modal');
  // 更新滑塊值
  document.getElementById('temp-slider').value = settings.temperature * 100;
  document.getElementById('temp-value').textContent = settings.temperature.toFixed(1);
  document.getElementById('topp-slider').value = settings.topP * 100;
  document.getElementById('topp-value').textContent = settings.topP.toFixed(1);
}

function updateAIParam(param, value){
  value = parseFloat(value);
  settings[param] = value;
  saveSetting(param, value);
  
  // 更新顯示
  switch(param){
    case 'temperature':
      document.getElementById('temp-value').textContent = value.toFixed(1);
      break;
    case 'topP':
      document.getElementById('topp-value').textContent = value.toFixed(1);
      break;
  }
  applySettings();
}

function applyAIPreset(preset){
  const presets = {
    creative: { temperature: 1.0, topP: 0.95 },
    balanced: { temperature: 0.8, topP: 0.9 },
    precise: { temperature: 0.5, topP: 0.8 },
    wild: { temperature: 1.5, topP: 1.0 }
  };
  
  const p = presets[preset];
  if(!p) return;
  
  settings.temperature = p.temperature;
  settings.topP = p.topP;
  
  saveSetting('temperature', p.temperature);
  saveSetting('topP', p.topP);
  
  // 更新 UI
  showAIParamsSettings();
  applySettings();
  
  const names = { creative: '創意寫作', balanced: '平衡模式', precise: '精準敘事', wild: '天馬行空' };
  toast(`已套用「${names[preset]}」預設`);
}

// 全局默認 AI 參數設置（別名）
function showDefaultAIParams(){
  showAIParamsSettings();
}

// ============ 故事級別 AI 參數設置 ============
let storyAIParamsTemp = null; // 臨時存儲編輯中的參數

function showStoryAIParams(){
  if(!story){toast(T('請先打開一個故事'),'warning');return;}
  closeAll();
  
  // 讀取故事的 AI 參數
  const hasCustom = story.aiParams && story.aiParams.useCustom;
  const params = story.aiParams || {
    useCustom: false,
    temperature: settings.temperature,
    topP: settings.topP,
    frequencyPenalty: settings.frequencyPenalty,
    presencePenalty: settings.presencePenalty
  };
  
  storyAIParamsTemp = {...params};
  
  // 設置 checkbox
  document.getElementById('story-ai-use-custom').checked = hasCustom;
  toggleStoryAICustom(hasCustom);
  
  // 設置滑塊值
  document.getElementById('story-temp-slider').value = params.temperature * 100;
  document.getElementById('story-temp-value').textContent = params.temperature.toFixed(1);
  document.getElementById('story-topp-slider').value = params.topP * 100;
  document.getElementById('story-topp-value').textContent = params.topP.toFixed(1);
  
  // 更新當前生效參數顯示
  updateEffectiveParamsDisplay();
  
  showModal('story-ai-params-modal');
}

function toggleStoryAICustom(checked){
  const container = document.getElementById('story-ai-params-container');
  if(checked){
    container.style.opacity = '1';
    container.style.pointerEvents = 'auto';
    storyAIParamsTemp.useCustom = true;
  } else {
    container.style.opacity = '0.5';
    container.style.pointerEvents = 'none';
    storyAIParamsTemp.useCustom = false;
  }
  updateEffectiveParamsDisplay();
}

function updateStoryAIParam(param, value){
  value = parseFloat(value);
  storyAIParamsTemp[param] = value;
  
  // 更新顯示
  switch(param){
    case 'temperature':
      document.getElementById('story-temp-value').textContent = value.toFixed(1);
      break;
    case 'topP':
      document.getElementById('story-topp-value').textContent = value.toFixed(1);
      break;
  }
  updateEffectiveParamsDisplay();
}

function applyStoryAIPreset(preset){
  const presets = {
    creative: { temperature: 1.0, topP: 0.95 },
    balanced: { temperature: 0.8, topP: 0.9 },
    precise: { temperature: 0.5, topP: 0.8 },
    wild: { temperature: 1.5, topP: 1.0 }
  };
  
  const p = presets[preset];
  if(!p) return;
  
  storyAIParamsTemp.temperature = p.temperature;
  storyAIParamsTemp.topP = p.topP;
  
  // 更新滑塊
  document.getElementById('story-temp-slider').value = p.temperature * 100;
  document.getElementById('story-temp-value').textContent = p.temperature.toFixed(1);
  document.getElementById('story-topp-slider').value = p.topP * 100;
  document.getElementById('story-topp-value').textContent = p.topP.toFixed(1);
  
  updateEffectiveParamsDisplay();
  
  const names = { creative: '創意寫作', balanced: '平衡模式', precise: '精準敘事', wild: '天馬行空' };
  toast(`已套用「${names[preset]}」預設`);
}

async function saveStoryAIParams(){
  if(!story) return;
  
  story.aiParams = {
    useCustom: storyAIParamsTemp.useCustom,
    temperature: storyAIParamsTemp.temperature,
    topP: storyAIParamsTemp.topP,
    frequencyPenalty: storyAIParamsTemp.frequencyPenalty,
    presencePenalty: storyAIParamsTemp.presencePenalty
  };
  story.updatedAt = Date.now();
  
  await db.stories.put(story);
  closeModal('story-ai-params-modal');

  if(story.aiParams.useCustom){
    toast(`已保存本故事的 AI 參數 (T:${story.aiParams.temperature})`,'success');
  } else {
    toast(T('已設為使用全局默認參數'),'success');
  }

  // 自動同步到雲端
  autoSyncToCloud();
}

function updateEffectiveParamsDisplay(){
  const el = document.getElementById('story-ai-effective-params');
  if(!el) return;
  
  let params;
  let source;
  
  if(storyAIParamsTemp && storyAIParamsTemp.useCustom){
    params = storyAIParamsTemp;
    source = '本故事自定義';
  } else {
    params = settings;
    source = '全局默認值';
  }
  
  el.innerHTML = `
    <div style="margin-bottom:4px">來源：<span style="color:var(--primary)">${source}</span></div>
    <div>Temperature: ${params.temperature.toFixed(1)} | Top P: ${params.topP.toFixed(1)}</div>
  `;
}

// 獲取當前應該使用的 AI 參數（優先故事級別，其次全局默認）
function getAIParams(){
  if(story && story.aiParams && story.aiParams.useCustom){
    return {
      temperature: story.aiParams.temperature,
      topP: story.aiParams.topP,
      frequencyPenalty: story.aiParams.frequencyPenalty,
      presencePenalty: story.aiParams.presencePenalty
    };
  }
  return {
    temperature: settings.temperature || 0.8,
    topP: settings.topP || 0.9,
    frequencyPenalty: settings.frequencyPenalty || 0.3,
    presencePenalty: settings.presencePenalty || 0.1
  };
}

// ============ 模板變量設置 ============
function showTemplateVarsSettings(){
  showModal('template-vars-modal');
  document.getElementById('var-player-name').value = settings.playerName || '';
  document.getElementById('var-location').value = settings.currentLocation || '';
}

function saveTemplateVars(){
  const playerName = document.getElementById('var-player-name').value.trim();
  const location = document.getElementById('var-location').value.trim();
  
  settings.playerName = playerName;
  settings.currentLocation = location;
  
  saveSetting('playerName', playerName);
  saveSetting('currentLocation', location);
  
  closeModal('template-vars-modal');
  applySettings();
  toast(T('模板變量已保存'), 'success');
}

// 替換模板變量
function replaceTemplateVars(text){
  if(!text) return text;
  
  // {{user}} - 玩家稱呼
  text = text.replace(/\{\{user\}\}/gi, settings.playerName || '你');
  
  // {{location}} - 當前地點
  text = text.replace(/\{\{location\}\}/gi, settings.currentLocation || '此處');
  
  // {{time}} - 故事時間（添加story存在性檢查）
  const storyTime = story && story.storyTime ? story.storyTime : '';
  text = text.replace(/\{\{time\}\}/gi, storyTime || '當前');
  
  // {{date}} - 現實日期
  const today = new Date();
  const dateStr = `${today.getFullYear()}年${today.getMonth()+1}月${today.getDate()}日`;
  text = text.replace(/\{\{date\}\}/gi, dateStr);
  
  // {{char:角色名}} - 指定角色的信息（異步，這裡只做簡單替換）
  text = text.replace(/\{\{char:([^}]+)\}\}/gi, (match, charName) => {
    return `【${charName}】`;
  });
  
  return text;
}

// 圖片上傳相關
let imageUploadTarget = null; // 'storyCover' | 'charAvatar' | 'chatBg' | {type: 'charAvatar', charId: xxx}

// 壓縮圖片
async function compressImage(file, maxWidth = 400, quality = 0.8) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('圖片加載超時'));
    }, 30000); // 30秒超时

    const reader = new FileReader();
    reader.onload = (e) => {
      if(!e.target.result) {
        clearTimeout(timeout);
        reject(new Error('無效的圖片數據'));
        return;
      }
      const img = new Image();
      img.onload = () => {
        clearTimeout(timeout);
        try {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }

          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          const dataUrl = canvas.toDataURL('image/jpeg', quality);
          resolve(dataUrl);
        } catch(e) {
          reject(e);
        }
      };
      img.onerror = (err) => {
        clearTimeout(timeout);
        reject(err || new Error('圖片加載失敗'));
      };
      img.src = e.target.result;
    };
    reader.onerror = (err) => {
      clearTimeout(timeout);
      reject(err || new Error('文件讀取失敗'));
    };
    reader.readAsDataURL(file);
  });
}

// 處理圖片上傳
async function handleImageUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    showLoading('處理圖片中...');
    const maxWidth = imageUploadTarget === 'chatBg' ? 1920 : 400;
    const dataUrl = await compressImage(file, maxWidth, 0.85);
    
    // 從主頁更換封面（帶storyId的對象）
    if (typeof imageUploadTarget === 'object' && imageUploadTarget.type === 'storyCover') {
      const targetStoryId = imageUploadTarget.storyId;
      await db.stories.update(targetStoryId, { coverImage: dataUrl });
      // 如果當前打開的故事就是這個故事，也更新全局變量
      if (story && story.id === targetStoryId) {
        story.coverImage = dataUrl;
      }
      await renderStories();
      toast(T('封面已更新'), 'success');
    } else if (imageUploadTarget === 'storyCover' && story) {
      // 從故事內部更換封面
      await db.stories.update(story.id, { coverImage: dataUrl });
      story.coverImage = dataUrl;
      await renderStories();
      toast(T('封面已更新'), 'success');
    } else if (imageUploadTarget === 'chatBg') {
      settings.chatBg = 'custom';
      settings.chatBgImage = dataUrl;
      await saveSetting('chatBg', 'custom');
      await saveSetting('chatBgImage', dataUrl);
      applyChatBg();
      closeModal('chat-bg-modal');
      toast(T('背景已更新'), 'success');
    } else if (typeof imageUploadTarget === 'object' && imageUploadTarget.type === 'charAvatar') {
      const charId = imageUploadTarget.charId;
      await db.characters.update(charId, { avatarImage: dataUrl, updatedAt: Date.now() });
      renderCharacters();
      toast(T('頭像已更新'), 'success');
    } else if (typeof imageUploadTarget === 'object' && imageUploadTarget.type === 'charAvatarEdit') {
      // 在角色編輯界面上傳圖片（暫存，保存時才寫入數據庫）
      tempCharAvatarImage = dataUrl;
      document.getElementById('char-avatar-preview').style.display = 'block';
      document.getElementById('char-avatar-img').src = dataUrl;
      toast(T('圖片已選擇，保存角色後生效'), 'success');
    }
    
    hideLoading();
  } catch (e) {
    hideLoading();
    toast('圖片處理失敗: ' + e.message, 'error');
  }
  
  // 清空 input
  event.target.value = '';
}

// 上傳故事封面
function uploadStoryCover() {
  if (!story) return toast(T('請先選擇故事'));
  imageUploadTarget = 'storyCover';
  document.getElementById('image-upload').click();
}

// 上傳角色頭像
function uploadCharAvatar(charId) {
  imageUploadTarget = { type: 'charAvatar', charId };
  document.getElementById('image-upload').click();
}

// 在角色編輯界面上傳圖片
let tempCharAvatarImage = null;
function uploadCharAvatarInEdit() {
  imageUploadTarget = { type: 'charAvatarEdit' };
  document.getElementById('image-upload').click();
}

// 清除角色編輯界面的圖片
function clearCharAvatarImage() {
  tempCharAvatarImage = null;
  document.getElementById('char-avatar-preview').style.display = 'none';
  document.getElementById('char-avatar-img').src = '';
}

// 聊天背景設置
function setChatBackground() {
  // 更新選中狀態
  document.querySelectorAll('.bg-option').forEach(el => {
    el.style.borderColor = el.dataset.bg === settings.chatBg ? 'var(--primary)' : 'var(--divider)';
  });
  // 顯示自定義背景預覽
  const preview = document.getElementById('current-bg-preview');
  const previewImg = document.getElementById('bg-preview-img');
  if (settings.chatBg === 'custom' && settings.chatBgImage) {
    preview.style.display = 'block';
    previewImg.style.backgroundImage = `url(${settings.chatBgImage})`;
  } else {
    preview.style.display = 'none';
  }
  showModal('chat-bg-modal');
}

function selectBg(bg) {
  if (bg === 'custom') return; // 由 uploadChatBg 處理
  settings.chatBg = bg;
  saveSetting('chatBg', bg);
  applyChatBg();
  // 更新選中狀態
  document.querySelectorAll('.bg-option').forEach(el => {
    el.style.borderColor = el.dataset.bg === bg ? 'var(--primary)' : 'var(--divider)';
  });
  applySettings();
  toast(T('背景已更新'), 'success');
}

function uploadChatBg() {
  imageUploadTarget = 'chatBg';
  document.getElementById('image-upload').click();
}

function clearChatBg() {
  settings.chatBg = 'none';
  settings.chatBgImage = '';
  saveSetting('chatBg', 'none');
  saveSetting('chatBgImage', '');
  applyChatBg();
  document.getElementById('current-bg-preview').style.display = 'none';
  document.querySelectorAll('.bg-option').forEach(el => {
    el.style.borderColor = el.dataset.bg === 'none' ? 'var(--primary)' : 'var(--divider)';
  });
  applySettings();
  toast(T('已恢復默認背景'), 'success');
}

function applyChatBg() {
  const content = document.getElementById('content-area');
  if (!content) return;
  
  content.classList.remove('has-bg');
  content.style.backgroundImage = '';
  content.style.background = '';
  
  if (settings.chatBg === 'custom' && settings.chatBgImage) {
    content.classList.add('has-bg');
    content.style.backgroundImage = `url(${settings.chatBgImage})`;
  } else if (settings.chatBg === 'gradient1') {
    content.style.background = 'linear-gradient(135deg, #1a1a2e, #16213e)';
  } else if (settings.chatBg === 'gradient2') {
    content.style.background = 'linear-gradient(135deg, #0f0f1a, #1e1e32)';
  } else if (settings.chatBg === 'gradient3') {
    content.style.background = 'linear-gradient(135deg, #1a0a0a, #2a1515)';
  } else if (settings.chatBg === 'gradient4') {
    content.style.background = 'linear-gradient(135deg, #0a1a0a, #152a15)';
  }
}

// 處理輸入框按鍵事件
function handleInputKey(event){
  if(event.key==='Enter'){
    if(settings.sendKey==='ctrl+enter'){
      if(event.ctrlKey||event.metaKey){
        event.preventDefault();
        send();
      }
    }else{
      // 默認 Enter 發送
      if(!event.ctrlKey&&!event.metaKey&&!event.shiftKey){
        event.preventDefault();
        send();
      }
    }
  }
}

// 上下文設置
function showContextSettings(){
  document.getElementById('context-count').value=settings.contextCount||20;
  document.getElementById('smart-context-enabled').checked=settings.smartContext||false;
  document.getElementById('smart-context-recent').value=settings.smartContextRecent||10;
  document.getElementById('smart-context-min-score').value=settings.smartContextMinScore||30;

  // 根據智能模式顯示/隱藏選項
  const options = document.getElementById('smart-context-options');
  if(options){
    options.style.display = settings.smartContext ? 'block' : 'none';
  }

  // 監聽checkbox變化
  const checkbox = document.getElementById('smart-context-enabled');
  if(checkbox){
    checkbox.onchange = function(){
      if(options){
        options.style.display = this.checked ? 'block' : 'none';
      }
    };
  }

  showModal('context-modal');
}

function saveContextSettings(){
  const input = document.getElementById('context-count');
  const val = input ? safeParseInt(input.value, 20) : 20;
  settings.contextCount=Math.max(1,Math.min(500,val));
  saveSetting('contextCount',settings.contextCount);

  // 保存智能上下文設置
  const smartEnabled = document.getElementById('smart-context-enabled');
  if(smartEnabled){
    settings.smartContext = smartEnabled.checked;
    saveSetting('smartContext', settings.smartContext);
  }

  const smartRecent = document.getElementById('smart-context-recent');
  if(smartRecent){
    settings.smartContextRecent = Math.max(5, Math.min(50, safeParseInt(smartRecent.value, 10)));
    saveSetting('smartContextRecent', settings.smartContextRecent);
  }

  const smartMinScore = document.getElementById('smart-context-min-score');
  if(smartMinScore){
    settings.smartContextMinScore = Math.max(0, Math.min(100, safeParseInt(smartMinScore.value, 30)));
    saveSetting('smartContextMinScore', settings.smartContextMinScore);
  }

  applySettings();
  closeModal('context-modal');

  const mode = settings.smartContext ? '智能模式' : '傳統模式';
  toast(T(`上下文設置已保存（${mode}）`));
}

// 智能角色選擇設置
function showCharacterSelectionSettings(){
  document.getElementById('smart-character-enabled').checked = settings.smartCharacterSelection || false;
  document.getElementById('character-recent-messages').value = settings.characterRecentMessages || 20;
  document.getElementById('always-include-main-chars').checked = settings.alwaysIncludeMainCharacters !== false;

  // 根據智能模式顯示/隱藏選項
  const options = document.getElementById('smart-character-options');
  if(options){
    options.style.display = settings.smartCharacterSelection ? 'block' : 'none';
  }

  // 監聽checkbox變化
  const checkbox = document.getElementById('smart-character-enabled');
  if(checkbox){
    checkbox.onchange = function(){
      if(options){
        options.style.display = this.checked ? 'block' : 'none';
      }
    };
  }

  showModal('character-selection-modal');
}

function saveCharacterSelectionSettings(){
  // 保存啟用狀態
  const smartEnabled = document.getElementById('smart-character-enabled');
  if(smartEnabled){
    settings.smartCharacterSelection = smartEnabled.checked;
    saveSetting('smartCharacterSelection', settings.smartCharacterSelection);
  }

  // 保存檢查消息數量
  const recentMessages = document.getElementById('character-recent-messages');
  if(recentMessages){
    settings.characterRecentMessages = Math.max(5, Math.min(100, safeParseInt(recentMessages.value, 20)));
    saveSetting('characterRecentMessages', settings.characterRecentMessages);
  }

  // 保存是否總是包含主要角色
  const includeMain = document.getElementById('always-include-main-chars');
  if(includeMain){
    settings.alwaysIncludeMainCharacters = includeMain.checked;
    saveSetting('alwaysIncludeMainCharacters', settings.alwaysIncludeMainCharacters);
  }

  applySettings();
  closeModal('character-selection-modal');

  const mode = settings.smartCharacterSelection ? '智能模式' : '全部發送';
  toast(T(`角色選擇設置已保存（${mode}）`));
}

// 最大 Token 設置
function showMaxTokensSettings(){
  const input = document.getElementById('max-tokens-input');
  if(input) input.value = settings.maxTokens||4096;
  showModal('max-tokens-modal');
}
function saveMaxTokensSettings(){
  const input = document.getElementById('max-tokens-input');
  const val = input ? safeParseInt(input.value, 4096) : 4096;
  settings.maxTokens=Math.max(100,val);
  saveSetting('maxTokens',settings.maxTokens);
  applySettings();
  closeModal('max-tokens-modal');
  toast(T('最大生成長度已保存'));
}

// 打字機效果設置
function showTypingSpeedSettings(){
  document.getElementById('typing-speed-select').value=settings.typingSpeed||30;
  showModal('typing-modal');
}
function saveTypingSpeedSettings(){
  settings.typingSpeed=parseInt(document.getElementById('typing-speed-select').value);
  saveSetting('typingSpeed',settings.typingSpeed);
  applySettings();
  closeModal('typing-modal');
  toast(T('打字機效果已保存'));
}

// 流式響應設置
function showStreamingSettings(){
  const toggle=document.getElementById('toggle-streaming');
  const text=document.getElementById('toggle-streaming-text');
  const options=document.getElementById('streaming-advanced-options');
  if(settings.enableStreaming){
    toggle.classList.add('active');
    text.textContent='已開啟';
    options.style.display='block';
  }else{
    toggle.classList.remove('active');
    text.textContent='已關閉';
    options.style.display='none';
  }
  document.getElementById('streaming-chunk-delay-select').value=settings.streamingChunkDelay||20;
  showModal('streaming-modal');
}
function toggleStreamingEnabled(){
  const toggle=document.getElementById('toggle-streaming');
  const text=document.getElementById('toggle-streaming-text');
  const options=document.getElementById('streaming-advanced-options');
  const enabled=toggle.classList.contains('active');
  if(enabled){
    toggle.classList.remove('active');
    text.textContent='已關閉';
    options.style.display='none';
  }else{
    toggle.classList.add('active');
    text.textContent='已開啟';
    options.style.display='block';
  }
}
function saveStreamingSettings(){
  const enabled=document.getElementById('toggle-streaming').classList.contains('active');
  settings.enableStreaming=enabled;
  settings.streamingChunkDelay=parseInt(document.getElementById('streaming-chunk-delay-select').value)||20;
  saveSetting('enableStreaming',settings.enableStreaming);
  saveSetting('streamingChunkDelay',settings.streamingChunkDelay);
  applySettings();
  closeModal('streaming-modal');
  toast(T('流式響應設置已保存'),'success');
}

// 時間
function updateTime(){
  const n=new Date();
  const timeEl=document.getElementById('status-time');
  if(timeEl)timeEl.textContent=`${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}`;
}

// 導航
function goTo(id){
  const cur=document.querySelector('.view.active'),tar=document.getElementById(id);
  if(!tar||cur===tar)return;
  hist.push(id);
  cur.classList.remove('active');cur.classList.add('out');
  tar.classList.add('active');
  setTimeout(()=>cur.classList.remove('out'),300);
  // 載入數據
  if(id==='view-lore')renderLore();
  else if(id==='view-timeline')renderTimeline();
  else if(id==='view-foreshadow')renderForeshadow();
  else if(id==='view-saves')renderSaves();
  else if(id==='view-api')renderApi();
  else if(id==='view-chapters')renderChapters();
  else if(id==='view-bookmarks')renderBookmarks();
  else if(id==='view-inventory')renderInventory();
  else if(id==='view-schedule')renderSchedule();
  else if(id==='view-branches')renderBranches();
  else if(id==='view-characters')renderCharacters(); // v7
  else if(id==='view-lorebook')renderLorebook(); // v13
  else if(id==='view-search')initContentSearch(); // v17 修復
}
function goBack(){
  if(hist.length>1){
    hist.pop();
    const prev=hist[hist.length-1];
    const cur=document.querySelector('.view.active'),tar=document.getElementById(prev);
    cur.classList.remove('active');tar.classList.add('active');
  }
}
function switchTab(t){
  document.querySelectorAll('.tab-bar .tab-item').forEach(x=>x.classList.remove('active'));
  if(t==='stories'){goTo('view-stories');document.querySelectorAll('.tab-bar')[0]?.querySelector('.tab-item')?.classList.add('active');}
  else if(t==='instructions'){goTo('view-instructions');}
  else if(t==='settings'){goTo('view-settings');}
}

// 故事列表
async function renderStories(){
  const c=document.getElementById('story-list');
  let list=await db.stories.orderBy('updatedAt').reverse().toArray();
  list.sort((a,b)=>(a.isPinned&&!b.isPinned)?-1:(!a.isPinned&&b.isPinned)?1:0);
  if(!list.length){c.innerHTML=`<div class="empty"><div class="empty-icon">📚</div><div class="empty-title">${T('還沒有故事')}</div><div class="empty-desc">${T('點擊右上角 ➕ 創建你的第一個互動故事')}</div><button class="empty-btn" onclick="createStory()">${T('創建故事')}</button></div>`;return;}
  c.innerHTML=list.map(s=>{
    const t=timeAgo(s.updatedAt),stats=s.statistics||{totalChars:0},tags=(s.tags||[]).map(x=>`<span class="tag">${esc(x)}</span>`).join('');
    // 支持封面圖片
    const coverEmoji = esc(s.cover) || '📖';
    const coverContent = s.coverImage 
      ? `<img src="${s.coverImage}" alt="封面" onerror="this.outerHTML='<span class=cover-emoji>${coverEmoji}</span>'">` 
      : `<span class="cover-emoji">${coverEmoji}</span>`;
    return `<div class="card ${s.isPinned?'pinned':''}" onclick="openStory('${escAttr(s.id)}')"><div class="card-cover">${coverContent}</div><div class="card-info"><div class="card-header"><span class="card-title">${esc(s.title)}</span><span class="card-time">${t}</span></div><div class="card-preview">${esc(s.preview||'開始你的冒險...')}</div><div class="card-meta">${s.instructionName?`<span class="card-instruction">📜 ${esc(s.instructionName)}</span>`:''}<span class="card-stats">📊 ${fmtNum(stats.totalChars)}字</span></div>${tags?`<div class="card-tags">${tags}</div>`:''}</div><div class="card-menu-btn" onclick="event.stopPropagation();showStoryMenu('${escAttr(s.id)}')">⋯</div></div>`;
  }).join('');
}
function filterStories(){const q=document.getElementById('story-search').value.toLowerCase();document.querySelectorAll('#story-list .card').forEach(c=>{const t=c.querySelector('.card-title')?.textContent.toLowerCase()||'';c.style.display=t.includes(q)?'':'none';});}

// v19: 經營模式相關
let selectedStoryMode = 'normal';

function selectStoryMode(mode){
  selectedStoryMode = mode;
  document.getElementById('mode-normal').classList.toggle('active', mode === 'normal');
  document.getElementById('mode-simulation').classList.toggle('active', mode === 'simulation');
  document.getElementById('sim-mode-options').style.display = mode === 'simulation' ? 'block' : 'none';
}

function addSimResource(){
  const container = document.getElementById('new-sim-resources');
  const div = document.createElement('div');
  div.style.cssText = 'display:flex;gap:6px;align-items:center';
  div.innerHTML = `
    <input type="text" class="form-input" style="width:60px" placeholder="📊" maxlength="2">
    <input type="text" class="form-input" style="flex:1" placeholder="名稱">
    <input type="number" class="form-input" style="width:80px" placeholder="數值" value="0">
    <button onclick="removeSimResource(this)" style="background:none;border:none;color:var(--error);cursor:pointer">✕</button>
  `;
  container.appendChild(div);
}

function removeSimResource(btn){
  btn.parentElement.remove();
}

async function createStory(){
  const insts=await db.instructions.toArray();
  const sel=document.getElementById('new-inst');
  sel.innerHTML='<option value="">不綁定指令</option>'+insts.map(i=>`<option value="${i.id}">${esc(i.name)}</option>`).join('');
  document.getElementById('new-title').value='';
  document.getElementById('new-desc').value='';
  document.getElementById('new-tags').value='';
  // v19: 重置模式選擇
  selectedStoryMode = 'normal';
  selectStoryMode('normal');
  // 重置初始資源
  document.getElementById('new-sim-resources').innerHTML = `
    <div style="display:flex;gap:6px;align-items:center">
      <input type="text" class="form-input" style="width:60px" placeholder="💰" maxlength="2" value="💰">
      <input type="text" class="form-input" style="flex:1" placeholder="名稱" value="金幣">
      <input type="number" class="form-input" style="width:80px" placeholder="數值" value="10000">
      <button onclick="removeSimResource(this)" style="background:none;border:none;color:var(--error);cursor:pointer">✕</button>
    </div>
  `;
  showModal('new-story-modal');
}
async function saveNewStory(){
  const title=document.getElementById('new-title').value.trim();
  if(!title){toast(T('請輸入故事標題'),'warning');return;}
  const desc=document.getElementById('new-desc').value.trim();
  const tagsStr=document.getElementById('new-tags').value.trim();
  const tags=tagsStr?tagsStr.split(/\s+/):[];
  const instId=document.getElementById('new-inst').value;
  const storyId=crypto.randomUUID(),branchId='main_'+crypto.randomUUID(),now=Date.now();
  const s={id:storyId,title,description:desc,cover:'📖',tags,currentBranchId:branchId,currentMessageId:null,storyTime:'',isPinned:false,preview:'',createdAt:now,updatedAt:now,statistics:{totalChars:0,totalMessages:0},draft:'',autoSave:{enabled:true,interval:20,maxCount:5}};
  
  // v19: 保存模式和資源
  s.mode = selectedStoryMode;
  if(selectedStoryMode === 'simulation'){
    s.simDay = 1;
    s.simResources = [];
    const rows = document.querySelectorAll('#new-sim-resources > div');
    rows.forEach(row => {
      const inputs = row.querySelectorAll('input');
      if(inputs.length >= 3){
        const icon = inputs[0].value.trim() || '📊';
        const name = inputs[1].value.trim();
        const value = parseFloat(inputs[2].value) || 0;
        if(name) s.simResources.push({icon, name, value, prevValue: value});
      }
    });
  }
  
  if(instId){const inst=await db.instructions.get(instId);if(inst){s.instructionName=inst.name;await db.storyInstructions.put({storyId,instructionId:instId,order:0});}}
  await db.branches.put({id:branchId,storyId,name:'主線',parentBranchId:null,createdAt:now});
  await db.stories.put(s);
  closeModal('new-story-modal');
  toast(T('故事創建成功！'),'success');
  await renderStories();
  openStory(storyId);

  // 自動同步到雲端
  autoSyncToCloud();
}

async function openStory(id){
  // 防止竞态条件：记录当前正在加载的故事ID
  loadingStoryId = id;
  const currentLoadingId = id;

  showLoading('載入故事...');
  try{
    story=await db.stories.get(id);

    // 检查是否有新的加载请求，如果有则放弃当前加载
    if(loadingStoryId !== currentLoadingId){
      console.log('[OpenStory] 加載被取消，用戶已切換到其他故事');
      return;
    }

    if(!story){toast(T('故事不存在'),'error');hideLoading();loadingStoryId=null;return;}
    msgs=await db.messages.where('[storyId+branchId]').equals([id,story.currentBranchId]).sortBy('createdAt');

    // 再次检查竞态条件
    if(loadingStoryId !== currentLoadingId){
      console.log('[OpenStory] 加載被取消，用戶已切換到其他故事');
      return;
    }

    const titleEl = document.getElementById('reading-title');
    if(titleEl) titleEl.textContent=story.title;
    // 載入玩家狀態面板（用於消息中顯示玩家狀態卡片，必須在 renderMsgs 之前）
    currentPlayerPanel = await db.playerPanels.where('storyId').equals(story.id).first();

    renderMsgs();
    applyChatBg(); // 應用聊天背景
    // v19: 經營模式 UI 切換
    updateSimulationUI();
    // v22: 載入 Persona
    await initDefaultPersona();

    // ✨ 恢复草稿
    const input = document.getElementById('user-input');
    if(input && story.draft) {
      input.value = story.draft;
      toast('📝 已恢复上次编辑的内容', 'info');
    } else if(input) {
      input.value = ''; // 清空输入框
    }

    goTo('view-reading');
    hideLoading();
    loadingStoryId = null;

    // 更新一致性修復提示條
    updateConsistencyFixBanner();

    // v25: 如果是新故事（沒有消息），檢查是否有開場白
    if(msgs.length === 0){
      await checkGreetingAvailable();
    }
  }catch(e){
    console.error('[OpenStory] 載入失敗:', e);
    toast(T('載入失敗'),'error');
    hideLoading();
    loadingStoryId = null;
  }
}

// v25: 開場白系統
let selectedGreetingIndex = -1;
let availableGreetings = [];

async function checkGreetingAvailable(){
  if(!story) return;
  
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  availableGreetings = [];
  
  // 收集所有角色的開場白
  for(const char of chars){
    if(char.first_mes){
      availableGreetings.push({
        charId: char.id,
        charName: char.name,
        charAvatar: char.avatar || '👤',
        content: char.first_mes,
        isDefault: true
      });
    }
    
    // 替代開場白
    if(char.alternate_greetings && char.alternate_greetings.length > 0){
      char.alternate_greetings.forEach((greeting, idx) => {
        if(greeting.trim()){
          availableGreetings.push({
            charId: char.id,
            charName: char.name,
            charAvatar: char.avatar || '👤',
            content: greeting,
            isDefault: false,
            altIndex: idx + 1
          });
        }
      });
    }
  }
  
  if(availableGreetings.length > 0){
    showGreetingSelector();
  }
}

function showGreetingSelector(){
  const container = document.getElementById('greeting-select-content');
  selectedGreetingIndex = 0;
  
  let html = '';
  availableGreetings.forEach((g, idx) => {
    const isSelected = idx === 0 ? 'selected' : '';
    const badge = g.isDefault ? '默認' : `替代 ${g.altIndex}`;
    html += `
      <div class="greeting-option ${isSelected}" onclick="selectGreeting(${idx})" data-idx="${idx}">
        <div class="greeting-option-header">
          <span class="greeting-char-avatar">${g.charAvatar}</span>
          <span class="greeting-char-name">${esc(g.charName)}</span>
          <span class="greeting-badge">${badge}</span>
        </div>
        <div class="greeting-preview">${esc(g.content.slice(0, 150))}${g.content.length > 150 ? '...' : ''}</div>
      </div>
    `;
  });
  
  container.innerHTML = html;
  showModal('greeting-select-modal');
}

function selectGreeting(idx){
  selectedGreetingIndex = idx;
  document.querySelectorAll('.greeting-option').forEach((el, i) => {
    el.classList.toggle('selected', i === idx);
  });
}

async function confirmGreeting(){
  closeModal('greeting-select-modal');
  
  if(selectedGreetingIndex < 0 || selectedGreetingIndex >= availableGreetings.length) return;
  
  const greeting = availableGreetings[selectedGreetingIndex];
  
  // 創建AI消息
  const aiMsgId = crypto.randomUUID();
  const aiMsg = {
    id: aiMsgId,
    storyId: story.id,
    branchId: story.currentBranchId,
    role: 'assistant',
    content: greeting.content,
    createdAt: Date.now(),
    isGreeting: true  // 標記為開場白
  };
  
  await db.messages.put(aiMsg);
  msgs.push(aiMsg);
  renderMsgs();
  
  toast(T('已使用開場白'), 'success');
}

function skipGreeting(){
  // 用戶選擇不使用開場白，什麼都不做
  availableGreetings = [];
  selectedGreetingIndex = -1;
}

// v25: 角色關係系統
let charRelationships = []; // 當前編輯的角色關係
const RELATIONSHIP_TYPES = [
  { code: 'lover', label: '戀人', icon: '❤️', color: '#ff6b6b' },
  { code: 'ex', label: '前任', icon: '💔', color: '#ffa8a8' },
  { code: 'crush', label: '暗戀', icon: '💗', color: '#ffb3d9' },
  { code: 'spouse', label: '配偶', icon: '💍', color: '#ff4757' },
  { code: 'family', label: '家人', icon: '👨‍👩‍👧', color: '#4ecdc4' },
  { code: 'friend', label: '朋友', icon: '🤝', color: '#45b7d1' },
  { code: 'bestfriend', label: '摯友', icon: '👯', color: '#3498db' },
  { code: 'enemy', label: '敵人', icon: '⚔️', color: '#ff4757' },
  { code: 'rival', label: '對手', icon: '🔥', color: '#ff7f50' },
  { code: 'boss', label: '上司', icon: '👔', color: '#a55eea' },
  { code: 'subordinate', label: '下屬', icon: '👷', color: '#26de81' },
  { code: 'colleague', label: '同事', icon: '🏢', color: '#74b9ff' },
  { code: 'mentor', label: '導師', icon: '🎓', color: '#fed330' },
  { code: 'student', label: '學生', icon: '📚', color: '#20bf6b' },
  { code: 'master', label: '主人', icon: '👑', color: '#6c5ce7' },
  { code: 'servant', label: '僕人', icon: '🙇', color: '#81ecec' },
  { code: 'partner', label: '搭檔', icon: '🤜🤛', color: '#00cec9' },
  { code: 'custom', label: '自定義', icon: '✏️', color: '#9ca3af' }
];

function addCharRelationship(){
  charRelationships.push({
    id: crypto.randomUUID(),
    targetId: null,
    targetName: '',
    type: 'friend',
    label: '朋友',
    description: '',
    mutual: false
  });
  renderCharRelationships();
}

async function renderCharRelationships(){
  const container = document.getElementById('char-relationships-list');
  if(!container) return;
  
  // 獲取可選的角色列表（排除當前編輯的角色）
  const chars = await db.characters.where('storyId').equals(story?.id || 0).toArray();
  const otherChars = chars.filter(c => c.id !== editingCharacterId);
  
  const typeOptions = RELATIONSHIP_TYPES.map(t => 
    `<option value="${t.code}">${t.icon} ${t.label}</option>`
  ).join('');
  
  const charOptions = otherChars.map(c => 
    `<option value="${c.id}">${c.avatar || '👤'} ${c.name}</option>`
  ).join('');
  
  container.innerHTML = charRelationships.map((rel, idx) => `
    <div class="relationship-item">
      <button class="delete-btn" onclick="removeCharRelationship(${idx})">✕</button>
      <div class="relationship-row">
        <select class="form-input" onchange="updateRelTarget(${idx}, this.value)" style="flex:1.5">
          <option value="">選擇角色...</option>
          ${charOptions}
        </select>
        <select class="form-input" onchange="updateRelType(${idx}, this.value)">
          ${typeOptions}
        </select>
      </div>
      <div class="relationship-row">
        <input type="text" class="form-input" placeholder="關係描述（可選）" 
               value="${esc(rel.description || '')}"
               oninput="charRelationships[${idx}].description=this.value">
        <label style="display:flex;align-items:center;gap:4px;font-size:12px;white-space:nowrap">
          <input type="checkbox" ${rel.mutual ? 'checked' : ''} 
                 onchange="charRelationships[${idx}].mutual=this.checked">
          雙向
        </label>
      </div>
    </div>
  `).join('');
  
  // 設置已選中的值
  const selects = container.querySelectorAll('select');
  charRelationships.forEach((rel, idx) => {
    const targetSelect = selects[idx * 2];
    const typeSelect = selects[idx * 2 + 1];
    if(targetSelect && rel.targetId) targetSelect.value = rel.targetId;
    if(typeSelect) typeSelect.value = rel.type || 'friend';
  });
}

function updateRelTarget(idx, targetId){
  if(!targetId){
    charRelationships[idx].targetId = null;
    charRelationships[idx].targetName = '';
    return;
  }
  const parsedId = safeParseInt(targetId);
  if(parsedId === 0){
    console.error('[Relationship] 無效的目標ID:', targetId);
    return;
  }
  charRelationships[idx].targetId = parsedId;
  // 獲取角色名
  db.characters.get(parsedId).then(char => {
    if(char) charRelationships[idx].targetName = char.name;
  }).catch(err => {
    console.error('[Relationship] 獲取角色名失敗:', err);
  });
}

function updateRelType(idx, typeCode){
  const typeInfo = RELATIONSHIP_TYPES.find(t => t.code === typeCode);
  charRelationships[idx].type = typeCode;
  charRelationships[idx].label = typeInfo ? typeInfo.label : typeCode;
}

function removeCharRelationship(idx){
  charRelationships.splice(idx, 1);
  renderCharRelationships();
}

// v25: 表情立繪系統
let charExpressions = []; // 當前編輯的角色表情
let editingExpressionIndex = -1;

function addCharExpression(){
  document.getElementById('expr-file-input').click();
}

function handleExpressionUpload(event){
  const file = event.target.files[0];
  if(!file) return;
  
  if(!file.type.startsWith('image/')){
    toast(T('請選擇圖片文件'), 'warning');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = (e) => {
    const base64 = e.target.result;
    
    // 創建新表情
    const expr = {
      id: Date.now(),
      name: '表情 ' + (charExpressions.length + 1),
      image: base64,
      keywords: [],
      isDefault: charExpressions.length === 0  // 第一個表情默認
    };
    
    charExpressions.push(expr);
    renderCharExpressions();
    
    // 顯示編輯彈窗
    editingExpressionIndex = charExpressions.length - 1;
    showExpressionEditPopup();
  };
  
  reader.readAsDataURL(file);
  event.target.value = '';  // 重置input
}

function renderCharExpressions(){
  const container = document.getElementById('char-expressions-list');
  if(!container) return;
  
  if(charExpressions.length === 0){
    container.innerHTML = '<div style="grid-column:span 3;text-align:center;color:var(--text-tertiary);font-size:12px;padding:20px 0">暫無表情，點擊下方按鈕添加</div>';
    return;
  }
  
  container.innerHTML = charExpressions.map((expr, idx) => `
    <div class="expression-item ${expr.isDefault ? 'default' : ''}" onclick="editExpression(${idx})">
      ${expr.isDefault ? '<span class="expr-badge">默認</span>' : ''}
      <button class="expr-delete" onclick="event.stopPropagation();deleteExpression(${idx})">✕</button>
      <img class="expr-img" src="${expr.image}" alt="${esc(expr.name)}">
      <div class="expr-name">${esc(expr.name)}</div>
    </div>
  `).join('');
}

function editExpression(idx){
  editingExpressionIndex = idx;
  showExpressionEditPopup();
}

function showExpressionEditPopup(){
  if(editingExpressionIndex < 0 || editingExpressionIndex >= charExpressions.length) return;
  
  const expr = charExpressions[editingExpressionIndex];
  
  const html = `
    <div class="expression-edit-modal" id="expr-edit-popup">
      <div style="display:flex;gap:12px;align-items:flex-start">
        <img src="${expr.image}" style="width:80px;height:80px;border-radius:10px;object-fit:cover">
        <div style="flex:1">
          <div class="form-group" style="margin-bottom:10px">
            <label class="form-label" style="font-size:11px">表情名稱</label>
            <input type="text" class="form-input" id="expr-edit-name" value="${esc(expr.name)}" placeholder="如：開心、生氣、害羞...">
          </div>
          <div class="form-group" style="margin-bottom:10px">
            <label class="form-label" style="font-size:11px">觸發關鍵詞（逗號分隔）</label>
            <input type="text" class="form-input" id="expr-edit-keywords" value="${(expr.keywords || []).join(', ')}" placeholder="笑, 開心, 高興...">
          </div>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;cursor:pointer">
            <input type="checkbox" id="expr-edit-default" ${expr.isDefault ? 'checked' : ''}>
            設為默認表情
          </label>
        </div>
      </div>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
        <button class="modal-btn secondary" onclick="closeExpressionEdit()" style="padding:6px 12px;font-size:12px">取消</button>
        <button class="modal-btn confirm" onclick="saveExpressionEdit()" style="padding:6px 12px;font-size:12px">保存</button>
      </div>
    </div>
  `;
  
  // 移除舊的彈窗
  const oldPopup = document.getElementById('expr-edit-popup');
  if(oldPopup) oldPopup.remove();
  
  // 在表情列表後插入
  const container = document.getElementById('char-expressions-list');
  container.insertAdjacentHTML('afterend', html);
}

function closeExpressionEdit(){
  const popup = document.getElementById('expr-edit-popup');
  if(popup) popup.remove();
  editingExpressionIndex = -1;
}

function saveExpressionEdit(){
  if(editingExpressionIndex < 0) return;
  
  const name = document.getElementById('expr-edit-name')?.value?.trim() || '表情';
  const keywordsText = document.getElementById('expr-edit-keywords')?.value || '';
  const keywords = keywordsText.split(',').map(s => s.trim()).filter(s => s);
  const isDefault = document.getElementById('expr-edit-default')?.checked || false;
  
  // 更新表情
  charExpressions[editingExpressionIndex].name = name;
  charExpressions[editingExpressionIndex].keywords = keywords;
  
  // 如果設為默認，取消其他默認
  if(isDefault){
    charExpressions.forEach((e, i) => {
      e.isDefault = (i === editingExpressionIndex);
    });
  }
  charExpressions[editingExpressionIndex].isDefault = isDefault;
  
  closeExpressionEdit();
  renderCharExpressions();
  toast(T('表情已更新'), 'success');
}

function deleteExpression(idx){
  if(!confirm('確定要刪除這個表情嗎？')) return;
  
  const wasDefault = charExpressions[idx].isDefault;
  charExpressions.splice(idx, 1);
  
  // 如果刪除的是默認表情，設置第一個為默認
  if(wasDefault && charExpressions.length > 0){
    charExpressions[0].isDefault = true;
  }
  
  renderCharExpressions();
  toast(T('表情已刪除'), 'success');
}

// AI 自動切換表情
async function autoSwitchExpression(charId, aiResponse){
  const char = await db.characters.get(charId);
  if(!char || !char.expressions || char.expressions.length === 0) return null;
  if(char.expressionMode !== 'auto') return null;
  
  const responseText = aiResponse.toLowerCase();
  
  // 檢查每個表情的關鍵詞
  for(const expr of char.expressions){
    if(!expr.keywords || expr.keywords.length === 0) continue;
    
    const matched = expr.keywords.some(kw => responseText.includes(kw.toLowerCase()));
    if(matched){
      // 更新當前表情
      await db.characters.update(charId, { currentExpression: expr.id });
      return expr;
    }
  }
  
  return null;
}

// 獲取角色當前表情
async function getCurrentExpression(charId){
  const char = await db.characters.get(charId);
  if(!char || !char.expressions || char.expressions.length === 0) return null;
  
  // 如果有當前表情，返回它
  if(char.currentExpression){
    const expr = char.expressions.find(e => e.id === char.currentExpression);
    if(expr) return expr;
  }
  
  // 否則返回默認表情
  const defaultExpr = char.expressions.find(e => e.isDefault);
  return defaultExpr || char.expressions[0];
}

// 手動切換表情
async function switchExpression(charId, exprId){
  await db.characters.update(charId, { currentExpression: exprId });
  toast(T('表情已切換'), 'success');
  
  // 更新顯示
  renderCharacterExpressionInChat(charId);
}

// 在聊天中渲染角色表情
async function renderCharacterExpressionInChat(charId){
  const expr = await getCurrentExpression(charId);
  const displays = document.querySelectorAll(`.char-expr-display[data-char-id="${charId}"]`);
  
  displays.forEach(display => {
    if(expr && expr.image){
      display.src = expr.image;
      display.style.display = 'block';
    } else {
      display.style.display = 'none';
    }
  });
}

// 檢查並自動切換所有角色的表情
async function checkAutoExpressionSwitch(aiResponse){
  if(!story) return;
  
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  
  for(const char of chars){
    if(char.expressionMode !== 'auto') continue;
    if(!char.expressions || char.expressions.length === 0) continue;
    
    const switched = await autoSwitchExpression(char.id, aiResponse);
    if(switched){
      console.log(`Expression switched for ${char.name}: ${switched.name}`);
    }
  }
}

// v21: 更新經營模式 UI（雙軌並行：資源面板 + 角色系統都可用）
function updateSimulationUI(){
  const isSimMode = story?.mode === 'simulation';
  const resourceBar = document.getElementById('sim-resource-bar');
  const btnCharacters = document.getElementById('btn-characters');
  
  if(isSimMode){
    resourceBar.style.display = 'flex';
    // v21: 經營模式下也保留角色狀態按鈕（雙軌並行）
    btnCharacters.style.display = '';
    renderSimResourceBar();
  } else {
    resourceBar.style.display = 'none';
    btnCharacters.style.display = '';
  }
}

// v19: 渲染資源面板
function renderSimResourceBar(){
  const bar = document.getElementById('sim-resource-bar');
  if(!story || story.mode !== 'simulation') return;
  
  const day = story.simDay || 1;
  const resources = story.simResources || [];
  
  let html = `<div class="sim-day-badge" onclick="showSimResourceModal()">📅 第 ${day} 天</div>`;
  
  resources.forEach(r => {
    const change = r.value - (r.prevValue || r.value);
    let changeHtml = '';
    if(change !== 0){
      const cls = change > 0 ? 'up' : 'down';
      const sign = change > 0 ? '+' : '';
      changeHtml = `<span class="sim-resource-change ${cls}">${sign}${formatNumber(change)}</span>`;
    }
    html += `
      <div class="sim-resource-item" onclick="showSimResourceModal()">
        <span class="sim-resource-icon">${r.icon}</span>
        <span class="sim-resource-value">${formatNumber(r.value)}</span>
        ${changeHtml}
      </div>
    `;
  });
  
  bar.innerHTML = html;
}

function formatNumber(n){
  if(Math.abs(n) >= 10000) return (n/10000).toFixed(1) + '萬';
  if(Math.abs(n) >= 1000) return n.toLocaleString();
  return n.toString();
}

// v19: 顯示資源管理 Modal
function showSimResourceModal(){
  if(!story || story.mode !== 'simulation'){
    toast(T('此故事不是經營模式'),'warning');
    return;
  }
  
  document.getElementById('sim-current-day').value = story.simDay || 1;
  
  const list = document.getElementById('sim-resource-list');
  const resources = story.simResources || [];
  
  list.innerHTML = resources.map((r, idx) => `
    <div style="display:flex;gap:6px;align-items:center" data-idx="${idx}">
      <input type="text" class="form-input" style="width:50px;text-align:center" value="${r.icon}" maxlength="2">
      <input type="text" class="form-input" style="flex:1" value="${esc(r.name)}">
      <input type="number" class="form-input" style="width:90px" value="${r.value}">
      <button onclick="removeSimResourceInModal(this)" style="background:none;border:none;color:var(--error);cursor:pointer;font-size:16px">✕</button>
    </div>
  `).join('');
  
  showModal('sim-resource-modal');
}

function addSimResourceInModal(){
  const list = document.getElementById('sim-resource-list');
  const div = document.createElement('div');
  div.style.cssText = 'display:flex;gap:6px;align-items:center';
  div.innerHTML = `
    <input type="text" class="form-input" style="width:50px;text-align:center" placeholder="📊" maxlength="2">
    <input type="text" class="form-input" style="flex:1" placeholder="資源名稱">
    <input type="number" class="form-input" style="width:90px" placeholder="數值" value="0">
    <button onclick="removeSimResourceInModal(this)" style="background:none;border:none;color:var(--error);cursor:pointer;font-size:16px">✕</button>
  `;
  list.appendChild(div);
}

function removeSimResourceInModal(btn){
  btn.parentElement.remove();
}

function simDayMinus(){
  const input = document.getElementById('sim-current-day');
  input.value = Math.max(1, parseInt(input.value) - 1);
}

function simDayPlus(){
  const input = document.getElementById('sim-current-day');
  input.value = parseInt(input.value) + 1;
}

async function saveSimResources(){
  if(!story) return;
  
  const day = parseInt(document.getElementById('sim-current-day').value) || 1;
  const rows = document.querySelectorAll('#sim-resource-list > div');
  const resources = [];
  
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    if(inputs.length >= 3){
      const icon = inputs[0].value.trim() || '📊';
      const name = inputs[1].value.trim();
      const value = parseFloat(inputs[2].value) || 0;
      // 保留之前的 prevValue 用於計算變化
      const oldResource = story.simResources?.find(r => r.name === name);
      if(name) resources.push({
        icon, 
        name, 
        value, 
        prevValue: oldResource?.value ?? value
      });
    }
  });
  
  story.simDay = day;
  story.simResources = resources;
  
  await db.stories.update(story.id, {simDay: day, simResources: resources});
  
  renderSimResourceBar();
  closeModal('sim-resource-modal');
  toast(T('資源已更新'),'success');
}

// v19: 快速更新資源（+1天）
async function simNextDay(){
  if(!story || story.mode !== 'simulation') return;
  
  // 保存當前值為 prevValue
  const resources = (story.simResources || []).map(r => ({
    ...r,
    prevValue: r.value
  }));
  
  story.simDay = (story.simDay || 1) + 1;
  story.simResources = resources;
  
  await db.stories.update(story.id, {simDay: story.simDay, simResources: resources});
  renderSimResourceBar();
  toast(`進入第 ${story.simDay} 天`,'info');
}

// v19: 存檔導入
function showSimImportModal(){
  if(!story || story.mode !== 'simulation'){
    toast(T('此故事不是經營模式'),'warning');
    return;
  }
  document.getElementById('sim-import-content').value = '';
  document.getElementById('sim-import-regex').value = '';
  document.getElementById('sim-import-preview').style.display = 'none';
  showModal('sim-import-modal');
}

function parseSimImport(){
  const content = document.getElementById('sim-import-content').value;
  const customRegex = document.getElementById('sim-import-regex').value;
  
  if(!content.trim()){
    toast(T('請貼入存檔內容'),'warning');
    return;
  }
  
  const result = {day: null, resources: []};
  
  // 嘗試解析天數
  const dayPatterns = [
    /第\s*(\d+)\s*天/,
    /Day\s*(\d+)/i,
    /遊戲日期.*?(\d+)天/,
    /已遊玩.*?(\d+)\s*天/
  ];
  for(const p of dayPatterns){
    const m = content.match(p);
    if(m) { result.day = parseInt(m[1]); break; }
  }
  
  // 嘗試解析資源
  const resourcePatterns = [
    // 💰 現金：100,000元
    /([💰📦👥💎⭐🔮❤️🍖😊📊🎴])\s*([^：:]+)[：:]\s*([\d,]+)/g,
    // 現金：100,000元
    /([^\s：:]+)[：:]\s*([\d,]+)\s*元?/g
  ];
  
  if(customRegex){
    try{
      const regex = new RegExp(customRegex, 'g');
      let m;
      while((m = regex.exec(content)) !== null){
        if(m[1] && m[2]){
          result.resources.push({icon:'📊', name:m[1], value:parseInt(m[2].replace(/,/g,''))});
        }
      }
    }catch(e){
      toast('正則表達式錯誤: '+e.message,'error');
      return;
    }
  } else {
    // 使用默認模式
    for(const p of resourcePatterns){
      p.lastIndex = 0; // 重置正則表達式狀態
      let m;
      while((m = p.exec(content)) !== null){
        const isEmoji = /[\u{1F300}-\u{1F9FF}]/u.test(m[1]);
        if(isEmoji){
          result.resources.push({
            icon: m[1],
            name: m[2].trim(),
            value: parseInt(m[3].replace(/,/g,''))
          });
        } else if(m[1] && m[2]){
          result.resources.push({
            icon: '📊',
            name: m[1].trim(),
            value: parseInt(m[2].replace(/,/g,''))
          });
        }
      }
    }
  }
  
  // 去重
  const seen = new Set();
  result.resources = result.resources.filter(r => {
    if(seen.has(r.name)) return false;
    seen.add(r.name);
    return true;
  });
  
  // 顯示預覽
  const preview = document.getElementById('sim-import-preview');
  const previewContent = document.getElementById('sim-import-preview-content');
  
  let html = '';
  if(result.day) html += `<div>📅 天數：第 ${result.day} 天</div>`;
  if(result.resources.length){
    html += '<div style="margin-top:8px">資源：</div>';
    html += result.resources.map(r => 
      `<div style="margin-left:12px">${r.icon} ${r.name}：${r.value.toLocaleString()}</div>`
    ).join('');
  }
  
  if(!html) html = '<div style="color:var(--text-tertiary)">未能解析出任何數據，請檢查格式或使用自定義正則</div>';
  
  previewContent.innerHTML = html;
  preview.style.display = 'block';
  
  // 保存解析結果供導入使用
  preview.dataset.result = JSON.stringify(result);
}

async function applySimImport(){
  const preview = document.getElementById('sim-import-preview');
  if(!preview.dataset.result){
    parseSimImport();
  }
  
  try{
    const result = JSON.parse(preview.dataset.result || '{}');
    
    if(result.day) story.simDay = result.day;
    if(result.resources?.length){
      story.simResources = result.resources.map(r => ({...r, prevValue: r.value}));
    }
    
    await db.stories.update(story.id, {
      simDay: story.simDay,
      simResources: story.simResources
    });
    
    renderSimResourceBar();
    closeModal('sim-import-modal');
    toast(T('存檔導入成功！'),'success');
  }catch(e){
    toast('導入失敗: '+e.message,'error');
  }
}

// v19: 存檔導出
function showSimExportModal(){
  if(!story || story.mode !== 'simulation'){
    toast(T('此故事不是經營模式'),'warning');
    return;
  }
  document.getElementById('sim-export-format').value = 'simple';
  document.getElementById('sim-export-template-group').style.display = 'none';
  generateSimExport();
  showModal('sim-export-modal');
}

function generateSimExport(){
  const format = document.getElementById('sim-export-format').value;
  const templateGroup = document.getElementById('sim-export-template-group');
  templateGroup.style.display = format === 'custom' ? 'block' : 'none';
  
  const day = story.simDay || 1;
  const resources = story.simResources || [];
  const title = story.title;
  
  let content = '';
  
  if(format === 'simple'){
    content = `【${title}】存檔\n`;
    content += `📅 第 ${day} 天\n\n`;
    content += `【當前狀態】\n`;
    resources.forEach(r => {
      content += `${r.icon} ${r.name}：${r.value.toLocaleString()}\n`;
    });
  } else if(format === 'detailed'){
    content = `═══════════════════════════════════════════\n`;
    content += `【${title}】完整存檔\n`;
    content += `存檔時間：${new Date().toLocaleString()}\n`;
    content += `遊戲日期：第 ${day} 天\n`;
    content += `═══════════════════════════════════════════\n\n`;
    content += `【當前狀態】\n`;
    resources.forEach(r => {
      content += `${r.icon} ${r.name}：${r.value.toLocaleString()}\n`;
    });
    content += `\n【故事摘要】\n`;
    if(story.summaries?.length){
      story.summaries.forEach((s, i) => {
        content += `\n--- 記憶片段 ${i+1} ---\n${s.content}\n`;
      });
    } else {
      content += `（暫無摘要）\n`;
    }
    content += `\n═══════════════════════════════════════════\n`;
    content += `將此存檔完整貼給新對話即可繼續遊戲\n`;
    content += `═══════════════════════════════════════════`;
  } else {
    // 自定義模板
    const template = document.getElementById('sim-export-template').value;
    content = template
      .replace(/{day}/g, day)
      .replace(/{title}/g, title)
      .replace(/{resources}/g, resources.map(r => `${r.icon} ${r.name}：${r.value.toLocaleString()}`).join('\n'))
      .replace(/{summary}/g, story.summaries?.map(s=>s.content).join('\n\n') || '（暫無）');
  }
  
  document.getElementById('sim-export-content').value = content;
}

async function copySimExport(){
  const content = document.getElementById('sim-export-content').value;
  try{
    await navigator.clipboard.writeText(content);
    toast(T('已複製到剪貼板'),'success');
  }catch(e){
    toast(T('複製失敗，請手動選取複製'),'error');
  }
}
function renderMsgs(){
  const c=document.getElementById('content-area');
  if(!msgs.length){c.innerHTML=`<div class="empty" style="padding:60px 20px"><div class="empty-icon">✨</div><div class="empty-title">${T('故事即將開始')}</div><div class="empty-desc">${T('輸入你的第一個行動，或點擊「繼續」讓AI開始講述...')}</div></div>`;updateProgress();return;}
  let html='',lastTime=null,floor=0;
  msgs.forEach((m,idx)=>{
    floor++;
    if(m.storyTime&&m.storyTime!==lastTime){html+=`<div class="time-div">${esc(m.storyTime)}</div>`;lastTime=m.storyTime;}
    const isUser=m.role==='user';
    const isLast = idx === msgs.length - 1;
    
    if(isUser){
      // 小說式：用戶行動居中顯示
      const safeId = escAttr(m.id);
      const importantClass = m.isImportant ? ' msg-important' : '';
      const importantBadge = m.isImportant ? '<span class="msg-important-badge" title="重要記憶">⭐</span>' : '';
      html+=`<div class="msg user${importantClass}" data-id="${safeId}" oncontextmenu="showMsgMenu(event,'${safeId}')">
        <span class="msg-floor">#${floor}</span>
        ${importantBadge}
        <div class="msg-menu-btn" onclick="showMsgActionMenu(event,'${safeId}','user')">⋯</div>
        <div class="msg-user-action">
          <div class="action-divider">你的行動</div>
          <div class="action-content">「${esc(m.content).replace(/^[「」]|[「」]$/g,'')}」</div>
        </div>
      </div>`;
    }else{
      // AI 消息：分離劇情和狀態
      const parsed = parseAIResponse(m.content||'');
      const safeId = escAttr(m.id);
      const importantClass = m.isImportant ? ' msg-important' : '';
      const importantBadge = m.isImportant ? '<span class="msg-important-badge" title="重要記憶">⭐</span>' : '';
      html+=`<div class="msg${importantClass}" data-id="${safeId}" oncontextmenu="showMsgMenu(event,'${safeId}')">`;
      html+=`<span class="msg-floor">#${floor}</span>`;
      html+=`${importantBadge}`;
      html+=`<div class="msg-menu-btn" onclick="showMsgActionMenu(event,'${safeId}','ai')">⋯</div>`;
      html+=`<div class="msg-ai-story">${marked.parse(parsed.story)}</div>`;
      if(parsed.characters && parsed.characters.length > 0){
        html+=renderStatusCards(parsed.characters, m.id);
      }
      // v24: 显示玩家状态卡片
      if(parsed.playerStatus){
        html+=renderPlayerStatusCard(parsed.playerStatus, m.id);
      }
      if(parsed.formatWarning){
        html+=`<div class="msg-format-warning"><span class="icon">⚠️</span>AI 未按格式輸出狀態數據，已顯示原文</div>`;
      }
      if(m.tokens){
        html+=`<div class="msg-timestamp">≈${m.tokens} tokens</div>`;
      }
      html+=`</div>`;
    }
  });
  c.innerHTML=html;
  c.scrollTop=c.scrollHeight;
  updateProgress();
}

// 解析 AI 回覆，分離劇情和角色狀態
function parseAIResponse(content){
  try {
    // 確保content是字符串
    if(typeof content !== 'string'){
      console.warn('[Parse] 無效的內容類型:', typeof content);
      return { story: '', characters: [], playerStatus: null, timeUpdate: null, formatWarning: false };
    }

    let story = content;
    let characters = [];
    let playerStatus = null;
    let timeUpdate = null;
    let formatWarning = false;

    // 嘗試匹配 JSON 代碼塊
    const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
    if(jsonMatch){
      const jsonStr = jsonMatch[1];
      const data = safeJSONParse(jsonStr, {});
      if(data){
        if(data.characters && Array.isArray(data.characters)){
          characters = data.characters;
        }
        // v24: 解析玩家状态
        if(data.player && typeof data.player === 'object'){
          playerStatus = data.player;
        }
        // v26: 解析時間變化
        if(data.time && typeof data.time === 'object' && data.time.changed && data.time.newTime){
          timeUpdate = data.time;
        }
        // 移除 JSON 部分，只保留劇情
        story = content.replace(/```json\s*[\s\S]*?\s*```/, '').trim();
        // 移除可能的分隔線
        story = story.replace(/[-─]{3,}\s*(?:狀態更新|角色狀態|現有後宮|狀態)\s*[-─]{3,}/gi, '').trim();
      } else {
        console.log('[Parse] JSON 格式錯誤');
        formatWarning = true;
      }
    }else{
      // 檢查是否有狀態內容但沒用 JSON 格式
      const hasStatusMarker = /[-─]{3,}\s*(?:狀態更新|角色狀態|現有後宮|狀態|現有角色)\s*[-─]{3,}/i.test(content);
      const hasCharacterBlock = /【[^】]+】[^\n]+/.test(content);
      if(hasStatusMarker || hasCharacterBlock){
        // 嘗試解析舊格式
        const parsed = parseOldFormatStatus(content);
        if(parsed.characters.length > 0){
          characters = parsed.characters;
          story = parsed.story;
        }else{
          formatWarning = hasStatusMarker; // 有標記但解析失敗才警告
        }
      }
    }

    return { story, characters, playerStatus, timeUpdate, formatWarning };
  } catch(e) {
    console.error('[Parse] 解析錯誤:', e);
    return { story: content || '', characters: [], playerStatus: null, timeUpdate: null, formatWarning: false };
  }
}

// 解析舊格式狀態（【角色】格式）
function parseOldFormatStatus(content){
  let story = content;
  let characters = [];
  
  // 找到狀態分隔線
  const statusMatch = content.match(/([-─]{3,}\s*(?:狀態更新|角色狀態|現有後宮|狀態|現有角色)\s*[-─]{3,})([\s\S]*?)(?=[-─]{3,}|$)/i);
  if(statusMatch){
    story = content.slice(0, content.indexOf(statusMatch[0])).trim();
    const statusText = statusMatch[2];
    
    // 解析【角色】格式
    const charBlocks = statusText.split(/(?=【[^】]+】)/);
    charBlocks.forEach(block => {
      if(!block.trim()) return;
      const nameMatch = block.match(/【([^】]+)】\s*([^\s【]+)?/);
      if(nameMatch){
        const char = {
          name: nameMatch[2] || nameMatch[1],
          title: nameMatch[1].includes('】') ? '' : nameMatch[1],
          stats: {},
          tags: []
        };
        
        // 提取數值屬性
        const statPatterns = [
          /好感[度]?\s*(\d+)/g,
          /表面好感\s*(\d+)/g,
          /真實好感\s*(\d+)/g,
          /寵愛[度]?\s*(\d+)/g,
          /忠誠[度]?\s*(\d+)/g,
          /野心[值]?\s*(\d+)/g,
          /智謀\s*(\d+)/g,
          /容貌\s*(\d+)/g,
          /健康\s*(\d+)/g
        ];
        
        const statNames = ['好感', '表面好感', '真實好感', '寵愛度', '忠誠', '野心', '智謀', '容貌', '健康'];
        statPatterns.forEach((pattern, i) => {
          const match = block.match(pattern);
          if(match){
            char.stats[statNames[i]] = parseInt(match[1]);
          }
        });
        
        // 提取情緒
        const moodMatch = block.match(/情緒[：:]\s*([^\s|｜]+)/);
        if(moodMatch) char.mood = moodMatch[1];
        
        // 提取居所
        const locationMatch = block.match(/居所[：:·]?\s*([^\s|｜]+)/);
        if(locationMatch) char.location = locationMatch[1];
        
        if(Object.keys(char.stats).length > 0 || char.mood){
          characters.push(char);
        }
      }
    });
  }
  
  return { story, characters };
}

// 渲染狀態卡片
function renderStatusCards(characters, msgId){
  if(!characters || characters.length === 0) return '';
  
  let html = `<div class="msg-status-section">`;
  html += `<div class="msg-status-header" onclick="toggleStatusCards(this)">`;
  html += `<span class="title">👥 角色狀態更新 (${characters.length})</span>`;
  html += `<span class="toggle">▼</span>`;
  html += `</div>`;
  html += `<div class="msg-status-cards">`;
  
  characters.forEach(char => {
    html += `<div class="status-card">`;
    html += `<div class="status-card-header">`;
    html += `<div class="status-card-avatar">${char.avatar || '👤'}</div>`;
    html += `<div class="status-card-info">`;
    html += `<div class="status-card-name">${esc(char.name)}`;
    if(char.title) html += `<span class="status-card-title">${esc(char.title)}</span>`;
    html += `</div>`;
    if(char.location) html += `<div class="status-card-meta">📍 ${esc(char.location)}</div>`;
    html += `</div></div>`;
    
    // 渲染數值屬性
    if(char.stats && Object.keys(char.stats).length > 0){
      html += `<div class="status-card-stats">`;
      Object.entries(char.stats).forEach(([key, value]) => {
        const numValue = typeof value === 'number' ? value : parseInt(value) || 0;
        const fillClass = numValue >= 70 ? 'high' : numValue >= 40 ? 'medium' : numValue > 0 ? 'low' : 'primary';
        html += `<div class="status-stat-row">`;
        html += `<span class="status-stat-label">${esc(key)}</span>`;
        html += `<div class="status-stat-bar"><div class="status-stat-fill ${fillClass}" style="width:${Math.min(100, numValue)}%"></div></div>`;
        html += `<span class="status-stat-value">${numValue}</span>`;
        html += `</div>`;
      });
      html += `</div>`;
    }
    
    // 渲染標籤（情緒、備註等）
    const hasTags = char.mood || char.note || (char.tags && char.tags.length > 0);
    if(hasTags){
      html += `<div class="status-card-footer">`;
      if(char.mood) html += `<span class="status-tag mood">😐 ${esc(char.mood)}</span>`;
      if(char.note) html += `<span class="status-tag note">💭 ${esc(char.note)}</span>`;
      if(char.tags) char.tags.forEach(tag => {
        html += `<span class="status-tag">${esc(tag)}</span>`;
      });
      html += `</div>`;
    }
    
    html += `</div>`;
  });
  
  html += `</div></div>`;
  return html;
}

// v24: 渲染玩家状态卡片
function renderPlayerStatusCard(playerStatus, msgId){
  if(!playerStatus || !currentPlayerPanel) return '';

  // 检查是否有状态变化
  const hasChanges = playerStatus.stats && Object.keys(playerStatus.stats).length > 0;
  if(!hasChanges) return '';

  let html = `<div class="msg-status-section player-status">`;
  html += `<div class="msg-status-header" onclick="toggleStatusCards(this)">`;
  html += `<span class="title">👤 ${esc(currentPlayerPanel.name || '玩家状态')}更新</span>`;
  html += `<span class="toggle">▼</span>`;
  html += `</div>`;
  html += `<div class="msg-status-cards">`;

  html += `<div class="status-card player-card">`;
  html += `<div class="status-card-header">`;
  html += `<div class="status-card-avatar">👤</div>`;
  html += `<div class="status-card-info">`;
  html += `<div class="status-card-name">${esc(currentPlayerPanel.name || '玩家')}</div>`;
  html += `</div></div>`;

  // 渲染数值属性
  if(playerStatus.stats && Object.keys(playerStatus.stats).length > 0){
    html += `<div class="status-card-stats">`;
    Object.entries(playerStatus.stats).forEach(([key, value]) => {
      const numValue = typeof value === 'number' ? value : parseInt(value) || 0;

      // 根据属性的color配置来决定颜色
      const attr = currentPlayerPanel.attributes?.find(a => a.name === key);
      let fillClass = 'primary';
      if(attr && attr.color){
        const colorMap = {
          'red': 'low',
          'orange': 'medium',
          'green': 'high',
          'blue': 'primary',
          'purple': 'primary',
          'pink': 'primary',
          'default': 'primary'
        };
        fillClass = colorMap[attr.color] || 'primary';
      } else {
        // 默认逻辑
        fillClass = numValue >= 70 ? 'high' : numValue >= 40 ? 'medium' : numValue > 0 ? 'low' : 'primary';
      }

      html += `<div class="status-stat-row">`;
      html += `<span class="status-stat-label">${attr?.icon || '📊'} ${esc(key)}</span>`;
      html += `<div class="status-stat-bar"><div class="status-stat-fill ${fillClass}" style="width:${Math.min(100, numValue)}%"></div></div>`;
      html += `<span class="status-stat-value">${numValue}</span>`;
      html += `</div>`;
    });
    html += `</div>`;
  }

  // 渲染备注
  if(playerStatus.note){
    html += `<div class="status-card-footer">`;
    html += `<span class="status-tag note">💭 ${esc(playerStatus.note)}</span>`;
    html += `</div>`;
  }

  html += `</div>`;
  html += `</div></div>`;

  return html;
}

// 切換狀態卡片展開/收起
function toggleStatusCards(header){
  header.classList.toggle('expanded');
}

function updateProgress(){const n=msgs.length;document.getElementById('progress-fill').style.width=(n>0?100:0)+'%';document.getElementById('progress-text').textContent=n>0?n+'條':'0%';}

// ============ 智能上下文選擇 ============

/**
 * 智能選擇上下文消息
 * @param {Array} allMessages - 所有消息
 * @param {number} maxCount - 最大消息數量
 * @param {string} currentContent - 當前用戶輸入（用於相關性判斷）
 * @returns {Array} 選中的消息
 */
function selectSmartContext(allMessages, maxCount, currentContent = ''){
  if(!settings.smartContext || !allMessages || allMessages.length === 0){
    // 關閉智能模式，使用傳統方式
    return allMessages.slice(-maxCount);
  }

  // 邊界情況：消息數量少於maxCount，直接返回全部
  if(allMessages.length <= maxCount){
    console.log(`[SmartContext] 消息數量(${allMessages.length})少於配額(${maxCount})，返回全部`);
    return allMessages;
  }

  console.log(`[SmartContext] 開始智能選擇，總消息數：${allMessages.length}，目標數量：${maxCount}`);

  const recentCount = Math.min(settings.smartContextRecent || 10, maxCount);
  const minScore = settings.smartContextMinScore || 30;

  // 1. 必選：最近N條消息（保證連貫性）
  const recentMessages = allMessages.slice(-Math.min(recentCount, allMessages.length));
  const recentIds = new Set(recentMessages.map(m => m.id));

  console.log(`[SmartContext] 必選最近 ${recentMessages.length} 條消息`);

  // 2. 必選：用戶標記為重要的消息
  const importantMessages = allMessages.filter(m => m.isImportant && !recentIds.has(m.id));
  const importantIds = new Set(importantMessages.map(m => m.id));

  console.log(`[SmartContext] 必選重要標記 ${importantMessages.length} 條消息`);

  // 3. 計算剩餘配額
  const selectedCount = recentMessages.length + importantMessages.length;
  const remainingQuota = maxCount - selectedCount;

  console.log(`[SmartContext] 已選 ${selectedCount} 條，剩餘配額 ${remainingQuota} 條`);

  if(remainingQuota <= 0){
    // 配額已滿，需要裁剪
    const selected = [...recentMessages, ...importantMessages];
    // 如果超出配額，優先保留最近的消息
    if(selected.length > maxCount){
      console.log(`[SmartContext] 超出配額，裁剪到 ${maxCount} 條`);
      // 保留所有最近消息，裁剪重要消息
      const trimmedImportant = importantMessages.slice(-(maxCount - recentMessages.length));
      return [...recentMessages, ...trimmedImportant].sort((a, b) => a.createdAt - b.createdAt);
    }
    console.log(`[SmartContext] 配額已滿，返回 ${selected.length} 條消息`);
    return selected.sort((a, b) => a.createdAt - b.createdAt);
  }

  // 4. 為剩餘消息評分
  const scoredMessages = allMessages
    .filter(m => !recentIds.has(m.id) && !importantIds.has(m.id))
    .map(m => ({
      message: m,
      score: calculateMessageScore(m, currentContent, allMessages)
    }))
    .filter(item => item.score >= minScore)
    .sort((a, b) => b.score - a.score);

  console.log(`[SmartContext] 評分完成，${scoredMessages.length} 條消息達到最低分數 ${minScore}`);

  // 5. 選擇高分消息填充剩餘配額
  const highScoreMessages = scoredMessages
    .slice(0, remainingQuota)
    .map(item => item.message);

  console.log(`[SmartContext] 選擇 ${highScoreMessages.length} 條高分消息`);

  // 6. 合併並按時間排序
  const finalMessages = [...recentMessages, ...importantMessages, ...highScoreMessages];
  finalMessages.sort((a, b) => a.createdAt - b.createdAt);

  console.log(`[SmartContext] 最終選擇 ${finalMessages.length} 條消息`);

  return finalMessages;
}

/**
 * 計算消息重要性分數
 * @param {Object} message - 消息對象
 * @param {string} currentContent - 當前用戶輸入
 * @param {Array} allMessages - 所有消息（用於提取關鍵詞）
 * @returns {number} 分數（0-100）
 */
function calculateMessageScore(message, currentContent, allMessages){
  let score = 0;
  const content = message.content || '';

  // 1. 基礎分數
  if(message.role === 'user'){
    score += 5; // 用戶消息通常更重要
  }

  // 2. 長度分數（詳細描述通常重要）
  if(content.length > 200){
    score += 10;
  } else if(content.length > 100){
    score += 5;
  }

  // 3. 包含角色名（從所有消息中提取常見名字）
  const characterNames = extractCharacterNames(allMessages);
  characterNames.forEach(name => {
    if(content.includes(name)){
      score += 15;
    }
  });

  // 4. 包含關鍵詞
  const keywords = ['重要', '關鍵', '秘密', '發現', '決定', '承諾', '約定', '警告', '危險'];
  keywords.forEach(keyword => {
    if(content.includes(keyword)){
      score += 8;
    }
  });

  // 5. 與當前輸入的相關性（簡單關鍵詞匹配）
  if(currentContent && currentContent.length > 2){
    const currentWords = extractKeywords(currentContent);
    const messageWords = extractKeywords(content);
    const matchCount = currentWords.filter(w => messageWords.includes(w)).length;
    score += matchCount * 5;
  }

  // 6. 包含問題或選擇（互動性強）
  if(content.includes('？') || content.includes('?') || content.includes('選擇')){
    score += 8;
  }

  // 7. 包含情緒詞（情感重要）
  const emotionWords = ['愛', '恨', '怕', '喜歡', '討厭', '生氣', '開心', '難過', '感動'];
  emotionWords.forEach(word => {
    if(content.includes(word)){
      score += 6;
    }
  });

  return Math.min(score, 100); // 最高100分
}

/**
 * 從消息中提取角色名
 * @param {Array} messages - 所有消息
 * @returns {Array} 角色名列表
 */
function extractCharacterNames(messages){
  // 性能優化：只分析最近的消息
  const recentMessages = messages.slice(-50);
  const namePattern = /[「『""]([^「『""」』]{2,8})[」』""]/g;
  const names = new Set();

  recentMessages.forEach(m => {
    const content = m.content || '';
    // 重置正則表達式的lastIndex
    namePattern.lastIndex = 0;
    let match;
    let matchCount = 0;
    while((match = namePattern.exec(content)) !== null && matchCount < 10){
      const name = match[1];
      // 過濾掉常見的非名字
      if(name.length >= 2 && name.length <= 8 &&
         !['你好', '謝謝', '對不起', '沒關係', '是的', '不是', '什麼', '怎麼', '為什麼'].includes(name)){
        names.add(name);
      }
      matchCount++;
    }
  });

  return Array.from(names).slice(0, 20); // 最多20個名字
}

/**
 * 提取關鍵詞（簡單分詞）
 * @param {string} text - 文本
 * @returns {Array} 關鍵詞列表
 */
function extractKeywords(text){
  // 性能優化：限制文本長度
  const limitedText = text.slice(0, 500);

  // 簡單的中文分詞：提取2-4字的詞組
  const words = [];
  for(let len = 4; len >= 2; len--){
    for(let i = 0; i <= limitedText.length - len; i++){
      const word = limitedText.substring(i, i + len);
      if(word.trim().length === len){
        words.push(word);
      }
    }
  }
  return [...new Set(words)].slice(0, 50); // 去重，最多50個
}

// 發送消息
async function send(){
  const input=document.getElementById('user-input'),content=input.value.trim();
  if(!content||generating)return;
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  const sendBtn=document.getElementById('send-btn');

  try {
    generating=true;
    sendBtn.disabled=true;

    // 保存用户消息
    const userMsgId=crypto.randomUUID();
    const userMsg={id:userMsgId,storyId:story.id,branchId:story.currentBranchId,role:'user',content,createdAt:Date.now()};
    await db.messages.put(userMsg);
    msgs.push(userMsg);
    input.value='';

    // ✨ 清除草稿
    try {
      await db.stories.update(story.id, {
        draft: '',
        updatedAt: Date.now()
      });
      console.log('[Draft] 已清除草稿');
    } catch(e) {
      console.error('[Draft] 清除草稿失败:', e);
    }

    renderMsgs();

    // 更新伏筆計數
    await updateForeshadowCounts();

    // 检查是否启用流式响应
    const useStreaming=settings.enableStreaming;

    if(useStreaming){
      // 流式响应模式
      await sendWithStreaming(content,sendBtn);
    }else{
      // 传统模式
      await sendTraditional(content);
    }

    // 檢查並顯示伏筆提醒
    showForeshadowReminder();
  } finally {
    // ✅ 确保无论如何都会重置状态
    generating=false;
    sendBtn.disabled=false;
  }
}

// 传统非流式发送
async function sendTraditional(content){
  showTyping();
  try{
    const resp=await callAI(content);
    hideTyping();
    const aiMsgId=crypto.randomUUID();
    const aiMsg={id:aiMsgId,storyId:story.id,branchId:story.currentBranchId,role:'assistant',content:resp.content,tokens:resp.tokens||0,storyTime:story.storyTime||'',createdAt:Date.now()};
    await db.messages.put(aiMsg);
    msgs.push(aiMsg);
    await db.stories.update(story.id,{updatedAt:Date.now(),preview:resp.content.slice(0,100),currentMessageId:aiMsgId,'statistics.totalMessages':msgs.length,'statistics.totalChars':(story.statistics?.totalChars||0)+resp.content.length});
    await typewriter(aiMsg);
    checkAutoRollingSummary();
    checkAutoLorebookExtract();
    checkAutoConsistencyCheck();

    // v26: 處理時間變化（從 JSON 解析）
    const parsed = parseAIResponse(resp.content);
    if(parsed.timeUpdate){
      await handleTimeUpdate(parsed.timeUpdate);
    }

    // 自動同步到雲端
    autoSyncToCloud();
  }catch(e){
    console.error(e);
    hideTyping();
    toast('生成失敗: '+e.message,'error');
  }
}

// 流式发送
async function sendWithStreaming(content,sendBtn){
  const preset=await db.apiPresets.filter(p=>p.isActive).first();
  if(!preset){toast(T('請先配置並選擇一個 API 預設'),'error');return;}

  // 构建系统提示和消息（v27: 传入用户输入以启用智能角色选择）
  let sysPrompt=await buildSysPrompt(content);
  const triggeredLorebook=await getTriggeredLorebook(content);
  if(triggeredLorebook.length>0){
    sysPrompt+='\n\n### 相關設定（自動觸發）\n';
    for(const entry of triggeredLorebook){
      if(entry.name && entry.content){
        sysPrompt+=`\n#### ${entry.name}\n${entry.content}\n`;
      }
      await db.lorebook.update(entry.id,{triggerCount:(entry.triggerCount||0)+1,lastTriggered:Date.now()});
      if(entry.oneTime)await db.lorebook.update(entry.id,{isEnabled:false});
    }
    showLorebookTriggerToast(triggeredLorebook);
  }

  const contextCount=settings.contextCount||20;

  // 使用智能上下文選擇
  const selectedMessages = selectSmartContext(msgs, contextCount, content);
  const messages = selectedMessages.map(m=>({role:m.role,content:m.content}));

  if(!messages.length||messages[messages.length-1].content!==content)messages.push({role:'user',content});
  
  // v25: 注入後歷史指令 (post_history_instructions)
  const postHistoryInstructions = await getPostHistoryInstructions();
  if(postHistoryInstructions){
    // 在最後一條用戶消息後添加系統指令
    messages.push({
      role: 'user',
      content: `[系統指令：${postHistoryInstructions}]`
    });
  }

  // 创建空的AI消息元素
  const c=document.getElementById('content-area');
  const aiMsgId=crypto.randomUUID();
  const msgDiv=document.createElement('div');
  msgDiv.className='msg';
  msgDiv.dataset.id=aiMsgId;
  c.appendChild(msgDiv);

  // 替换发送按钮为停止按钮
  sendBtn.textContent='■';
  sendBtn.style.background='var(--error)';
  sendBtn.disabled=false;  // 重要：启用按钮让用户可以点击停止
  sendBtn.onclick=()=>stopStreaming();

  let fullContent='';
  let stopped=false;
  const chunkDelay=settings.streamingChunkDelay||20;

  try{
    // 选择对应的流式API函数
    let streamFunc;
    if(preset.type==='anthropic')streamFunc=callAnthropicStream;
    else if(preset.type==='openai')streamFunc=callOpenAIStream;
    else streamFunc=callCustomStream;

    // 调用流式API
    const result=await streamFunc(
      preset,
      sysPrompt,
      messages,
      // onChunk: 收到新文字时
      async(newText,full)=>{
        fullContent=full;
        // 轻微延迟以实现平滑显示
        if(chunkDelay>0){
          await new Promise(r=>setTimeout(r,chunkDelay));
        }
        msgDiv.innerHTML=`<div class="msg-ai-story">${marked.parse(full)}</div>`;
        c.scrollTop=c.scrollHeight;
      },
      // onDone: 生成完成
      (final)=>{
        fullContent=final;
      },
      // onError: 发生错误
      (error,partial)=>{
        fullContent=partial;
        stopped=true;
      }
    );

    if(result.stopped)stopped=true;

  }catch(e){
    console.error(e);
    stopped=true;

    // 检查是否是不支持流式的错误
    const errMsg=e.message||'';
    if(errMsg.includes('stream')&&!errMsg.includes('停止')){
      toast(T('此 API 不支持流式響應，已自動切換到傳統模式'),'warning');
      // 降级到非流式
      sendBtn.textContent='↑';
      sendBtn.style.background='';
      sendBtn.onclick=()=>send();
      msgDiv.remove();
      await sendTraditional(content);
      return;
    }

    if(!errMsg.includes('停止')){
      toast('生成失敗: '+errMsg,'error');
    }
  }

  // 恢复发送按钮
  sendBtn.textContent='↑';
  sendBtn.style.background='';
  sendBtn.onclick=()=>send();

  // 处理生成的内容
  if(stopped){
    // 用户中途停止,询问是否保存
    if(fullContent&&fullContent.length>10){
      showConfirm('生成已停止，是否保存已生成的內容？',async()=>{
        await saveStreamedMessage(aiMsgId,fullContent,msgDiv);
      },false,'確認',()=>{
        msgDiv.remove();
      });
    }else{
      msgDiv.remove();
    }
  }else{
    // 正常完成
    await saveStreamedMessage(aiMsgId,fullContent,msgDiv);
  }
}

// 保存流式生成的消息
async function saveStreamedMessage(aiMsgId,fullContent,msgDiv){
  // 估算 token 數量（中文約2字符=1token，英文約4字符=1token）
  const estimatedTokens = Math.round(fullContent.length / 2);
  const aiMsg={id:aiMsgId,storyId:story.id,branchId:story.currentBranchId,role:'assistant',content:fullContent,tokens:estimatedTokens,storyTime:story.storyTime||'',createdAt:Date.now()};
  await db.messages.put(aiMsg);
  msgs.push(aiMsg);
  await db.stories.update(story.id,{updatedAt:Date.now(),preview:fullContent.slice(0,100),currentMessageId:aiMsgId,'statistics.totalMessages':msgs.length,'statistics.totalChars':(story.statistics?.totalChars||0)+fullContent.length});

  // 解析并显示完整内容(包括角色状态)
  const parsed=parseAIResponse(fullContent);
  const safeId = escAttr(aiMsgId);
  const floor = msgs.length; // 当前楼层号
  let html=`<span class="msg-floor">#${floor}</span>`;
  html+=`<div class="msg-menu-btn" onclick="showMsgActionMenu(event,'${safeId}','ai')">⋯</div>`;
  html+=`<div class="msg-ai-story">${marked.parse(parsed.story)}</div>`;
  if(parsed.characters&&parsed.characters.length>0){
    html+=renderStatusCards(parsed.characters,aiMsgId);
    syncCharacterStatus(parsed.characters);
  }
  // v23: 自動解析玩家狀態
  parsePlayerStatusFromAI(fullContent);
  if(parsed.playerStatus){
    html+=renderPlayerStatusCard(parsed.playerStatus, aiMsgId);
  }
  // v26: 處理時間變化（從 JSON 中解析）
  if(parsed.timeUpdate){
    await handleTimeUpdate(parsed.timeUpdate);
  }
  if(parsed.formatWarning){
    html+=`<div class="msg-format-warning"><span class="icon">⚠️</span>AI 未按格式輸出狀態數據，已顯示原文</div>`;
  }
  if(estimatedTokens){
    html+=`<div class="msg-timestamp">≈${estimatedTokens} tokens</div>`;
  }
  msgDiv.innerHTML=html;
  checkAutoRollingSummary();

  checkAutoLorebookExtract();

  // 自動同步到雲端
  autoSyncToCloud();
}
function sendCmd(cmd){document.getElementById('user-input').value=cmd;send();}

// ============ 快捷指令系統 ============
const defaultQuickCommands = [
  { id: 'default_1', label: '繼續', content: '繼續', order: 1 },
  { id: 'default_2', label: '狀態', content: '查看狀態', order: 2 },
  { id: 'default_3', label: '環境', content: '描述環境', order: 3 }
];

async function initDefaultQuickCommands(){
  const count = await db.quickCommands.count();
  if(count === 0){
    for(const cmd of defaultQuickCommands){
      await db.quickCommands.put({...cmd, createdAt: Date.now()});
    }
  }
}

async function renderQuickCommands(){
  const container = document.getElementById('quick-cmds');
  if(!container) return;
  
  const cmds = await db.quickCommands.orderBy('order').toArray();
  
  let html = '';
  cmds.forEach(cmd => {
    // 对默认命令标签进行简繁转换
    const label = cmd.id.startsWith('default_') ? T(cmd.label) : cmd.label;
    html += `<button class="quick-cmd" onclick="sendCmd('${esc(cmd.content)}')">${esc(label)}</button>`;
  });
  html += `<button class="quick-cmd add" onclick="showQuickCmdManager()">＋</button>`;
  
  container.innerHTML = html;
}

function showQuickCmdManager(){
  renderQuickCmdList();
  showModal('quick-cmd-modal');
}

async function renderQuickCmdList(){
  const container = document.getElementById('quick-cmd-list');
  const cmds = await db.quickCommands.orderBy('order').toArray();
  
  if(cmds.length === 0){
    container.innerHTML = `<div style="text-align:center;padding:20px;color:var(--text-tertiary)">${T('暫無快捷指令')}</div>`;
    return;
  }
  
  let html = '';
  cmds.forEach(cmd => {
    html += `
      <div class="quick-cmd-item" data-id="${cmd.id}">
        <span class="drag-handle">⋮⋮</span>
        <div class="cmd-info">
          <div class="cmd-label">${esc(cmd.label)}</div>
          <div class="cmd-content">${esc(cmd.content)}</div>
        </div>
        <div class="cmd-actions">
          <button class="edit-btn" onclick="editQuickCommand('${cmd.id}')">編輯</button>
          <button class="del-btn" onclick="deleteQuickCommand('${cmd.id}')">刪除</button>
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

async function addQuickCommand(){
  const label = document.getElementById('new-cmd-label').value.trim();
  const content = document.getElementById('new-cmd-content').value.trim();
  
  if(!label){toast(T('請輸入按鈕顯示文字'),'warning');return;}
  if(!content){toast(T('請輸入指令內容'),'warning');return;}
  
  const maxOrder = await db.quickCommands.orderBy('order').last();
  const order = maxOrder ? maxOrder.order + 1 : 1;
  
  await db.quickCommands.put({
    id: crypto.randomUUID(),
    label,
    content,
    order,
    createdAt: Date.now()
  });
  
  document.getElementById('new-cmd-label').value = '';
  document.getElementById('new-cmd-content').value = '';
  
  await renderQuickCmdList();
  await renderQuickCommands();
  toast(T('快捷指令已添加'),'success');
}

async function editQuickCommand(id){
  const cmd = await db.quickCommands.get(id);
  if(!cmd) return;
  
  document.getElementById('edit-cmd-id').value = id;
  document.getElementById('edit-cmd-label').value = cmd.label;
  document.getElementById('edit-cmd-content').value = cmd.content;
  
  showModal('edit-cmd-modal');
}

async function saveEditQuickCommand(){
  const id = document.getElementById('edit-cmd-id').value;
  const label = document.getElementById('edit-cmd-label').value.trim();
  const content = document.getElementById('edit-cmd-content').value.trim();
  
  if(!label){toast(T('請輸入按鈕顯示文字'),'warning');return;}
  if(!content){toast(T('請輸入指令內容'),'warning');return;}
  
  const cmd = await db.quickCommands.get(id);
  if(!cmd) return;
  
  cmd.label = label;
  cmd.content = content;
  await db.quickCommands.put(cmd);
  
  closeModal('edit-cmd-modal');
  await renderQuickCmdList();
  await renderQuickCommands();
  toast(T('快捷指令已更新'),'success');
}

async function deleteQuickCommand(id){
  if(!confirm('確定刪除這個快捷指令？')) return;
  
  await db.quickCommands.delete(id);
  await renderQuickCmdList();
  await renderQuickCommands();
  toast(T('快捷指令已刪除'),'success');
}

async function resetQuickCommands(){
  if(!confirm('確定恢復默認快捷指令？這將刪除所有自定義指令。')) return;

  await db.quickCommands.clear();
  for(const cmd of defaultQuickCommands){
    await db.quickCommands.put({...cmd, createdAt: Date.now()});
  }

  await renderQuickCmdList();
  await renderQuickCommands();
  toast(T('已恢復默認快捷指令'),'success');
}

// ============ Persona 系統 ============
let currentPersona = null;

// 初始化默認 Persona
async function initDefaultPersona(){
  const count = await db.personas.count();
  if(count === 0){
    const defaultPersona = {
      id: 'default',
      name: '無特定身份',
      avatar: '👤',
      description: '',
      background: '',
      speechStyle: '',
      isDefault: true,
      createdAt: Date.now()
    };
    await db.personas.put(defaultPersona);
  }

  // 載入當前 Persona
  if(story && story.currentPersonaId){
    currentPersona = await db.personas.get(story.currentPersonaId);
  }
  if(!currentPersona){
    currentPersona = await db.personas.get('default');
  }

  updatePersonaDisplay();
}

// 更新 Persona 顯示
function updatePersonaDisplay(){
  if(!currentPersona) return;

  const avatarEl = document.getElementById('current-persona-avatar');
  const nameEl = document.getElementById('current-persona-name');

  if(avatarEl) avatarEl.textContent = currentPersona.avatar || '👤';
  if(nameEl) nameEl.textContent = currentPersona.name || T('無特定身份');
}

// 顯示 Persona 選擇器
async function showPersonaSelector(){
  await renderPersonaList();
  showModal('persona-selector-modal');
}

// 渲染 Persona 列表
async function renderPersonaList(){
  const container = document.getElementById('persona-list');
  const personas = await db.personas.orderBy('createdAt').toArray();

  let html = '';
  for(const persona of personas){
    const isSelected = currentPersona && currentPersona.id === persona.id;
    html += `
      <div class="card ${isSelected ? 'selected' : ''}" onclick="selectPersona('${persona.id}')" style="cursor:pointer">
        <div style="font-size:32px;margin-right:12px">${persona.avatar || '👤'}</div>
        <div class="card-info">
          <div class="card-title">${esc(persona.name)}</div>
          ${persona.description ? `<div class="card-preview">${esc(persona.description)}</div>` : ''}
        </div>
        ${isSelected ? '<div style="color:var(--primary);font-size:20px">✓</div>' : ''}
      </div>
    `;
  }

  container.innerHTML = html;
}

// 選擇 Persona
async function selectPersona(personaId){
  currentPersona = await db.personas.get(personaId);

  // 保存到故事
  if(story){
    story.currentPersonaId = personaId;
    await db.stories.update(story.id, {currentPersonaId: personaId});
  }

  updatePersonaDisplay();
  closeModal('persona-selector-modal');
  toast(`已切換到身份「${currentPersona.name}」`, 'success');
}

// 顯示 Persona 管理器
async function showPersonaManager(){
  closeModal('persona-selector-modal');
  await renderPersonaManagerList();
  showModal('persona-manager-modal');
}

// 渲染 Persona 管理列表
async function renderPersonaManagerList(){
  const container = document.getElementById('persona-manager-list');
  const personas = await db.personas.orderBy('createdAt').toArray();

  let html = '';
  for(const persona of personas){
    const isDefault = persona.id === 'default';
    html += `
      <div class="card">
        <div style="font-size:28px;margin-right:12px">${persona.avatar || '👤'}</div>
        <div class="card-info">
          <div class="card-title">${esc(persona.name)}</div>
          ${persona.description ? `<div class="card-preview">${esc(persona.description)}</div>` : ''}
        </div>
        <div style="display:flex;gap:8px">
          ${!isDefault ? `<button class="modal-btn" onclick="editPersona('${persona.id}')" style="padding:6px 12px;font-size:13px">編輯</button>` : ''}
          ${!isDefault ? `<button class="modal-btn cancel" onclick="deletePersona('${persona.id}')" style="padding:6px 12px;font-size:13px">刪除</button>` : ''}
        </div>
      </div>
    `;
  }

  if(personas.length === 1){
    html += '<div style="text-align:center;padding:20px;color:var(--text-tertiary)">尚未創建自定義身份<br>點擊下方按鈕創建</div>';
  }

  container.innerHTML = html;
}

// 創建新 Persona
function createNewPersona(){
  closeModal('persona-manager-modal');

  document.getElementById('persona-edit-title').textContent = '✨ 創建新身份';
  document.getElementById('persona-edit-id').value = '';
  document.getElementById('persona-avatar').value = '';
  document.getElementById('persona-name').value = '';
  document.getElementById('persona-description').value = '';
  document.getElementById('persona-background').value = '';
  document.getElementById('persona-speech-style').value = '';

  showModal('persona-edit-modal');
}

// 編輯 Persona
async function editPersona(personaId){
  closeModal('persona-manager-modal');

  const persona = await db.personas.get(personaId);
  if(!persona) return;

  document.getElementById('persona-edit-title').textContent = '✏️ 編輯身份';
  document.getElementById('persona-edit-id').value = persona.id;
  document.getElementById('persona-avatar').value = persona.avatar || '';
  document.getElementById('persona-name').value = persona.name || '';
  document.getElementById('persona-description').value = persona.description || '';
  document.getElementById('persona-background').value = persona.background || '';
  document.getElementById('persona-speech-style').value = persona.speechStyle || '';

  showModal('persona-edit-modal');
}

// 保存 Persona
async function savePersona(){
  const id = document.getElementById('persona-edit-id').value;
  const avatar = document.getElementById('persona-avatar').value.trim() || '👤';
  const name = document.getElementById('persona-name').value.trim();
  const description = document.getElementById('persona-description').value.trim();
  const background = document.getElementById('persona-background').value.trim();
  const speechStyle = document.getElementById('persona-speech-style').value.trim();

  if(!name){
    toast(T('請輸入名稱'), 'warning');
    return;
  }

  const persona = {
    id: id || crypto.randomUUID(),
    name,
    avatar,
    description,
    background,
    speechStyle,
    createdAt: id ? undefined : Date.now(),
    updatedAt: Date.now()
  };

  await db.personas.put(persona);

  closeModal('persona-edit-modal');
  toast(id ? '身份已更新' : '身份已創建', 'success');
}

// 刪除 Persona
async function deletePersona(personaId){
  if(!confirm('確定刪除這個身份？')) return;

  await db.personas.delete(personaId);

  // 如果刪除的是當前 Persona，切換到默認
  if(currentPersona && currentPersona.id === personaId){
    await selectPersona('default');
  }

  await renderPersonaManagerList();
  toast(T('身份已刪除'), 'success');
}

// 構建 Persona Prompt
function buildPersonaPrompt(){
  if(!currentPersona || currentPersona.id === 'default') return '';

  let prompt = `\n\n【用戶身份設定】\n`;
  prompt += `用戶正在扮演「${currentPersona.name}」這個角色。\n`;

  if(currentPersona.description){
    prompt += `角色簡介：${currentPersona.description}\n`;
  }

  if(currentPersona.background){
    prompt += `角色背景：${currentPersona.background}\n`;
  }

  if(currentPersona.speechStyle){
    prompt += `說話風格：${currentPersona.speechStyle}\n`;
  }

  prompt += `\n注意事項：\n`;
  prompt += `- 你（AI）要用適當的方式稱呼用戶扮演的「${currentPersona.name}」\n`;
  prompt += `- 你（AI）不要扮演「${currentPersona.name}」，這是用戶的角色\n`;
  prompt += `- 根據「${currentPersona.name}」的身份背景來調整你的回應\n`;

  return prompt;
}

// ============ 簡繁轉換系統 ============

// 转换文本
function convertText(text, toSimplified){
  if(!text || typeof text !== 'string') return text;
  if(toSimplified && openccT2S){
    return openccT2S(text);
  } else if(!toSimplified && openccS2T){
    return openccS2T(text);
  }
  return text;
}

// 简化的翻译函数 - 用于动态生成的文字
function T(text){
  if(settings.uiLanguage === 'sc' && openccT2S){
    return openccT2S(text);
  }
  return text;
}

// 转换界面语言
function translateUI(){
  const isSimplified = settings.uiLanguage === 'sc';
  if(!openccT2S || !openccS2T) return;
  
  // 需要转换的元素选择器
  const selectors = [
    '.nav-title',
    '.list-nav-title', 
    '.tab-label',
    '.modal-title',
    '.form-label',
    '.settings-section-title',
    '.settings-item-label',
    '.modal-btn',
    '.btn',
    '.empty-text',
    '.empty-title',
    '.empty-desc',
    '.card-title',
    '.card-preview',
    '.settings-item-value',
    'option',
    'label',
    'button',
    '.lorebook-card-title',
    '.lorebook-card-triggers',
    '.player-panel-title',
    '.player-group-title',
    '.player-stat-label',
    '.inventory-item-name',
    '.inventory-item-category',
    '.inventory-item-desc',
    '.char-name',
    '.char-title',
    '.stat-label',
    // 新增选择器
    '.bottom-sheet-title',
    '.sheet-item-label',
    '.context-menu-item',
    '.modal-content',
    '.form-group label',
    '.script-step',
    '.script-tab',
    '.script-preview-tab',
    '.script-file-text',
    '.script-file-hint',
    '.script-analyzing-text',
    '.script-analyze-step',
    '.script-preview-header span',
    '.script-complete-title',
    '.script-complete-tip',
    '.script-optimization-title',
    'h3', 'h4',
    '.tip', '.hint', '.desc',
    // 角色列表空状态
    '.char-empty-title',
    '.char-empty-desc',
    // Persona相关
    '.persona-label',
    '.persona-name',
    // 其他
    '.action-btn',
    '.api-badge',
    '.lore-count span'
  ];
  
  // 遍历所有需要转换的元素
  selectors.forEach(selector => {
    document.querySelectorAll(selector).forEach(el => {
      // 跳过输入框
      if(el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') return;
      
      // 处理子节点文本
      el.childNodes.forEach(node => {
        if(node.nodeType === Node.TEXT_NODE && node.textContent.trim()){
          const converted = convertText(node.textContent, isSimplified);
          if(converted !== node.textContent){
            node.textContent = converted;
          }
        }
      });
    });
  });
  
  // 转换placeholder
  document.querySelectorAll('input[placeholder], textarea[placeholder]').forEach(el => {
    const placeholder = el.getAttribute('placeholder');
    if(placeholder){
      el.setAttribute('placeholder', convertText(placeholder, isSimplified));
    }
  });
  
  // 转换title属性
  document.querySelectorAll('[title]').forEach(el => {
    const title = el.getAttribute('title');
    if(title){
      el.setAttribute('title', convertText(title, isSimplified));
    }
  });
  
  // 更新页面标题
  document.title = convertText(document.title, isSimplified);
}

function showChineseConvertSettings(){
  document.getElementById('ui-language-mode').value = settings.uiLanguage || 'sc';
  document.getElementById('cn-convert-mode').value = settings.chineseConvert || 'follow';
  updateCnConvertPreview();
  showModal('cn-convert-modal');
}

function updateCnConvertPreview(){
  const uiLang = document.getElementById('ui-language-mode').value;
  const aiMode = document.getElementById('cn-convert-mode').value;
  const preview = document.getElementById('cn-convert-preview');
  
  let uiText = uiLang === 'sc' ? '简体中文' : '繁體中文';
  let aiText = '';
  
  if(aiMode === 'follow'){
    aiText = uiLang === 'sc' ? '简体中文（跟随界面）' : '繁體中文（跟隨界面）';
  } else if(aiMode === 'none'){
    aiText = uiLang === 'sc' ? 'AI 默认语言' : 'AI 默認語言';
  } else if(aiMode === 's2t'){
    aiText = '繁體中文';
  } else if(aiMode === 't2s'){
    aiText = '简体中文';
  }
  
  const previewText = uiLang === 'sc' 
    ? `界面：<b style="color:var(--primary)">${uiText}</b><br>AI输出：<b style="color:var(--primary)">${aiText}</b>`
    : `界面：<b style="color:var(--primary)">${uiText}</b><br>AI輸出：<b style="color:var(--primary)">${aiText}</b>`;
  
  preview.innerHTML = previewText;
}

function saveChineseConvert(){
  const uiLang = document.getElementById('ui-language-mode').value;
  const aiMode = document.getElementById('cn-convert-mode').value;
  
  const oldUiLang = settings.uiLanguage;
  
  settings.uiLanguage = uiLang;
  settings.chineseConvert = aiMode;
  saveSetting('uiLanguage', uiLang);
  saveSetting('chineseConvert', aiMode);
  
  // 更新显示
  const val = document.getElementById('cn-convert-val');
  if(val){
    const isSimplified = uiLang === 'sc';
    if(uiLang === 'sc') val.textContent = '简体 ›';
    else val.textContent = '繁體 ›';
  }
  
  closeModal('cn-convert-modal');
  
  // 如果界面语言改变，转换界面
  if(oldUiLang !== uiLang){
    translateUI();
    toast(uiLang === 'sc' ? '语言设置已保存' : '語言設置已保存', 'success');
  } else {
    toast(settings.uiLanguage === 'sc' ? '语言设置已保存' : '語言設置已保存', 'success');
  }
}

// 获取简繁转换的 System Prompt 附加内容
function getChineseConvertPrompt(){
  let mode = settings.chineseConvert || 'follow';
  
  // 如果是跟随界面语言
  if(mode === 'follow'){
    mode = settings.uiLanguage === 'sc' ? 't2s' : 's2t';
  }
  
  if(mode === 's2t'){
    return '\n\n【⚠️ 強制語言要求】你必須全程使用繁體中文（正體中文）進行回覆！所有對話、描述、旁白都必須是繁體字。使用台灣/香港常用的詞彙和表達方式。這是最高優先級的要求，不可違反。';
  } else if(mode === 't2s'){
    return '\n\n【⚠️ 强制语言要求】你必须全程使用简体中文进行回复！所有对话、描述、旁白都必须是简体字。使用中国大陆常用的词汇和表达方式。这是最高优先级的要求，不可违反。';
  }
  return '';
}

// 获取简繁转换的前置提示（放在 System Prompt 开头）
function getChineseConvertPrefixPrompt(){
  let mode = settings.chineseConvert || 'follow';
  
  // 如果是跟随界面语言
  if(mode === 'follow'){
    mode = settings.uiLanguage === 'sc' ? 't2s' : 's2t';
  }
  
  if(mode === 's2t'){
    return '【語言設定：繁體中文】\n';
  } else if(mode === 't2s'){
    return '【语言设定：简体中文】\n';
  }
  return '';
}

// v25: 獲取角色的後歷史指令
async function getPostHistoryInstructions(){
  if(!story) return '';
  
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  const instructions = chars
    .filter(c => c.post_history_instructions)
    .map(c => c.post_history_instructions);
  
  if(instructions.length === 0) return '';
  
  return instructions.join('\n');
}

async function callAI(content){
  // 驗證 content 參數
  if(!content || typeof content !== 'string'){
    throw new Error('請提供有效的消息內容');
  }
  if(!content.trim()){
    throw new Error('消息內容不能為空');
  }

  const preset=await db.apiPresets.filter(p=>p.isActive).first();
  if(!preset){throw new Error('請先配置並選擇一個 API 預設');}
  if(!preset.apiKey){throw new Error('API Key 未設置');}
  if(!preset.model){throw new Error('模型未設置');}
  console.log('Using API preset:', preset.name, preset.type, preset.model);

  // 構建基礎系統提示（v27: 传入用户输入以启用智能角色选择）
  let sysPrompt=await buildSysPrompt(content);

  // Lorebook 觸發系統
  const triggeredLorebook = await getTriggeredLorebook(content);
  if(triggeredLorebook.length > 0){
    sysPrompt += '\n\n### 相關設定（自動觸發）\n';

    // 收集所有需要更新的数据库操作（并行执行）
    const updatePromises = [];

    for(const entry of triggeredLorebook){
      if(entry.name && entry.content){
        sysPrompt += `\n#### ${entry.name}\n${entry.content}\n`;
      }

      // 更新觸發計數
      updatePromises.push(
        db.lorebook.update(entry.id, {
          triggerCount: (entry.triggerCount || 0) + 1,
          lastTriggered: Date.now()
        })
      );

      // 一次性觸發後禁用
      if(entry.oneTime){
        updatePromises.push(
          db.lorebook.update(entry.id, {isEnabled: false})
        );
      }
    }

    // 并行执行所有数据库更新
    await Promise.all(updatePromises).catch(err => {
      console.error('[Lorebook] 批量更新失敗:', err);
    });

    // 顯示觸發提示
    showLorebookTriggerToast(triggeredLorebook);
  }
  
  const contextCount = settings.contextCount || 20;

  // 使用智能上下文選擇
  const selectedMessages = selectSmartContext(msgs, contextCount, content);
  const messages = selectedMessages.map(m=>({role:m.role,content:m.content}));

  if(!messages.length||messages[messages.length-1].content!==content)messages.push({role:'user',content});
  
  // v25: 注入後歷史指令 (post_history_instructions)
  const postHistoryInstructions = await getPostHistoryInstructions();
  if(postHistoryInstructions){
    messages.push({
      role: 'user',
      content: `[系統指令：${postHistoryInstructions}]`
    });
  }
  
  if(preset.type==='anthropic')return await callAnthropic(preset,sysPrompt,messages);
  else if(preset.type==='openai')return await callOpenAI(preset,sysPrompt,messages);
  else return await callCustom(preset,sysPrompt,messages);
}
// 別名
async function callApi(content){ return await callAI(content); }

// 專用分析 API 調用（不注入故事 system prompt、Lorebook、角色設定）
async function callAIForAnalysis(userPrompt, systemPrompt){
  if(!userPrompt || !userPrompt.trim()) throw new Error('分析內容不能為空');
  const preset = await db.apiPresets.filter(p => p.isActive).first();
  if(!preset) throw new Error('請先配置並選擇一個 API 預設');
  if(!preset.apiKey) throw new Error('API Key 未設置');
  if(!preset.model) throw new Error('模型未設置');

  const sys = systemPrompt || '你是一個專業的故事內容分析助手。你的任務是從角色扮演對話記錄中精確提取結構化資訊。請積極識別內容，寧可多提取讓用戶篩選，也不要遺漏重要資訊。務必嚴格按照要求的 JSON 格式返回結果，不要添加任何額外文字。';
  const messages = [{ role: 'user', content: userPrompt }];

  console.log('[Analysis API] Using preset:', preset.name, preset.type, preset.model);

  // 分析任務使用低 temperature 和較高 maxTokens，暫時覆蓋設定
  const origTemp = settings.temperature;
  const origTopP = settings.topP;
  const origMaxTokens = settings.maxTokens;
  const origStoryCustom = story?.aiParams?.useCustom;
  settings.temperature = 0.3;
  settings.topP = 0.95;
  settings.maxTokens = Math.max(settings.maxTokens || 4096, 8000);
  if(story?.aiParams) story.aiParams.useCustom = false;

  try {
    if(preset.type === 'anthropic') return await callAnthropic(preset, sys, messages);
    else if(preset.type === 'openai') return await callOpenAI(preset, sys, messages);
    else return await callCustom(preset, sys, messages);
  } finally {
    // 還原設定
    settings.temperature = origTemp;
    settings.topP = origTopP;
    settings.maxTokens = origMaxTokens;
    if(story?.aiParams) story.aiParams.useCustom = origStoryCustom;
  }
}

async function callAnthropic(p,sys,msgs){
  const aiParams = getAIParams();
  console.log('Calling Anthropic API with model:', p.model, 'temp:', aiParams.temperature, '(story custom:', story?.aiParams?.useCustom || false, ')');
  let r;
  try {
    r = await fetch('https://api.anthropic.com/v1/messages',{
      method:'POST',
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache',
      headers:{
        'Content-Type':'application/json',
        'x-api-key':p.apiKey,
        'anthropic-version':'2023-06-01',
        'anthropic-dangerous-direct-browser-access':'true'
      },
      body:JSON.stringify({
        model:p.model,
        max_tokens:settings.maxTokens||4096,
        system:[{type:"text",text:sys}],
        messages:msgs,
        temperature: aiParams.temperature,
        top_p: aiParams.topP
      })
    });
  } catch(e) {
    console.error('Fetch error:', e);
    const errMsg = e.message || e.toString() || '';
    if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch')) {
      throw new Error('網絡錯誤 - 請檢查網絡連接或 API 服務狀態');
    }
    throw new Error('網絡請求失敗: ' + errMsg);
  }
  
  const text = await r.text();
  console.log('API Response status:', r.status, 'body:', text.slice(0, 500));
  
  if(!r.ok){
    try {
      const e = JSON.parse(text);
      const errMsg = e.error?.message || '';
      // 詳細的錯誤分類
      if(r.status === 401 || errMsg.includes('invalid_api_key') || errMsg.includes('authentication')){
        throw new Error('API Key 無效或已過期，請檢查設置');
      } else if(r.status === 429 || errMsg.includes('rate_limit')){
        throw new Error('API 調用頻率過高，請稍後再試');
      } else if(r.status === 400 || errMsg.includes('invalid_request')){
        throw new Error('請求格式錯誤: ' + errMsg);
      } else if(r.status === 500 || r.status === 502 || r.status === 503){
        throw new Error('API 服務暫時不可用，請稍後再試');
      }
      throw new Error(errMsg || `API錯誤 (${r.status})`);
    } catch(parseErr) {
      if(parseErr.message.includes('API') || parseErr.message.includes('無效') || parseErr.message.includes('過期') || parseErr.message.includes('頻率')) throw parseErr;
      throw new Error(`API錯誤 (${r.status}): ${text.slice(0, 200)}`);
    }
  }
  
  try {
    const d = JSON.parse(text);
    if(!d.content || !d.content[0]){throw new Error('API返回格式錯誤');}
    return {content: d.content[0].text, tokens: d.usage?.output_tokens || 0};
  } catch(parseErr) {
    if(parseErr.message.includes('API')) throw parseErr;
    console.error('JSON parse error:', parseErr, 'Response:', text);
    throw new Error('JSON解析失敗，API返回: ' + text.slice(0, 100));
  }
}
async function callOpenAI(p,sys,msgs){
  const aiParams = getAIParams();
  console.log('Calling OpenAI API with model:', p.model, 'temp:', aiParams.temperature, '(story custom:', story?.aiParams?.useCustom || false, ')');
  const allMsgs=[{role:'system',content:sys},...msgs];
  let r;
  try {
    r = await fetch('https://api.openai.com/v1/chat/completions',{
      method:'POST',
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${p.apiKey}`
      },
      body:JSON.stringify({
        model:p.model,
        messages:allMsgs,
        max_tokens:settings.maxTokens||4096,
        temperature: aiParams.temperature,
        top_p: aiParams.topP
      })
    });
  } catch(e) {
    console.error('Fetch error:', e);
    const errMsg = e.message || e.toString() || '';
    if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch')) {
      throw new Error('網絡錯誤 - 請檢查網絡連接或 API 服務狀態');
    }
    throw new Error('網絡請求失敗: ' + errMsg);
  }
  
  const text = await r.text();
  console.log('API Response status:', r.status, 'body:', text.slice(0, 500));
  
  if(!r.ok){
    try {
      const e = JSON.parse(text);
      const errMsg = e.error?.message || '';
      // 詳細的錯誤分類
      if(r.status === 401 || errMsg.includes('invalid_api_key') || errMsg.includes('Incorrect API')){
        throw new Error('API Key 無效或已過期，請檢查設置');
      } else if(r.status === 429 || errMsg.includes('rate_limit') || errMsg.includes('quota')){
        throw new Error('API 配額已用完或調用頻率過高');
      } else if(r.status === 400){
        throw new Error('請求格式錯誤: ' + errMsg);
      } else if(r.status === 500 || r.status === 502 || r.status === 503){
        throw new Error('API 服務暫時不可用，請稍後再試');
      }
      throw new Error(errMsg || `API錯誤 (${r.status})`);
    } catch(parseErr) {
      if(parseErr.message.includes('API') || parseErr.message.includes('無效') || parseErr.message.includes('配額')) throw parseErr;
      throw new Error(`API錯誤 (${r.status}): ${text.slice(0, 200)}`);
    }
  }
  
  try {
    const d = JSON.parse(text);
    if(!d.choices || !d.choices[0]){throw new Error('API返回格式錯誤');}
    return {content: d.choices[0].message.content, tokens: d.usage?.completion_tokens || 0};
  } catch(parseErr) {
    if(parseErr.message.includes('API')) throw parseErr;
    console.error('JSON parse error:', parseErr, 'Response:', text);
    throw new Error('JSON解析失敗，API返回: ' + text.slice(0, 100));
  }
}
// 自動補全 API URL 路徑
function normalizeApiUrl(url, autoComplete = true, model = '') {
  if(!url) return url;
  url = url.trim();
  // 自動添加 https:// 協議
  if(!url.startsWith('http://') && !url.startsWith('https://')) {
    url = 'https://' + url;
  }
  // 移除尾部斜線
  url = url.replace(/\/+$/, '');

  // 如果不自動補全，直接返回
  if(!autoComplete) return url;

  // 如果已經包含完整路徑，直接返回
  if(url.includes('/v1/chat/completions') || url.includes('/v1/messages')) {
    return url;
  }

  // 智能判斷：如果 model 包含 claude，使用 Anthropic 格式
  const isClaudeModel = model && (model.toLowerCase().includes('claude') || model.toLowerCase().includes('sonnet') || model.toLowerCase().includes('opus') || model.toLowerCase().includes('haiku'));

  // 如果只是基礎 URL，根據模型類型自動補全路徑
  if(url.endsWith('/v1')) {
    return isClaudeModel ? url + '/messages' : url + '/chat/completions';
  }
  // 否則補全完整路徑
  return isClaudeModel ? url + '/v1/messages' : url + '/v1/chat/completions';
}

async function callCustom(p,sys,msgs){
  const autoComplete = p.urlAutoComplete !== false; // 默認為 true
  const apiUrl = normalizeApiUrl(p.url || p.baseUrl, autoComplete, p.model);
  const aiParams = getAIParams();
  console.log('Calling Custom API:', p.url || p.baseUrl, '→', apiUrl, '(autoComplete:', autoComplete, ') model:', p.model, 'temp:', aiParams.temperature, '(story custom:', story?.aiParams?.useCustom || false, ')');
  if(!apiUrl){throw new Error('自定義 API URL 未設置');}

  // 智能判斷格式：如果 URL 包含 /messages，使用 Anthropic 格式，否則使用 OpenAI 格式
  const isAnthropicFormat = apiUrl.includes('/messages') || apiUrl.includes('/anthropic');

  let requestBody;
  let headers = {
    'Content-Type':'application/json',
    'Authorization':`Bearer ${p.apiKey}`
  };

  if(isAnthropicFormat){
    // Anthropic 格式：system 作為單獨參數
    console.log('Using Anthropic format for custom API');
    headers['anthropic-version'] = '2023-06-01';
    requestBody = {
      model: p.model,
      system: [{type:"text",text:sys}],
      messages: msgs,
      max_tokens: settings.maxTokens || 4096,
      temperature: aiParams.temperature,
      top_p: aiParams.topP
    };
  } else {
    // OpenAI 格式：system 放在 messages 數組的第一個
    console.log('Using OpenAI format for custom API');
    const allMsgs = [];
    if(sys) {
      allMsgs.push({role: 'system', content: sys});
    }
    allMsgs.push(...msgs);
    requestBody = {
      model: p.model,
      messages: allMsgs,
      max_tokens: settings.maxTokens || 4096,
      temperature: aiParams.temperature,
      top_p: aiParams.topP
    };
  }

  // 創建超時控制（5分鐘）
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 300000);

  let r;
  try {
    r = await fetch(apiUrl,{
      method:'POST',
      signal: controller.signal,
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache',
      headers: headers,
      body:JSON.stringify(requestBody)
    });
  } catch(e) {
    console.error('Fetch error:', e);
    const errMsg = e.message || e.toString() || '';
    if(e.name === 'AbortError') {
      throw new Error('請求超時（5分鐘）- 請檢查網絡連接');
    } else if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch') || errMsg.includes('NetworkError')) {
      throw new Error('網絡錯誤 - API 服務可能不支持瀏覽器直接調用（CORS），請確認 API 已開啟跨域支持');
    }
    throw new Error('網絡請求失敗: ' + errMsg);
  } finally {
    clearTimeout(timeoutId);
  }
  
  const text = await r.text();
  console.log('API Response status:', r.status, 'body:', text.slice(0, 500));
  
  if(!r.ok){
    try {
      const e = JSON.parse(text);
      throw new Error(e.error?.message || `API錯誤 (${r.status})`);
    } catch(parseErr) {
      if(parseErr.message.includes('API錯誤')) throw parseErr;
      throw new Error(`API錯誤 (${r.status}): ${text.slice(0, 200)}`);
    }
  }
  
  try {
    const d = JSON.parse(text);
    let content, tokens;

    // 嘗試解析不同格式的返回值
    if(isAnthropicFormat){
      // Anthropic 格式：d.content[0].text
      content = d.content?.[0]?.text || d.choices?.[0]?.message?.content || d.response || d.text || '';
      tokens = d.usage?.output_tokens || d.usage?.completion_tokens || 0;
    } else {
      // OpenAI 格式：d.choices[0].message.content
      content = d.choices?.[0]?.message?.content || d.content?.[0]?.text || d.response || d.text || '';
      tokens = d.usage?.completion_tokens || d.usage?.output_tokens || 0;
    }

    if(!content){throw new Error('API返回內容為空');}
    return {content, tokens};
  } catch(parseErr) {
    console.error('JSON parse error:', parseErr, 'Response:', text);
    throw new Error('JSON解析失敗，API返回: ' + text.slice(0, 100));
  }
}

// ============================================
// 流式響應 API 調用
// ============================================
let streamAbortController = null;

async function callAnthropicStream(p, sys, msgs, onChunk, onDone, onError) {
  const aiParams = getAIParams();
  console.log('Calling Anthropic API (STREAM) with model:', p.model, 'temp:', aiParams.temperature);

  // 清理旧的controller，防止竞态条件
  if(streamAbortController) {
    streamAbortController.abort();
    streamAbortController = null;
  }

  streamAbortController = new AbortController();
  let r;

  try {
    r = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache',
      signal: streamAbortController.signal,
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': p.apiKey,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: p.model,
        max_tokens: settings.maxTokens || 4096,
        system: [{type:"text",text:sys}],
        messages: msgs,
        temperature: aiParams.temperature,
        top_p: aiParams.topP,
        stream: true
      })
    });
  } catch(e) {
    console.error('Fetch error:', e);
    if(e.name === 'AbortError') {
      throw new Error('已停止生成');
    }
    const errMsg = e.message || e.toString() || '';
    if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch')) {
      throw new Error('網絡錯誤 - 請檢查網絡連接或 API 服務狀態');
    }
    throw new Error('網絡請求失敗: ' + errMsg);
  }

  if(!r.ok) {
    const text = await r.text();
    console.error('API Response error:', r.status, text);
    try {
      const e = JSON.parse(text);
      const errMsg = e.error?.message || '';
      if(r.status === 401 || errMsg.includes('invalid_api_key')) {
        throw new Error('API Key 無效或已過期，請檢查設置');
      } else if(r.status === 429) {
        throw new Error('API 調用頻率過高，請稍後再試');
      }
      throw new Error(errMsg || `API錯誤 (${r.status})`);
    } catch(parseErr) {
      if(parseErr.message.includes('API')) throw parseErr;
      throw new Error(`API錯誤 (${r.status}): ${text.slice(0, 200)}`);
    }
  }

  const reader = r.body.getReader();
  const decoder = new TextDecoder();
  let fullContent = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            if (parsed.type === 'content_block_delta') {
              const text = parsed.delta?.text || '';
              if (text) {
                fullContent += text;
                if (onChunk) await onChunk(text, fullContent);
              }
            } else if (parsed.type === 'error') {
              throw new Error(parsed.error?.message || 'Stream error');
            }
          } catch (e) {
            if (e.message.includes('Stream error')) throw e;
            // 忽略 JSON 解析錯誤，繼續處理下一行
          }
        }
      }
    }
  } catch (e) {
    if (e.name === 'AbortError' || e.message === '已停止生成') {
      if (onError) onError(e, fullContent);
      return { content: fullContent, stopped: true };
    }
    if (onError) onError(e, fullContent);
    throw e;
  }

  if (onDone) onDone(fullContent);
  return { content: fullContent, tokens: 0 };
}

async function callOpenAIStream(p, sys, msgs, onChunk, onDone, onError) {
  const aiParams = getAIParams();
  console.log('Calling OpenAI API (STREAM) with model:', p.model, 'temp:', aiParams.temperature);

  const allMsgs = [{ role: 'system', content: sys }, ...msgs];

  // 清理旧的controller，防止竞态条件
  if(streamAbortController) {
    streamAbortController.abort();
    streamAbortController = null;
  }

  streamAbortController = new AbortController();
  let r;

  try {
    r = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache',
      signal: streamAbortController.signal,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${p.apiKey}`
      },
      body: JSON.stringify({
        model: p.model,
        messages: allMsgs,
        max_tokens: settings.maxTokens || 4096,
        temperature: aiParams.temperature,
        top_p: aiParams.topP,
        stream: true
      })
    });
  } catch(e) {
    console.error('Fetch error:', e);
    if(e.name === 'AbortError') {
      throw new Error('已停止生成');
    }
    const errMsg = e.message || e.toString() || '';
    if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch')) {
      throw new Error('網絡錯誤 - 請檢查網絡連接或 API 服務狀態');
    }
    throw new Error('網絡請求失敗: ' + errMsg);
  }

  if(!r.ok) {
    const text = await r.text();
    console.error('API Response error:', r.status, text);
    try {
      const e = JSON.parse(text);
      const errMsg = e.error?.message || '';
      if(r.status === 401) {
        throw new Error('API Key 無效或已過期，請檢查設置');
      } else if(r.status === 429) {
        throw new Error('API 配額已用完或調用頻率過高');
      }
      throw new Error(errMsg || `API錯誤 (${r.status})`);
    } catch(parseErr) {
      if(parseErr.message.includes('API')) throw parseErr;
      throw new Error(`API錯誤 (${r.status}): ${text.slice(0, 200)}`);
    }
  }

  const reader = r.body.getReader();
  const decoder = new TextDecoder();
  let fullContent = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            const text = parsed.choices?.[0]?.delta?.content || '';
            if (text) {
              fullContent += text;
              if (onChunk) await onChunk(text, fullContent);
            }
          } catch (e) {
            // 忽略 JSON 解析錯誤
          }
        }
      }
    }
  } catch (e) {
    if (e.name === 'AbortError' || e.message === '已停止生成') {
      if (onError) onError(e, fullContent);
      return { content: fullContent, stopped: true };
    }
    if (onError) onError(e, fullContent);
    throw e;
  }

  if (onDone) onDone(fullContent);
  return { content: fullContent, tokens: 0 };
}

async function callCustomStream(p, sys, msgs, onChunk, onDone, onError) {
  const autoComplete = p.urlAutoComplete !== false;
  const apiUrl = normalizeApiUrl(p.url || p.baseUrl, autoComplete, p.model);
  const aiParams = getAIParams();
  console.log('Calling Custom API (STREAM):', apiUrl, 'model:', p.model);

  // 智能判斷格式：如果 URL 包含 /messages，使用 Anthropic 格式，否則使用 OpenAI 格式
  const isAnthropicFormat = apiUrl.includes('/messages') || apiUrl.includes('/anthropic');

  let requestBody;
  let headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${p.apiKey}`
  };

  if(isAnthropicFormat){
    // Anthropic 格式：system 作為單獨參數
    console.log('Using Anthropic format for custom API (STREAM)');
    headers['anthropic-version'] = '2023-06-01';
    requestBody = {
      model: p.model,
      system: [{type:"text",text:sys}],
      messages: msgs,
      max_tokens: settings.maxTokens || 4096,
      temperature: aiParams.temperature,
      stream: true
    };
  } else {
    // OpenAI 格式：system 放在 messages 數組的第一個
    console.log('Using OpenAI format for custom API (STREAM)');
    const allMsgs = [];
    if(sys) allMsgs.push({role: 'system', content: sys});
    allMsgs.push(...msgs);
    requestBody = {
      model: p.model,
      messages: allMsgs,
      max_tokens: settings.maxTokens || 4096,
      temperature: aiParams.temperature,
      stream: true
    };
  }

  // 清理旧的controller，防止竞态条件
  if(streamAbortController) {
    streamAbortController.abort();
    streamAbortController = null;
  }

  streamAbortController = new AbortController();
  const timeoutId = setTimeout(() => streamAbortController.abort(), 300000);
  let r;

  try {
    r = await fetch(apiUrl, {
      method: 'POST',
      signal: streamAbortController.signal,
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache',
      headers: headers,
      body: JSON.stringify(requestBody)
    });
  } catch(e) {
    console.error('Fetch error:', e);
    if(e.name === 'AbortError') {
      throw new Error('已停止生成');
    }
    const errMsg = e.message || e.toString() || '';
    if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch')) {
      throw new Error('網絡錯誤 - API 服務可能不支持瀏覽器直接調用（CORS）');
    }
    throw new Error('網絡請求失敗: ' + errMsg);
  } finally {
    clearTimeout(timeoutId);
  }

  if(!r.ok) {
    const text = await r.text();
    console.error('API Response error:', r.status, text);
    try {
      const e = JSON.parse(text);
      throw new Error(e.error?.message || `API錯誤 (${r.status})`);
    } catch(parseErr) {
      if(parseErr.message.includes('API錯誤')) throw parseErr;
      throw new Error(`API錯誤 (${r.status}): ${text.slice(0, 200)}`);
    }
  }

  const reader = r.body.getReader();
  const decoder = new TextDecoder();
  let fullContent = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            let text = '';

            if(isAnthropicFormat){
              // Anthropic 格式：parsed.delta?.text
              text = parsed.delta?.text || '';
            } else {
              // OpenAI 格式：parsed.choices[0].delta.content
              text = parsed.choices?.[0]?.delta?.content || '';
            }

            if (text) {
              fullContent += text;
              if (onChunk) await onChunk(text, fullContent);
            }
          } catch (e) {
            // 忽略 JSON 解析錯誤
          }
        }
      }
    }
  } catch (e) {
    if (e.name === 'AbortError' || e.message === '已停止生成') {
      if (onError) onError(e, fullContent);
      return { content: fullContent, stopped: true };
    }
    if (onError) onError(e, fullContent);
    throw e;
  }

  if (onDone) onDone(fullContent);
  return { content: fullContent, tokens: 0 };
}

function stopStreaming() {
  if (streamAbortController) {
    streamAbortController.abort();
    streamAbortController = null;
  }
}

// ============ 智能角色選擇 ============
/**
 * 智能選擇應該發送給 AI 的角色
 * 只選擇最近出場的角色，避免每次都發送所有角色消耗 tokens
 * @param {Array} allCharacters - 所有角色列表
 * @param {string} userInput - 用户输入内容（可选）
 * @returns {Array} 選中的角色列表
 */
async function selectRelevantCharacters(allCharacters, userInput = '') {
  // 如果禁用智能選擇，返回所有角色
  if (!settings.smartCharacterSelection) {
    return allCharacters;
  }

  const relevantChars = new Set();
  const recentMessageCount = settings.characterRecentMessages || 20;

  // 1. 查找最近N條消息中提到的角色名
  const recentMessages = msgs.slice(-recentMessageCount);

  for (const msg of recentMessages) {
    const content = msg.content || '';
    // 检查每个角色名是否在消息中出现
    allCharacters.forEach(char => {
      if (content.includes(char.name)) {
        relevantChars.add(char.id);
      }
    });
  }

  // 2. 检查用户当前输入中是否提到某个角色
  if (userInput) {
    allCharacters.forEach(char => {
      if (userInput.includes(char.name)) {
        relevantChars.add(char.id);
      }
    });
  }

  // 3. 总是包含主要角色（有特殊标记的角色，如: isMainCharacter, isPinned, 或 category='main'）
  if (settings.alwaysIncludeMainCharacters) {
    allCharacters.forEach(char => {
      if (char.isMainCharacter || char.isPinned || char.category === 'main' || char.category === '主要') {
        relevantChars.add(char.id);
      }
    });
  }

  // 4. 如果筛选结果为空（比如刚开始对话），返回所有角色
  if (relevantChars.size === 0) {
    console.log('智能角色选择：未找到相关角色，返回所有角色');
    return allCharacters;
  }

  // 5. 返回选中的角色
  const selectedChars = allCharacters.filter(char => relevantChars.has(char.id));

  console.log(`智能角色选择：从 ${allCharacters.length} 个角色中选择了 ${selectedChars.length} 个相关角色`);
  console.log('选中的角色:', selectedChars.map(c => c.name).join(', '));

  return selectedChars;
}

async function buildSysPrompt(userInput = ''){
  if(!story)return'';
  let p='';

  // v22: 簡繁轉換前置提示
  p += getChineseConvertPrefixPrompt();

  const bindings=await db.storyInstructions.where('storyId').equals(story.id).toArray();
  for(const b of bindings){
    const i=await db.instructions.get(b.instructionId);
    if(i && i.content){
      p+=i.content+'\n\n';
    }
  }
  
  // v18: 添加記憶摘要（修復：之前摘要沒有被使用）
  if(story.summaries && story.summaries.length > 0){
    p+='\n### 📚 故事前情摘要\n';
    p+='以下是之前劇情的重要摘要，請參考這些信息保持故事連貫性：\n\n';
    // 按時間順序添加摘要
    story.summaries.forEach((s, idx) => {
      if(s && s.content){
        p+=`**【記憶片段 ${idx + 1}】**\n${s.content}\n\n`;
      }
    });
    p+='---\n\n';
  }
  
  // v22: 添加滾動摘要
  if(story.rollingSummaries && story.rollingSummaries.length > 0){
    p+='\n### 📜 故事背景摘要\n';
    p+='以下是最近劇情的背景摘要，請參考：\n\n';
    story.rollingSummaries.forEach((s, idx) => {
      if(s && s.content){
        p+=`**【背景 ${idx + 1}】** ${s.content}\n\n`;
      }
    });
    p+='---\n\n';
  }

  // 重要記憶 - 優先展示用戶標記的重要消息
  const importantMsgs = msgs.filter(m => m.isImportant);
  if(importantMsgs.length > 0){
    p+='\n### ⭐ 重要記憶\n';
    p+='以下是玩家標記為重要的劇情片段，請特別注意這些內容：\n\n';
    importantMsgs.forEach((m, idx) => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      const content = m.content.slice(0, 300); // 限制長度
      p+=`**${idx + 1}. ${role}** ${content}${m.content.length > 300 ? '...' : ''}\n\n`;
    });
    p+='---\n\n';
  }

  const lore=await db.loreEntries.where('storyId').equals(story.id).filter(e=>e.isSelected).toArray();
  if(lore.length){
    p+='\n### 參考資料\n';
    for(const e of lore){
      if(e.name && e.content){
        p+=`\n#### ${e.name}\n${e.content}\n`;
      }
    }
  }
  if(story.storyTime)p+=`\n### 當前時間\n${story.storyTime}\n`;

  // 伏筆信息（優化版）
  const fs=await db.foreshadowing.where('storyId').equals(story.id).filter(f=>!f.isResolved).toArray();
  if(fs.length){
    p+='\n### 📌 待回收伏筆\n';
    p+='以下是需要注意回收的伏筆，請在合適的時機自然地回收這些伏筆：\n\n';

    // 按優先級排序
    const sortedFs=fs.sort((a,b)=>{
      const priorityOrder={urgent:0,high:1,medium:2,low:3};
      const pa=priorityOrder[a.priority||'medium'];
      const pb=priorityOrder[b.priority||'medium'];
      return pa-pb;
    });

    sortedFs.forEach(f=>{
      if(f.title){
        // 優先級圖標
        const priorityIcon={urgent:'🔴',high:'🟠',medium:'🟡',low:'🟢'}[f.priority||'medium'];
        const priorityText={urgent:'緊急',high:'高',medium:'中',low:'低'}[f.priority||'medium'];

        // 緊急度提示
        const urgency=calculateForeshadowUrgency(f);
        const urgencyHint=urgency==='critical'?'⚠️ 非常緊急！':urgency==='warning'?'⚠️ 需要儘快回收':urgency==='notice'?'💡 即將到期':'';

        p+=`- 【${priorityIcon}${priorityText}】${f.title}`;
        if(f.description){
          p+=`：${f.description}`;
        }
        p+=`（已過${f.mentionCount||0}條對話）`;
        if(urgencyHint){
          p+=` ${urgencyHint}`;
        }
        p+='\n';

        // 添加標籤
        if(f.tags&&f.tags.length>0){
          p+=`  標籤：${f.tags.join('、')}\n`;
        }

        // 添加回收計劃（如果有）
        if(f.plan){
          const planPreview=f.plan.slice(0,100);
          p+=`  回收提示：${planPreview}${f.plan.length>100?'...':''}\n`;
        }

        p+='\n';
      }
    });

    p+='💡 提示：請根據當前劇情自然地回收這些伏筆，不要生硬或突兀。\n';
  }
  // 添加一致性修復提示
  if(story.consistencyNote){
    p+='\n### 一致性修復提示\n'+story.consistencyNote+'\n';
    // 增加使用計數
    const fixCount = (story.consistencyFixCount || 0) + 1;
    const fixMax = story.consistencyFixMax || 1;

    if(fixCount >= fixMax){
      // 達到最大次數，清除提示
      await db.stories.update(story.id,{
        consistencyNote:null,
        consistencyFixCount:0,
        consistencyFixMax:null
      });
      story.consistencyNote=null;
      story.consistencyFixCount=0;
      story.consistencyFixMax=null;
    } else {
      // 更新計數器
      await db.stories.update(story.id,{consistencyFixCount:fixCount});
      story.consistencyFixCount=fixCount;
    }
    // 更新提示條顯示（延遲執行，避免阻塞）
    setTimeout(() => updateConsistencyFixBanner(), 100);
  }
  
  // v21: 雙軌並行 - 經營模式也支持角色系統
  const isSimMode = story.mode === 'simulation';

  // 1. 角色狀態信息（所有模式都發送）
  const allChars=await db.characters.where('storyId').equals(story.id).toArray();
  // v27: 智能角色選擇 - 只發送相關角色，節省 tokens
  const chars = await selectRelevantCharacters(allChars, userInput);
  if(chars.length){
    // v25: 注入角色專屬系統提示詞
    const charSystemPrompts = chars.filter(c => c.system_prompt).map(c => c.system_prompt);
    if(charSystemPrompts.length){
      p+='\n### 🎭 角色專屬指令\n';
      p+=charSystemPrompts.join('\n\n');
      p+='\n\n';
    }
    
    p+='\n### 當前角色狀態\n';
    p+='以下是當前已知角色的狀態，請在回覆中保持角色行為與其性格、屬性一致：\n\n';
    chars.forEach(c=>{
      p+=`**${c.name}**`;
      if(c.title)p+=`（${c.title}）`;
      p+='\n';
      // v25: 添加性格摘要
      if(c.personality)p+=`- 性格：${c.personality}\n`;
      if(c.description)p+=`- 簡介：${c.description}\n`;
      // v25: 添加場景描述
      if(c.scenario)p+=`- 場景：${c.scenario}\n`;
      if(c.stats&&Object.keys(c.stats).length){
        p+=`- 屬性：${Object.entries(c.stats).map(([k,v])=>`${k}:${v}`).join('、')}\n`;
      }
      if(c.tags&&c.tags.length){
        p+=`- 特徵：${c.tags.join('、')}\n`;
      }
      p+='\n';
    });
    
    // v25: 注入角色關係信息
    const charsWithRelations = chars.filter(c => c.relationships && c.relationships.length > 0);
    if(charsWithRelations.length){
      p+='\n### 👥 角色關係\n';
      charsWithRelations.forEach(c => {
        c.relationships.forEach(rel => {
          p+=`- ${c.name} → ${rel.targetName || '某人'}：${rel.label || rel.type}`;
          if(rel.description) p+=`（${rel.description}）`;
          p+='\n';
        });
      });
      p+='\n';
    }
    
    // v25: 注入對話示例
    const charsWithExamples = chars.filter(c => c.mes_example);
    if(charsWithExamples.length){
      p+='\n### 💬 對話示例\n';
      p+='以下是角色的對話風格示例，請參考這些示例來模仿角色的說話方式：\n\n';
      charsWithExamples.forEach(c => {
        p+=`**${c.name} 的對話風格：**\n`;
        p+=c.mes_example.replace(/<START>/g, '\n---\n');
        p+='\n\n';
      });
    }
  }
  
  // v24: 先獲取玩家狀態面板（需要在後面使用）
  const playerPanel = await db.playerPanels.where('storyId').equals(story.id).first();

  // 2. 經營模式：添加資源狀態
  if(isSimMode){
    if(story.simResources && story.simResources.length > 0){
      p+='\n### 📊 當前資源狀態（第 ' + (story.simDay || 1) + ' 天）\n';
      story.simResources.forEach(r => {
        p+=`${r.icon} ${r.name}：${r.value.toLocaleString()}\n`;
      });
      p+='\n請在回覆中維持這些數據的合理性，如有變化可在回覆中自然說明。\n';
    }
  }

  // 3. 所有模式：強制要求 JSON 格式輸出角色狀態
  const hasPlayerPanel = playerPanel && playerPanel.attributes && playerPanel.attributes.length > 0;
  p+=`\n### ⚠️ 狀態輸出格式（必須遵守）
**重要：每次回覆都必須在劇情內容之後，用以下 JSON 格式輸出角色狀態。這是強制要求，不可省略。**

\`\`\`json
{
  "characters": [
    {
      "name": "角色名",
      "title": "身份/稱號",
      "location": "當前位置",
      "stats": {
        "表面好感": 0-100,
        "真實好感": 0-100,
        "其他屬性": 數值
      },
      "mood": "當前情緒",
      "note": "簡短備註"
    }
  ]${hasPlayerPanel ? `,
  "player": {
    "stats": {
      "屬性名": 數值
    },
    "note": "玩家狀態備註（可選）"
  }` : ''},
  "time": {
    "changed": true/false,
    "newTime": "新的時間描述（如：第二天早上、三天後、一月十日）"
  }
}
\`\`\`

**必須遵守的規則：**
- 每次回覆都必須輸出 JSON，即使狀態沒有變化
- 只輸出本次互動中出現的角色（即使狀態未變也要輸出）
- 如果本次沒有任何角色出現，返回空數組：{"characters": []}
- 數值用 0-100 表示${hasPlayerPanel ? '\n- 玩家狀態有變化時才輸出 player 字段，沒變化則省略 player' : ''}
- time 字段：如果劇情中時間發生變化（如過了一天、到了晚上等），設 changed 為 true 並填寫 newTime；如果時間沒變化，設 changed 為 false 或省略 time 字段
- JSON 必須放在回覆的最後，用 \`\`\`json 和 \`\`\` 包裹
- 絕對不可以省略 JSON 輸出，這是系統運作的必要部分
`;

  // v24: 添加玩家狀態面板（已在前面獲取）
  if(playerPanel && playerPanel.attributes && playerPanel.attributes.length > 0){
    p += `\n### 👤 玩家狀態（${playerPanel.name || '主角'}）\n`;
    p += '以下是玩家/主角的當前狀態，請在回覆中參考這些數值：\n\n';
    
    // 按分組整理屬性
    const groups = {};
    playerPanel.attributes.forEach(attr => {
      const group = attr.group || '基礎屬性';
      if(!groups[group]) groups[group] = [];
      groups[group].push(attr);
    });
    
    for(const [groupName, attrs] of Object.entries(groups)){
      p += `**【${groupName}】**\n`;
      attrs.forEach(attr => {
        // 從 values 對象中獲取當前值，如果沒有則使用默認值
        const currentValue = playerPanel.values?.[attr.name] ?? attr.defaultValue ?? 0;
        let valueStr = '';
        if(attr.type === 'percent'){
          valueStr = `${currentValue}%`;
        } else if(attr.type === 'number'){
          valueStr = `${currentValue}`;
        } else {
          valueStr = currentValue;
        }
        p += `- ${attr.icon || '•'} ${attr.name}：${valueStr}\n`;
      });
      p += '\n';
    }
  }
  
  // v24: 添加財產資產
  if(story.inventory && story.inventory.length > 0){
    p += '\n### 💰 財產清單\n';
    p += '以下是玩家目前擁有的財產，請在劇情中合理運用這些資產：\n\n';

    // 按分類整理資產
    const categories = {
      'money': '💰 金錢',
      'property': '🏠 房產',
      'vehicle': '🚗 載具',
      'valuable': '💎 貴重物品',
      'other': '📋 其他'
    };

    const locationNames = {
      'on_person': '身上',
      'home': '家中',
      'bank': '銀行',
      'warehouse': '倉庫',
      'other_location': '其他地點'
    };

    const itemsByCategory = {};
    story.inventory.forEach(item => {
      const cat = item.category || 'other';
      if(!itemsByCategory[cat]) itemsByCategory[cat] = [];
      itemsByCategory[cat].push(item);
    });

    for(const [catKey, catName] of Object.entries(categories)){
      const items = itemsByCategory[catKey];
      if(items && items.length > 0){
        p += `**${catName}**\n`;
        items.forEach(item => {
          p += `- ${item.icon || '•'} ${item.name}`;
          if(item.quantity && item.quantity > 1) p += ` ×${item.quantity}`;
          if(item.location) p += `【${locationNames[item.location] || '其他'}】`;
          if(item.description) p += `（${item.description}）`;
          p += '\n';
        });
        p += '\n';
      }
    }
  }

  // v25: 添加行程安排
  if(story.schedule && story.schedule.length > 0){
    const pendingSchedule = story.schedule.filter(s => s.status !== 'completed');
    if(pendingSchedule.length > 0){
      p += '\n### 📋 行程安排\n';
      p += '以下是玩家目前的行程安排，請在劇情中適時提醒或推進這些行程：\n\n';

      const statusNames = { pending: '⏳ 待辦', in_progress: '🔄 進行中' };

      pendingSchedule.forEach(item => {
        p += `- ${statusNames[item.status] || '⏳ 待辦'} **${item.datetime}**：${item.event}`;
        if(item.location) p += `（📍 ${item.location}）`;
        if(item.participants) p += `（👥 ${item.participants}）`;
        p += '\n';
      });
      p += '\n';
    }
  }

  // v14: 應用模板變量替換
  p = replaceTemplateVars(p);

  // v16: 添加簡繁轉換指示
  p += getChineseConvertPrompt();

  // v16: 添加當前場景信息
  p += await getActiveScenePrompt();

  // v22: 添加 Persona 信息
  p += buildPersonaPrompt();

  return p;
}

// 打字機效果
function showTyping(){const c=document.getElementById('content-area'),d=document.createElement('div');d.id='typing';d.className='typing';d.innerHTML='<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';c.appendChild(d);c.scrollTop=c.scrollHeight;}
function hideTyping(){const t=document.getElementById('typing');if(t)t.remove();}
async function typewriter(m){
  const c=document.getElementById('content-area'),d=document.createElement('div');
  d.className='msg';d.dataset.id=m.id;d.oncontextmenu=e=>showMsgMenu(e,m.id);
  c.appendChild(d);
  const text=m.content;
  const speed=settings.typingSpeed||0;
  
  // 解析內容
  const parsed = parseAIResponse(text);
  const storyText = parsed.story;
  
  // 完成後渲染的函數
  const renderFinal = () => {
    const safeId = escAttr(m.id);
    const floor = msgs.length; // 当前楼层号
    let html = `<span class="msg-floor">#${floor}</span>`;
    html += `<div class="msg-menu-btn" onclick="showMsgActionMenu(event,'${safeId}','ai')">⋯</div>`;
    html += `<div class="msg-ai-story">${marked.parse(storyText)}</div>`;
    if(parsed.characters && parsed.characters.length > 0){
      html += renderStatusCards(parsed.characters, m.id);
      // 同步角色狀態到數據庫
      syncCharacterStatus(parsed.characters);
    }
    // v23: 自動解析玩家狀態
    parsePlayerStatusFromAI(text);
    if(parsed.playerStatus){
      html += renderPlayerStatusCard(parsed.playerStatus, m.id);
    }
    if(parsed.formatWarning){
      html += `<div class="msg-format-warning"><span class="icon">⚠️</span>AI 未按格式輸出狀態數據，已顯示原文</div>`;
    }
    if(m.tokens){
      html += `<div class="msg-timestamp">≈${m.tokens} tokens</div>`;
    }
    d.innerHTML = html;

    // v26: 處理時間變化（從 JSON 解析）
    if(parsed.timeUpdate){
      handleTimeUpdate(parsed.timeUpdate);
    }

    // v25: 檢查並自動切換角色表情
    checkAutoExpressionSwitch(storyText);
  };
  
  // 如果速度為 0，直接顯示全部內容
  if(speed===0){
    renderFinal();
    c.scrollTop=c.scrollHeight;
    return;
  }
  
  // 打字機效果只對劇情部分
  let i=0;
  return new Promise(resolve=>{
    typingCtrl={cancelled:false};
    function type(){
      if(typingCtrl.cancelled){
        renderFinal();
        c.scrollTop=c.scrollHeight;
        resolve();
        return;
      }
      if(i<storyText.length){
        d.innerHTML=`<div class="msg-ai-story"><span>${marked.parse(storyText.slice(0,i+1))}</span><span class="typing-cursor"></span></div>`;
        c.scrollTop=c.scrollHeight;
        i++;
        setTimeout(type,speed);
      }else{
        renderFinal();
        c.scrollTop=c.scrollHeight;
        resolve();
      }
    }
    type();
  });
}

// 同步角色狀態到數據庫
async function syncCharacterStatus(characters){
  if(!story || !characters || characters.length === 0) return;

  // 并行处理所有角色
  await Promise.all(
    characters.map(async (char) => {
      try{
        // 查找是否已存在
        const existing = await db.characters.where('storyId').equals(story.id).filter(c => c.name === char.name).first();

        if(existing){
          // 更新現有角色
          const updates = {};
          if(char.title) updates.title = char.title;
          if(char.location) updates.location = char.location;
          if(char.stats) updates.stats = {...(existing.stats||{}), ...char.stats};
          if(char.mood) updates.mood = char.mood;
          if(char.note) updates.description = char.note;
          if(char.tags && char.tags.length) updates.tags = char.tags;
          updates.updatedAt = Date.now();

          await db.characters.update(existing.id, updates);
          console.log('Updated character:', char.name);
        }else{
          // 創建新角色
          const newChar = {
            id: crypto.randomUUID(),
            storyId: story.id,
            name: char.name,
            title: char.title || '',
            avatar: char.avatar || '👤',
            stats: char.stats || {},
            tags: char.tags || [],
            description: char.note || '',
            location: char.location || '',
            mood: char.mood || '',
            createdAt: Date.now(),
            updatedAt: Date.now()
          };
          await db.characters.put(newChar);
          console.log('Created new character:', char.name);
        }
      }catch(e){
        console.error('Error syncing character:', char.name, e);
      }
    })
  );
}

// ============================================
// Lorebook 觸發系統
// ============================================

let editLorebookId = null;
let lorebookConditions = [];

// 渲染 Lorebook 列表
async function renderLorebook(searchTerm = '', statusFilter = 'all'){
  if(!story) return;

  try {
    const c = document.getElementById('lorebook-list');
    if(!c){
      console.error('[Lorebook] 找不到列表容器元素');
      return;
    }

    let entries = await db.lorebook.where('storyId').equals(story.id).toArray();

    // 搜索过滤
    if(searchTerm){
      const term = searchTerm.toLowerCase();
      entries = entries.filter(e =>
        (e.name || '').toLowerCase().includes(term) ||
        (e.keywords || []).some(k => k.toLowerCase().includes(term)) ||
        (e.content || '').toLowerCase().includes(term)
      );
    }

    // 状态过滤
    if(statusFilter === 'enabled'){
      entries = entries.filter(e => e.isEnabled);
    } else if(statusFilter === 'disabled'){
      entries = entries.filter(e => !e.isEnabled);
    }

    // 按優先級排序
    entries.sort((a,b) => (b.priority||0) - (a.priority||0));

    if(!entries.length){
      const isFiltered = searchTerm || statusFilter !== 'all';
      c.innerHTML = `<div class="empty" style="padding:40px 20px">
        <div class="empty-icon">🔮</div>
        <div class="empty-title">${isFiltered ? '沒有匹配的條目' : 'Lorebook 為空'}</div>
        <div class="empty-desc">${isFiltered ? '嘗試更改搜索條件' : '添加設定條目，當對話包含關鍵詞時自動注入'}</div>
        ${!isFiltered ? `<button class="action-btn primary" style="margin-top:12px" onclick="addLorebook()">➕ 添加條目</button>
        <button class="action-btn secondary" style="margin-top:8px" onclick="importFromLore()">📥 從資料庫導入</button>` : ''}
      </div>`;
      return;
    }

    let html = '';
    for(const entry of entries){
      const hasConditions = entry.conditions && entry.conditions.length > 0;
      const keywords = (entry.keywords || []).slice(0,3).join(', ');
      const moreKeywords = (entry.keywords || []).length > 3 ? ` +${entry.keywords.length-3}` : '';

      html += `<div class="lorebook-card ${entry.isEnabled?'':'disabled'}">
        <div class="lorebook-card-header">
          <div class="lorebook-card-status"></div>
          <div class="lorebook-card-title">${esc(entry.name || '未命名')}</div>
          ${hasConditions ? '<span class="lorebook-card-lock">🔐</span>' : ''}
        </div>
        <div class="lorebook-card-triggers">🏷️ ${esc(keywords)}${moreKeywords}</div>
        <div class="lorebook-card-stats">
          <span>已觸發 ${entry.triggerCount||0} 次</span>
          <span>優先級 ${entry.priority||100}</span>
        </div>
        <div class="lorebook-card-actions">
          <button class="action-btn secondary" onclick="editLorebook('${entry.id}')">編輯</button>
          <button class="action-btn secondary" onclick="toggleLorebookEnabled('${entry.id}')">${entry.isEnabled?'禁用':'啟用'}</button>
          <button class="action-btn secondary" onclick="deleteLorebook('${entry.id}')">🗑️</button>
        </div>
      </div>`;
    }
    c.innerHTML = html;

  } catch(e) {
    console.error('[Lorebook] 渲染失敗:', e);
    const c = document.getElementById('lorebook-list');
    if(c){
      c.innerHTML = `<div class="empty" style="padding:40px 20px">
        <div class="empty-icon">⚠️</div>
        <div class="empty-title">加載失敗</div>
        <div class="empty-desc">${e.message}</div>
        <button class="action-btn primary" style="margin-top:12px" onclick="renderLorebook()">重試</button>
      </div>`;
    }
    toast('Lorebook 加載失敗: ' + e.message, 'error');
  }
}

// Lorebook 搜索过滤
function filterLorebook(){
  const searchTerm = document.getElementById('lorebook-search-input')?.value || '';
  const statusFilter = document.getElementById('lorebook-filter-status')?.value || 'all';
  renderLorebook(searchTerm, statusFilter);
}

// 添加 Lorebook 條目
function addLorebook(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  editLorebookId = null;
  lorebookConditions = [];
  document.getElementById('lorebook-id').value = '';
  document.getElementById('lorebook-name').value = '';
  document.getElementById('lorebook-keywords').value = '';
  document.getElementById('lorebook-content').value = '';
  document.getElementById('lorebook-depth').value = '2';
  document.getElementById('lorebook-priority').value = '100';
  document.getElementById('lorebook-cooldown').value = '0';
  document.getElementById('lorebook-max-triggers').value = '0';
  document.getElementById('lorebook-one-time').checked = false;
  document.getElementById('lorebook-condition-list').innerHTML = '';
  document.getElementById('lorebook-advanced').style.display = 'none';
  document.getElementById('lorebook-conditions').style.display = 'none';
  showModal('lorebook-modal');
}

// 編輯 Lorebook 條目
async function editLorebook(id){
  try {
    const entry = await db.lorebook.get(id);
    if(!entry){
      toast('找不到該條目', 'error');
      return;
    }

    editLorebookId = id;
    lorebookConditions = entry.conditions || [];

    // 安全更新元素
    const updateElement = (id, value) => {
      const el = document.getElementById(id);
      if(el) el.value = value;
    };

    updateElement('lorebook-id', id);
    updateElement('lorebook-name', entry.name || '');
    updateElement('lorebook-keywords', (entry.keywords || []).join(', '));
    updateElement('lorebook-content', entry.content || '');
    updateElement('lorebook-depth', entry.depth || '2');
    updateElement('lorebook-priority', entry.priority || '100');
    updateElement('lorebook-cooldown', entry.cooldown || '0');
    updateElement('lorebook-max-triggers', entry.maxTriggers || '0');

    const oneTimeEl = document.getElementById('lorebook-one-time');
    if(oneTimeEl) oneTimeEl.checked = entry.oneTime || false;

    // 設置條件邏輯
    const logicRadios = document.querySelectorAll('input[name="lorebook-logic"]');
    logicRadios.forEach(r => r.checked = r.value === (entry.conditionLogic || 'AND'));

    // 渲染條件列表
    try {
      renderLorebookConditions();
    } catch(e) {
      console.warn('[Lorebook] 渲染條件失敗:', e);
    }

    showModal('lorebook-modal');

  } catch(e) {
    console.error('[Lorebook] 編輯失敗:', e);
    toast('編輯失敗: ' + e.message, 'error');
  }
}

// 保存 Lorebook 條目
async function saveLorebook(){
  try {
    const name = document.getElementById('lorebook-name')?.value.trim() || '';
    const keywordsStr = document.getElementById('lorebook-keywords')?.value.trim() || '';
    const content = document.getElementById('lorebook-content')?.value.trim() || '';

    if(!name){toast(T('請輸入名稱'),'warning');return;}
    if(!keywordsStr){toast(T('請輸入觸發關鍵詞'),'warning');return;}
    if(!content){toast(T('請輸入內容'),'warning');return;}

    const keywords = keywordsStr.split(/[,，]/).map(k=>k.trim()).filter(k=>k);
    const conditionLogic = document.querySelector('input[name="lorebook-logic"]:checked')?.value || 'AND';

    const entry = {
      id: editLorebookId || crypto.randomUUID(),
      storyId: story.id,
      name,
      keywords,
      content,
      depth: parseInt(document.getElementById('lorebook-depth')?.value) || 2,
      priority: parseInt(document.getElementById('lorebook-priority')?.value) || 100,
      cooldown: parseInt(document.getElementById('lorebook-cooldown')?.value) || 0,
      maxTriggers: parseInt(document.getElementById('lorebook-max-triggers')?.value) || 0,
      oneTime: document.getElementById('lorebook-one-time')?.checked || false,
      conditions: lorebookConditions,
      conditionLogic,
      isEnabled: true,
      triggerCount: 0,
      lastTriggered: null,
      createdAt: editLorebookId ? undefined : Date.now(),
      updatedAt: Date.now()
    };

    // 保留原有的 triggerCount
    if(editLorebookId){
      try {
        const existing = await db.lorebook.get(editLorebookId);
        if(existing){
          entry.triggerCount = existing.triggerCount;
          entry.lastTriggered = existing.lastTriggered;
          entry.createdAt = existing.createdAt;
          entry.isEnabled = existing.isEnabled;
        }
      } catch(e) {
        console.warn('[Lorebook] 獲取原有數據失敗:', e);
      }
    }

    await db.lorebook.put(entry);
    closeModal('lorebook-modal');
    toast(editLorebookId ? '條目已更新' : '條目已添加', 'success');
    renderLorebook();

  } catch(e) {
    console.error('[Lorebook] 保存失敗:', e);
    toast('保存失敗: ' + e.message, 'error');
  }
}

// 切換啟用狀態
async function toggleLorebookEnabled(id){
  try {
    const entry = await db.lorebook.get(id);
    if(entry){
      await db.lorebook.update(id, {isEnabled: !entry.isEnabled});
      toast(entry.isEnabled ? '已禁用' : '已啟用');
      renderLorebook();
    } else {
      toast('找不到該條目', 'error');
    }
  } catch(e) {
    console.error('[Lorebook] 切換狀態失敗:', e);
    toast('操作失敗: ' + e.message, 'error');
  }
}

// 刪除 Lorebook 條目
function deleteLorebook(id){
  showConfirm('確定要刪除這個條目嗎？', async()=>{
    try {
      await db.lorebook.delete(id);
      toast(T('已刪除'),'success');
      renderLorebook();
    } catch(e) {
      console.error('[Lorebook] 刪除失敗:', e);
      toast('刪除失敗: ' + e.message, 'error');
    }
  });
}

// ============ Lorebook AI 合併功能 ============

let lorebookMergeSelectedIds = new Set();
let pendingMergeEntries = [];

// 顯示合併選擇 Modal
async function showLorebookMergeSelect(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  const entries = await db.lorebook.where('storyId').equals(story.id).toArray();
  if(entries.length < 2){
    toast('至少需要 2 個條目才能合併','warning');
    return;
  }

  entries.sort((a,b) => (b.priority||0) - (a.priority||0));
  lorebookMergeSelectedIds.clear();

  const list = document.getElementById('lorebook-merge-list');
  list.innerHTML = entries.map(entry => {
    const keywords = (entry.keywords || []).slice(0,4).join(', ');
    const preview = (entry.content || '').slice(0, 80);
    return `
    <div style="padding:10px;margin-bottom:8px;background:var(--bg-card);border-radius:8px;display:flex;align-items:flex-start;gap:10px;cursor:pointer" onclick="toggleLorebookMergeItem('${escAttr(entry.id)}',false)" data-merge-name="${escAttr(entry.name || '')}" data-merge-kw="${escAttr(keywords)}">
      <input type="checkbox" class="lorebook-merge-cb" data-id="${escAttr(entry.id)}" style="margin-top:3px;cursor:pointer" onclick="event.stopPropagation();toggleLorebookMergeItem('${escAttr(entry.id)}',true)">
      <div style="flex:1;min-width:0">
        <div style="font-size:14px;font-weight:600;margin-bottom:2px">${esc(entry.name || '未命名')}</div>
        <div style="font-size:11px;color:var(--text-tertiary);margin-bottom:4px">🏷️ ${esc(keywords)}</div>
        <div style="font-size:12px;color:var(--text-secondary);overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical">${esc(preview)}</div>
      </div>
    </div>`;
  }).join('');

  updateLorebookMergeCount();
  const searchInput = document.getElementById('lorebook-merge-search');
  if(searchInput) searchInput.value = '';
  showModal('lorebook-merge-select-modal');
}

// 切換選擇（fromCheckbox=true 表示由 checkbox 本身觸發，瀏覽器已自動切換 checked）
function toggleLorebookMergeItem(id, fromCheckbox){
  const cb = document.querySelector(`.lorebook-merge-cb[data-id="${CSS.escape(id)}"]`);
  if(!cb) return;
  if(!fromCheckbox) cb.checked = !cb.checked;
  if(cb.checked) lorebookMergeSelectedIds.add(id);
  else lorebookMergeSelectedIds.delete(id);
  updateLorebookMergeCount();
}

function lorebookMergeSelectAll(){
  document.querySelectorAll('#lorebook-merge-list > div').forEach(div => {
    if(div.style.display === 'none') return;
    const cb = div.querySelector('.lorebook-merge-cb');
    if(cb){ cb.checked = true; lorebookMergeSelectedIds.add(cb.dataset.id); }
  });
  updateLorebookMergeCount();
}

function lorebookMergeDeselectAll(){
  document.querySelectorAll('#lorebook-merge-list > div').forEach(div => {
    if(div.style.display === 'none') return;
    const cb = div.querySelector('.lorebook-merge-cb');
    if(cb){ cb.checked = false; lorebookMergeSelectedIds.delete(cb.dataset.id); }
  });
  updateLorebookMergeCount();
}

function updateLorebookMergeCount(){
  const el = document.getElementById('lorebook-merge-count');
  if(el) el.textContent = lorebookMergeSelectedIds.size;
}

function filterLorebookMergeList(){
  const query = (document.getElementById('lorebook-merge-search')?.value || '').trim().toLowerCase();
  document.querySelectorAll('#lorebook-merge-list > div').forEach(div => {
    if(!query){
      div.style.display = '';
      return;
    }
    const name = (div.dataset.mergeName || '').toLowerCase();
    const kw = (div.dataset.mergeKw || '').toLowerCase();
    div.style.display = (name.includes(query) || kw.includes(query)) ? '' : 'none';
  });
}

// 開始 AI 合併
async function startLorebookMerge(){
  if(lorebookMergeSelectedIds.size < 2){
    toast('請至少選擇 2 個條目','warning');
    return;
  }

  // 讀取選中的條目
  pendingMergeEntries = [];
  for(const id of lorebookMergeSelectedIds){
    const entry = await db.lorebook.get(id);
    if(entry) pendingMergeEntries.push(entry);
  }

  if(pendingMergeEntries.length < 2){
    toast('有效條目不足 2 個','warning');
    return;
  }

  closeModal('lorebook-merge-select-modal');
  showLoading('🤖 AI 正在分析並合併條目...');

  try {
    // 構建 prompt，包含 metadata 幫助 AI 判斷
    const entriesText = pendingMergeEntries.map((e, i) => {
      const created = e.createdAt ? new Date(e.createdAt).toLocaleString() : '未知';
      const updated = e.updatedAt ? new Date(e.updatedAt).toLocaleString() : '未知';
      const triggers = e.triggerCount || 0;
      return `【條目 ${i+1}】\n名稱：${e.name}\n關鍵詞：${(e.keywords||[]).join(', ')}\n建立時間：${created}\n最後更新：${updated}\n觸發次數：${triggers}\n內容：\n${e.content}`;
    }).join('\n\n---\n\n');

    // 動態計算字數限制
    const totalContentLen = pendingMergeEntries.reduce((sum, e) => sum + (e.content||'').length, 0);
    const targetLen = Math.min(800, Math.max(150, Math.round(totalContentLen * 0.6)));

    const response = await callAIForAnalysis(`你正在處理一個互動小說系統的 Lorebook（世界觀設定庫）。

【Lorebook 的用途】
Lorebook 條目會在玩家對話中出現匹配的關鍵詞時，自動注入到 AI 的上下文中作為背景設定。因此，合併後的內容必須：
- 是客觀的設定描述（不是對話或敘事）
- 結構清晰，方便 AI 快速理解並運用到回覆中
- 關鍵詞要覆蓋所有可能觸發的場景

以下是需要合併的 ${pendingMergeEntries.length} 個條目：

${entriesText}

【合併要求】
1. 整合所有條目的信息，去除重複內容
2. 如果有矛盾信息，優先採用「最後更新」時間較新的版本，或觸發次數較高（說明更常用）的版本
3. 合併後內容控制在 ${targetLen} 字左右，保持簡潔有條理
4. 使用分類或分段組織信息（如：基本信息、外貌、性格、能力、關係等），但只保留有實際內容的分類
5. 合併所有關鍵詞，去除完全重複的，保留同義詞和別名
6. 為合併後的條目取一個最能概括內容的名稱

請用 JSON 格式返回：
\`\`\`json
{
  "name": "合併後的名稱",
  "keywords": ["關鍵詞1", "關鍵詞2", "..."],
  "content": "合併後的內容..."
}
\`\`\``, '你是互動小說 Lorebook 世界觀設定的專業編輯。你的任務是將多個相關條目合併為一個結構清晰、信息完整的設定條目。合併後的內容將在關鍵詞觸發時注入 AI 上下文，所以必須是簡潔的客觀設定描述。務必返回有效的 JSON 格式。');

    hideLoading();

    // 解析 AI 返回
    let match = response.content.match(/```json\s*([\s\S]*?)\s*```/);
    if(!match) match = response.content.match(/```\s*([\s\S]*?)\s*```/);
    if(!match) match = response.content.match(/\{[\s\S]*"name"[\s\S]*"keywords"[\s\S]*"content"[\s\S]*\}/);

    if(!match){
      toast('AI 返回格式異常，請重試','error');
      return;
    }

    let result;
    try {
      result = JSON.parse(match[1] || match[0]);
    } catch(e) {
      try {
        let fixed = (match[1] || match[0]).replace(/,\s*}/g, '}').replace(/,\s*]/g, ']').replace(/'/g, '"');
        result = JSON.parse(fixed);
      } catch(e2) {
        toast('AI 返回 JSON 解析失敗，請重試','error');
        return;
      }
    }

    // 填入預覽
    document.getElementById('lorebook-merge-name').value = result.name || '';
    document.getElementById('lorebook-merge-keywords').value = (result.keywords || []).join(', ');
    document.getElementById('lorebook-merge-content').value = result.content || '';

    const sourceNames = pendingMergeEntries.map(e => e.name).join('、');
    document.getElementById('lorebook-merge-source-info').innerHTML =
      `📌 將合併以下 ${pendingMergeEntries.length} 個條目：<strong>${esc(sourceNames)}</strong><br>確認後原條目將被刪除。`;

    showModal('lorebook-merge-preview-modal');

  } catch(e) {
    hideLoading();
    console.error('[Lorebook] AI合併失敗:', e);
    toast('AI 合併失敗: ' + e.message, 'error');
  }
}

// 確認合併
async function confirmLorebookMerge(){
  const name = document.getElementById('lorebook-merge-name').value.trim();
  const keywordsStr = document.getElementById('lorebook-merge-keywords').value.trim();
  const content = document.getElementById('lorebook-merge-content').value.trim();

  if(!name){toast('請輸入名稱','warning');return;}
  if(!keywordsStr){toast('請輸入關鍵詞','warning');return;}
  if(!content){toast('請輸入內容','warning');return;}

  const keywords = keywordsStr.split(/[,，]/).map(k=>k.trim()).filter(k=>k);

  try {
    // 計算合併後的優先級（取最高值）
    const maxPriority = Math.max(...pendingMergeEntries.map(e => e.priority || 100));

    // 刪除原條目
    for(const entry of pendingMergeEntries){
      await db.lorebook.delete(entry.id);
    }

    // 建立新條目
    await db.lorebook.put({
      id: crypto.randomUUID(),
      storyId: story.id,
      name,
      keywords,
      content,
      depth: 2,
      priority: maxPriority,
      cooldown: 0,
      maxTriggers: 0,
      oneTime: false,
      conditions: [],
      conditionLogic: 'AND',
      isEnabled: true,
      triggerCount: 0,
      lastTriggered: null,
      createdAt: Date.now(),
      updatedAt: Date.now()
    });

    closeModal('lorebook-merge-preview-modal');
    const mergedCount = pendingMergeEntries.length;
    pendingMergeEntries = [];
    lorebookMergeSelectedIds.clear();
    renderLorebook();
    toast(`✅ 已成功將 ${mergedCount} 個條目合併為「${name}」`, 'success');

  } catch(e) {
    console.error('[Lorebook] 合併保存失敗:', e);
    toast('合併失敗: ' + e.message, 'error');
  }
}

// ============ Lorebook AI 合併功能結束 ============

// 從資料庫導入
async function importFromLore(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  
  const entries = await db.loreEntries.where('storyId').equals(story.id).toArray();
  if(!entries.length){
    toast(T('資料庫為空，沒有可導入的條目'),'warning');
    return;
  }
  
  showConfirm(`確定要從資料庫導入 ${entries.length} 個條目嗎？`, async()=>{
    let count = 0;
    for(const e of entries){
      // 檢查是否已存在
      const existing = await db.lorebook.where('storyId').equals(story.id).filter(l=>l.name===e.name).first();
      if(existing) continue;
      
      await db.lorebook.put({
        id: crypto.randomUUID(),
        storyId: story.id,
        name: e.name,
        keywords: [e.name],
        content: e.content || e.description || '',
        depth: 2,
        priority: 100,
        cooldown: 0,
        maxTriggers: 0,
        oneTime: false,
        conditions: [],
        conditionLogic: 'AND',
        isEnabled: true,
        triggerCount: 0,
        lastTriggered: null,
        createdAt: Date.now(),
        updatedAt: Date.now()
      });
      count++;
    }
    toast(`已導入 ${count} 個條目`,'success');
    renderLorebook();
  });
}

// 進階設置開關
function toggleLorebookAdvanced(){
  const el = document.getElementById('lorebook-advanced');
  const toggle = document.getElementById('lorebook-advanced-toggle');
  if(el.style.display === 'none'){
    el.style.display = 'block';
    toggle.textContent = '▲';
  }else{
    el.style.display = 'none';
    toggle.textContent = '▼';
  }
}

// 條件設置開關
function toggleLorebookConditions(){
  const el = document.getElementById('lorebook-conditions');
  const toggle = document.getElementById('lorebook-conditions-toggle');
  if(el.style.display === 'none'){
    el.style.display = 'block';
    toggle.textContent = '▲';
  }else{
    el.style.display = 'none';
    toggle.textContent = '▼';
  }
}

// 添加條件
async function addLorebookCondition(){
  lorebookConditions.push({
    type: 'stat',
    character: '',
    stat: '',
    operator: '>=',
    value: 50
  });
  renderLorebookConditions();
}

// 渲染條件列表
async function renderLorebookConditions(){
  const container = document.getElementById('lorebook-condition-list');
  const chars = story ? await db.characters.where('storyId').equals(story.id).toArray() : [];
  
  let html = '';
  lorebookConditions.forEach((cond, idx) => {
    // 獲取角色的屬性列表
    const charOptions = chars.map(c => `<option value="${esc(c.name)}" ${cond.character===c.name?'selected':''}>${esc(c.name)}</option>`).join('');
    
    // 獲取選中角色的屬性
    const selectedChar = chars.find(c => c.name === cond.character);
    const statOptions = selectedChar && selectedChar.stats 
      ? Object.keys(selectedChar.stats).map(s => `<option value="${esc(s)}" ${cond.stat===s?'selected':''}>${esc(s)}</option>`).join('')
      : '<option value="">請先選擇角色</option>';
    
    html += `<div class="lorebook-condition" data-idx="${idx}">
      <select onchange="updateLorebookCondition(${idx},'character',this.value);setTimeout(()=>renderLorebookConditions(),0)">
        <option value="">選擇角色</option>
        ${charOptions}
      </select>
      <select onchange="updateLorebookCondition(${idx},'stat',this.value)">
        <option value="">選擇屬性</option>
        ${statOptions}
      </select>
      <select onchange="updateLorebookCondition(${idx},'operator',this.value)">
        <option value=">=" ${cond.operator==='>='?'selected':''}>≥</option>
        <option value=">" ${cond.operator==='>'?'selected':''}>></option>
        <option value="<=" ${cond.operator==='<='?'selected':''}>≤</option>
        <option value="<" ${cond.operator==='<'?'selected':''}><</option>
        <option value="==" ${cond.operator==='=='?'selected':''}>＝</option>
      </select>
      <input type="number" value="${cond.value}" onchange="updateLorebookCondition(${idx},'value',parseInt(this.value))">
      <span style="cursor:pointer;color:var(--error)" onclick="removeLorebookCondition(${idx})">🗑️</span>
    </div>`;
  });
  
  container.innerHTML = html || '<div style="font-size:12px;color:var(--text-tertiary);text-align:center;padding:12px">暫無條件，點擊下方按鈕添加</div>';
}

// 更新條件
function updateLorebookCondition(idx, field, value){
  if(lorebookConditions[idx]){
    lorebookConditions[idx][field] = value;
  }
}

// 移除條件
function removeLorebookCondition(idx){
  lorebookConditions.splice(idx, 1);
  renderLorebookConditions();
}

// 檢測關鍵詞匹配
function checkKeywordMatch(entry, userMessage, recentMessages){
  const keywords = entry.keywords || [];
  const depth = entry.depth || 2;

  // 驗證輸入
  if(!userMessage || typeof userMessage !== 'string'){
    userMessage = '';
  }

  // 合併最近消息
  let textToCheck = userMessage;
  const recentSlice = recentMessages.slice(-depth);
  recentSlice.forEach(m => {
    textToCheck += ' ' + (m.content || '');
  });

  // 檢查關鍵詞
  for(const keyword of keywords){
    if(matchKeyword(keyword, textToCheck)){
      entry._matchedKeyword = keyword;
      return true;
    }
  }
  return false;
}

// 關鍵詞匹配（支持多種模式）
// - 普通文字：模糊匹配（不區分大小寫）
// - "文字"：精確匹配（完整詞，前後需為邊界）
// - /正則/：正則表達式匹配
function matchKeyword(keyword, text){
  if(!keyword || !text) return false;

  const trimmed = keyword.trim();

  // 正則表達式模式：/pattern/ 或 /pattern/i
  if(/^\/(.+)\/([gimsuy]*)$/.test(trimmed)){
    try {
      const match = trimmed.match(/^\/(.+)\/([gimsuy]*)$/);
      const pattern = match[1];
      const flags = match[2] || 'i';
      const regex = new RegExp(pattern, flags.includes('i') ? flags : flags + 'i');
      return regex.test(text);
    } catch(e) {
      console.warn('[Lorebook] 正則表達式錯誤:', keyword, e.message);
      return text.toLowerCase().includes(trimmed.toLowerCase());
    }
  }

  // 精確匹配模式："keyword"
  if(/^"(.+)"$/.test(trimmed)){
    const exactWord = trimmed.slice(1, -1);
    // 使用詞邊界匹配（支持中文：前後為空格、標點或字串邊界）
    const escaped = exactWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(?:^|[\\s，。！？、；：""''（）【】《》\\p{P}])${escaped}(?:[\\s，。！？、；：""''（）【】《》\\p{P}]|$)`, 'iu');
    return regex.test(text);
  }

  // 普通模糊匹配（預設）
  return text.toLowerCase().includes(trimmed.toLowerCase());
}

// 檢查觸發條件
async function checkLorebookConditions(entry){
  if(!entry.conditions || entry.conditions.length === 0) return true;
  
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  const results = [];
  
  for(const cond of entry.conditions){
    const char = chars.find(c => c.name === cond.character);
    if(!char || !char.stats) {
      results.push(false);
      continue;
    }
    
    const statValue = char.stats[cond.stat];
    if(statValue === undefined){
      results.push(false);
      continue;
    }
    
    let met = false;
    switch(cond.operator){
      case '>=': met = statValue >= cond.value; break;
      case '>': met = statValue > cond.value; break;
      case '<=': met = statValue <= cond.value; break;
      case '<': met = statValue < cond.value; break;
      case '==': met = statValue === cond.value; break;
    }
    results.push(met);
  }
  
  if(entry.conditionLogic === 'OR'){
    return results.some(r => r);
  }else{
    return results.every(r => r);
  }
}

// 獲取觸發的 Lorebook 內容
async function getTriggeredLorebook(userMessage){
  if(!story) return [];
  
  const entries = await db.lorebook.where('storyId').equals(story.id).filter(e => e.isEnabled).toArray();
  const triggered = [];
  const recentMsgs = msgs.slice(-5);
  
  for(const entry of entries){
    // 檢查關鍵詞
    if(!checkKeywordMatch(entry, userMessage, recentMsgs)) continue;
    
    // 檢查條件
    const conditionsMet = await checkLorebookConditions(entry);
    if(!conditionsMet) continue;
    
    // 檢查冷卻
    if(entry.cooldown > 0 && entry.lastTriggered){
      const msgsSinceTrigger = msgs.filter(m => m.createdAt > entry.lastTriggered).length;
      if(msgsSinceTrigger < entry.cooldown) continue;
    }
    
    // 檢查最大觸發次數
    if(entry.maxTriggers > 0 && (entry.triggerCount || 0) >= entry.maxTriggers) continue;
    
    triggered.push(entry);
  }
  
  // v25: 檢查角色專屬Lorebook
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  const activeScene = await getActiveScene();
  
  for(const char of chars){
    if(!char.character_book || !char.character_book.entries) continue;
    
    // 檢查觸發模式
    const triggerMode = char.character_book.triggerMode || 'scene';
    
    // 如果是場景模式，檢查角色是否在當前場景中
    if(triggerMode === 'scene'){
      if(activeScene && activeScene.characterIds){
        if(!activeScene.characterIds.includes(char.id)) continue;
      }
    }
    
    // 檢查每個條目
    for(const entry of char.character_book.entries){
      if(!entry.enabled) continue;
      
      // 常駐條目直接觸發
      if(entry.constant){
        triggered.push({
          ...entry,
          name: `[${char.name}] ${entry.keys?.join(', ') || '常駐'}`,
          isCharacterBook: true,
          characterName: char.name
        });
        continue;
      }
      
      // 檢查關鍵詞匹配
      const keywords = entry.keys || [];
      const searchText = userMessage + ' ' + recentMsgs.map(m => m.content).join(' ');
      const matched = keywords.some(kw => searchText.toLowerCase().includes(kw.toLowerCase()));
      
      if(matched){
        triggered.push({
          ...entry,
          name: `[${char.name}] ${entry.keys?.join(', ')}`,
          isCharacterBook: true,
          characterName: char.name
        });
      }
    }
  }
  
  // 按優先級排序
  triggered.sort((a, b) => (b.priority || 0) - (a.priority || 0));
  
  return triggered;
}

// v25: 獲取當前活動場景
async function getActiveScene(){
  if(!story) return null;
  const scenes = await db.scenes.where('storyId').equals(story.id).toArray();
  return scenes.find(s => s.isActive);
}

// 顯示觸發提示
function showLorebookTriggerToast(entries){
  if(!entries || entries.length === 0) return;
  
  const names = entries.map(e => e.name).join('、');
  const toast = document.createElement('div');
  toast.className = 'lore-trigger-toast';
  toast.innerHTML = `<span>🔮</span><span>已觸發：${esc(names)}</span>`;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateX(-50%) translateY(-10px)';
    setTimeout(() => toast.remove(), 300);
  }, 2500);
}

// 打字機點擊取消功能
function initTypingCancel(){
  const contentArea = document.getElementById('content-area');
  if(contentArea){
    contentArea.addEventListener('click', () => {
      if(typingCtrl && !typingCtrl.cancelled) typingCtrl.cancelled = true;
    });
  }
}

// 資料庫
async function renderLore(){
  if(!story)return;
  const c=document.getElementById('lore-list');
  const entries=await db.loreEntries.where('storyId').equals(story.id).toArray();
  const grouped={character:[],location:[],item:[],setting:[]};
  entries.forEach(e=>{if(grouped[e.category])grouped[e.category].push(e);});
  const labels={character:{icon:'👥',label:'角色'},location:{icon:'🗺️',label:'地點'},item:{icon:'📦',label:'物品'},setting:{icon:'📜',label:'設定'}};
  let html='',selCount=0;
  for(const[cat,items]of Object.entries(grouped)){
    if(!items.length)continue;
    const{icon,label}=labels[cat];
    html+=`<div class="lore-section"><div class="lore-header" onclick="toggleLoreSection(this)"><div class="lore-header-left"><span>${icon}</span><span>${label}</span><span class="lore-count">(${items.length})</span></div><span class="lore-toggle">▼</span></div><div class="lore-list">`;
    for(const e of items){
      if(e.isSelected)selCount++;
      html+=`<div class="lore-item" onclick="toggleLoreSel('${e.id}')"><div class="lore-checkbox ${e.isSelected?'checked':''}" data-id="${e.id}"></div><div class="lore-icon ${cat.slice(0,3)}">${e.icon||icon}</div><div class="lore-content"><div class="lore-name">${esc(e.name)}</div><div class="lore-desc">${esc(e.description||'')}</div></div><div class="lore-actions" onclick="event.stopPropagation()"><span onclick="editLore('${e.id}')">✏️</span><span onclick="deleteLore('${e.id}')">🗑️</span></div></div>`;
    }
    html+='</div></div>';
  }
  if(!html)html=`<div class="empty"><div class="empty-icon">📖</div><div class="empty-title">${T('資料庫為空')}</div><div class="empty-desc">${T('點擊右上角添加角色、地點等設定')}</div><button class="action-btn primary" style="margin-top:12px" onclick="addLore()">➕ ${T('添加資料')}</button></div>`;
  c.innerHTML=html;
  document.getElementById('lore-count').textContent=`${T('已選')} ${selCount} ${T('項')}`;
}
function toggleLoreSection(h){h.querySelector('.lore-toggle').classList.toggle('collapsed');h.nextElementSibling.classList.toggle('collapsed');}
async function toggleLoreSel(id){const e=await db.loreEntries.get(id);if(e){await db.loreEntries.update(id,{isSelected:!e.isSelected});renderLore();}}

let editLoreId=null;
function addLore(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  editLoreId=null;
  document.getElementById('lore-name').value='';
  document.getElementById('lore-category').value='character';
  document.getElementById('lore-desc').value='';
  document.getElementById('lore-content-input').value='';
  showModal('lore-modal');
}
async function editLore(id){
  const e=await db.loreEntries.get(id);
  if(!e)return;
  editLoreId=id;
  document.getElementById('lore-name').value=e.name||'';
  document.getElementById('lore-category').value=e.category||'character';
  document.getElementById('lore-desc').value=e.description||'';
  document.getElementById('lore-content-input').value=e.content||'';
  showModal('lore-modal');
}
async function saveLore(){
  const name=document.getElementById('lore-name').value.trim();
  const category=document.getElementById('lore-category').value;
  const description=document.getElementById('lore-desc').value.trim();
  const content=document.getElementById('lore-content-input').value.trim();
  if(!name){toast(T('請輸入名稱'),'warning');return;}
  const entry={
    id:editLoreId||crypto.randomUUID(),
    storyId:story.id,
    name,category,description,content,
    isSelected:false,
    createdAt:Date.now()
  };
  await db.loreEntries.put(entry);
  closeModal('lore-modal');
  toast(editLoreId?'資料已更新':'資料已添加','success');
  renderLore();
}
async function deleteLore(id){
  showConfirm('確定要刪除這條資料嗎？',async()=>{
    await db.loreEntries.delete(id);
    toast(T('資料已刪除'),'success');
    renderLore();
  });
}

// 資料搜索
async function filterLore(){
  const keyword=document.getElementById('lore-search').value.trim().toLowerCase();
  if(!story)return;
  const c=document.getElementById('lore-list');
  const entries=await db.loreEntries.where('storyId').equals(story.id).toArray();
  
  // 過濾
  const filtered=keyword?entries.filter(e=>
    e.name.toLowerCase().includes(keyword)||
    (e.description||'').toLowerCase().includes(keyword)||
    (e.content||'').toLowerCase().includes(keyword)
  ):entries;
  
  const grouped={character:[],location:[],item:[],setting:[]};
  filtered.forEach(e=>{if(grouped[e.category])grouped[e.category].push(e);});
  const labels={character:{icon:'👥',label:'角色'},location:{icon:'🗺️',label:'地點'},item:{icon:'📦',label:'物品'},setting:{icon:'📜',label:'設定'}};
  let html='',selCount=0;
  for(const[cat,items]of Object.entries(grouped)){
    if(!items.length)continue;
    const{icon,label}=labels[cat];
    html+=`<div class="lore-section"><div class="lore-header" onclick="toggleLoreSection(this)"><div class="lore-header-left"><span>${icon}</span><span>${label}</span><span class="lore-count">(${items.length})</span></div><span class="lore-toggle">▼</span></div><div class="lore-list">`;
    for(const e of items){
      if(e.isSelected)selCount++;
      html+=`<div class="lore-item" onclick="toggleLoreSel('${e.id}')"><div class="lore-checkbox ${e.isSelected?'checked':''}" data-id="${e.id}"></div><div class="lore-icon ${cat.slice(0,3)}">${e.icon||icon}</div><div class="lore-content"><div class="lore-name">${esc(e.name)}</div><div class="lore-desc">${esc(e.description||'')}</div></div><div class="lore-actions" onclick="event.stopPropagation()"><span onclick="editLore('${e.id}')">✏️</span><span onclick="deleteLore('${e.id}')">🗑️</span></div></div>`;
    }
    html+='</div></div>';
  }
  if(!html){
    if(keyword)html=`<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">${T('未找到匹配資料')}</div></div>`;
    else html=`<div class="empty"><div class="empty-icon">📖</div><div class="empty-title">${T('資料庫為空')}</div><div class="empty-desc">${T('點擊右上角添加角色、地點等設定')}</div><button class="action-btn primary" style="margin-top:12px" onclick="addLore()">➕ ${T('添加資料')}</button></div>`;
  }
  c.innerHTML=html;
  document.getElementById('lore-count').textContent=`${T('已選')} ${selCount} ${T('項')}`;
}

// AI 提取世界觀設定
let aiExtractData = null;
let _aiExtractLoreRange = 30;

async function aiExtractLore(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  showAiRangeSelector('🤖 AI 提取世界觀', (range) => {
    _aiExtractLoreRange = range;
    doAiExtractLore();
  }, 30);
}

async function doAiExtractLore(){
  // 收集來源數據
  let sourceContent = '';

  // 1. 從指令 Prompt 提取
  const bindings = await db.storyInstructions.where('storyId').equals(story.id).toArray();
  if(bindings.length > 0){
    const instIds = bindings.map(b => b.instructionId);
    const instructions = await db.instructions.where('id').anyOf(instIds).toArray();
    instructions.forEach(inst => {
      sourceContent += `\n【指令設定】\n${inst.content || ''}\n`;
    });
  }

  // 2. 從故事劇情提取
  if(msgs && msgs.length > 0){
    const recentMsgs = msgs.slice(-_aiExtractLoreRange);
    const storyContent = recentMsgs.map(m => m.content).join('\n');
    sourceContent += `\n【故事劇情】\n${storyContent}\n`;
  }

  if(!sourceContent.trim()){
    toast(T('沒有可提取的內容'),'warning');
    return;
  }

  showLoading('🤖 AI 正在分析並提取設定...\n這可能需要 30-120 秒，請耐心等待');
  
  const prompt = `請分析以下內容，提取其中的世界觀設定。請以 JSON 格式返回，包含以下類別：

1. characters（角色）：包含 name, description, details
2. locations（地點）：包含 name, description
3. items（物品）：包含 name, description
4. settings（設定/規則）：包含 name, description

注意：
- 只提取明確出現或提及的內容
- 每個類別最多提取 10 個最重要的條目
- 描述要簡潔但完整

請只返回 JSON，不要其他內容：
{
  "characters": [{"name": "", "description": ""}],
  "locations": [{"name": "", "description": ""}],
  "items": [{"name": "", "description": ""}],
  "settings": [{"name": "", "description": ""}]
}

待分析內容：
${sourceContent.slice(0, 15000)}`;

  try{
    const response = await callAIForAnalysis(prompt, '你是一個專業的世界觀設定提取助手。你的任務是從故事內容中提取角色、地點、物品和設定規則。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。');
    hideLoading();
    
    // 解析 JSON - response 是對象，需要取 content
    const responseText = response.content || response;
    let data;
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if(jsonMatch){
      try {
        data = JSON.parse(jsonMatch[0]);
        // 验证数据结构
        if(!data || typeof data !== 'object') {
          throw new Error('無效的數據結構');
        }
        // 验证必需字段
        const requiredFields = ['characters', 'locations', 'items', 'settings'];
        const hasValidStructure = requiredFields.some(field =>
          data[field] && Array.isArray(data[field]) && data[field].length > 0
        );
        if(!hasValidStructure) {
          throw new Error('AI 未返回有效的提取結果，請重試');
        }
      } catch(e) {
        throw new Error('無法解析 AI 返回的內容: ' + e.message);
      }
    }else{
      throw new Error('無法解析 AI 返回的內容');
    }
    
    // 顯示提取結果供用戶確認
    aiExtractData = data;
    showAiExtractResults(data);
  }catch(e){
    hideLoading();
    toast('提取失敗: ' + e.message, 'error');
  }
}

function showAiExtractResults(data){
  const categoryLabels = {
    characters: {icon: '👥', label: '角色', category: 'character'},
    locations: {icon: '🗺️', label: '地點', category: 'location'},
    items: {icon: '📦', label: '物品', category: 'item'},
    settings: {icon: '📜', label: '設定', category: 'setting'}
  };
  
  let html = '<div style="max-height:400px;overflow-y:auto">';
  let totalCount = 0;
  
  for(const [key, items] of Object.entries(data)){
    if(!items || !items.length) continue;
    const {icon, label, category} = categoryLabels[key] || {icon: '📄', label: key, category: 'setting'};
    
    html += `<div style="margin-bottom:16px">`;
    html += `<div style="font-weight:600;margin-bottom:8px">${icon} ${label} (${items.length})</div>`;
    
    items.forEach((item, idx) => {
      totalCount++;
      const itemId = `extract-${key}-${idx}`;
      html += `<div style="display:flex;align-items:flex-start;gap:8px;padding:8px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:6px">`;
      html += `<input type="checkbox" id="${itemId}" checked style="margin-top:4px" data-category="${category}" data-name="${esc(item.name)}" data-desc="${esc(item.description || '')}">`;
      html += `<label for="${itemId}" style="flex:1;cursor:pointer">`;
      html += `<div style="font-weight:500">${esc(item.name)}</div>`;
      if(item.description) html += `<div style="font-size:12px;color:var(--text-secondary)">${esc(item.description.slice(0, 100))}${item.description.length > 100 ? '...' : ''}</div>`;
      html += `</label></div>`;
    });
    
    html += `</div>`;
  }
  
  if(totalCount === 0){
    html = '<div style="text-align:center;color:var(--text-secondary);padding:20px">未提取到任何設定</div>';
  }
  
  html += '</div>';
  
  document.getElementById('confirm-title').textContent = `🤖 AI 提取結果 (${totalCount} 項)`;
  document.getElementById('confirm-content').innerHTML = html;
  document.getElementById('confirm-content').style.whiteSpace = 'normal';
  document.getElementById('confirm-btn').textContent = '保存選中項';
  document.getElementById('confirm-btn').style.display = '';
  confirmCb = saveExtractedLore;
  showModal('confirm-modal');
}

async function saveExtractedLore(){
  const checkboxes = document.querySelectorAll('#confirm-content input[type="checkbox"]:checked');
  let savedCount = 0;
  
  for(const cb of checkboxes){
    const entry = {
      id: crypto.randomUUID(),
      storyId: story.id,
      name: cb.dataset.name,
      category: cb.dataset.category,
      description: cb.dataset.desc,
      content: '',
      isSelected: false,
      createdAt: Date.now()
    };
    await db.loreEntries.put(entry);
    savedCount++;
  }
  
  toast(`已保存 ${savedCount} 條設定`, 'success');
  closeModal('confirm-modal');
  renderLore();
}

// 搜索頁面 Tab 切換
let currentSearchTab = 'search';
function switchSearchTab(tab){
  currentSearchTab = tab;
  document.getElementById('search-tab-search').classList.toggle('active', tab === 'search');
  document.getElementById('search-tab-important').classList.toggle('active', tab === 'important');
  document.getElementById('search-panel-search').style.display = tab === 'search' ? 'flex' : 'none';
  document.getElementById('search-panel-important').style.display = tab === 'important' ? 'flex' : 'none';
  if(tab === 'important'){
    renderImportantMessages();
  }
}

// 渲染重要消息列表
async function renderImportantMessages(){
  const c = document.getElementById('important-results');

  if(!story){
    c.innerHTML = '<div class="empty"><div class="empty-icon">📚</div><div class="empty-title">請先選擇故事</div></div>';
    return;
  }

  const allMsgs = await db.messages.where('[storyId+branchId]').equals([story.id, story.currentBranchId]).sortBy('createdAt');
  const importantMsgs = allMsgs.filter(m => m.isImportant);

  if(!importantMsgs.length){
    c.innerHTML = '<div class="empty"><div class="empty-icon">⭐</div><div class="empty-title">暫無重要消息</div><div class="empty-desc">長按消息可標記為重要</div></div>';
    return;
  }

  let html = `<div style="padding:8px 16px;color:var(--text-secondary);font-size:13px">共 ${importantMsgs.length} 條重要消息</div>`;
  html += '<div style="padding:0 16px">';
  html += importantMsgs.map(m => {
    const preview = (m.content || '').slice(0, 150);
    return `<div class="card" onclick="jumpToMessage('${m.id}')">
      <div class="card-cover" style="background:${m.role==='user'?'var(--primary)':'var(--bg-tertiary)'}">${m.role==='user'?'👤':'🤖'}</div>
      <div class="card-info">
        <div class="card-header">
          <div class="card-title">⭐ ${m.role==='user'?'用戶':'AI'}</div>
          <div class="card-time">${fmtDate(m.createdAt)}</div>
        </div>
        <div class="card-preview">${esc(preview)}${preview.length >= 150 ? '...' : ''}</div>
      </div>
    </div>`;
  }).join('');
  html += '</div>';

  c.innerHTML = html;
}

// 搜索功能
async function initContentSearch(){
  const c=document.getElementById('search-results');
  const input=document.getElementById('content-search');

  // 重置 tab 到搜索
  switchSearchTab('search');

  // 清空搜索框
  if(input) input.value='';
  
  // 檢查是否有故事
  if(!story){
    c.innerHTML='<div class="empty"><div class="empty-icon">📚</div><div class="empty-title">請先選擇故事</div><div class="empty-desc">返回故事列表選擇一個故事後再搜索</div></div>';
    return;
  }
  
  // 直接從數據庫獲取消息數量
  const msgCount = await db.messages.where('[storyId+branchId]').equals([story.id, story.currentBranchId]).count();
  
  if(!msgCount){
    c.innerHTML=`<div class="empty"><div class="empty-icon">✨</div><div class="empty-title">${T('故事內容為空')}</div><div class="empty-desc">${T('開始講述故事後才能搜索內容')}</div></div>`;
    return;
  }
  
  c.innerHTML=`<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">${T('輸入關鍵詞搜索')}</div><div class="empty-desc">${T('共有')} ${msgCount} ${T('條消息可搜索')}</div></div>`;
}

async function doContentSearch(){
  const keyword=document.getElementById('content-search').value.trim().toLowerCase();
  const c=document.getElementById('search-results');
  
  // 檢查是否有故事
  if(!story){
    c.innerHTML=`<div class="empty"><div class="empty-icon">📚</div><div class="empty-title">${T('請先選擇故事')}</div><div class="empty-desc">${T('返回故事列表選擇一個故事後再搜索')}</div></div>`;
    return;
  }
  
  // 直接從數據庫讀取所有消息（不依賴全局變量）
  const allMsgs = await db.messages.where('[storyId+branchId]').equals([story.id, story.currentBranchId]).sortBy('createdAt');
  
  if(!allMsgs||!allMsgs.length){
    c.innerHTML=`<div class="empty"><div class="empty-icon">✨</div><div class="empty-title">${T('故事內容為空')}</div><div class="empty-desc">${T('開始講述故事後才能搜索內容')}</div></div>`;
    return;
  }
  
  if(!keyword){
    c.innerHTML=`<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">${T('輸入關鍵詞搜索')}</div><div class="empty-desc">${T('共有')} ${allMsgs.length} ${T('條消息可搜索')}</div></div>`;
    return;
  }
  
  // 使用 includes 進行搜索
  const msgResults=allMsgs.filter(m=>{
    if(!m.content)return false;
    return m.content.toLowerCase().includes(keyword);
  });
  
  // v22: 同時搜索摘要
  const summaries = story.summaries || [];
  const rollingSummaries = story.rollingSummaries || [];
  const summaryResults = [];
  summaries.forEach((s, i) => {
    if(s.content && s.content.toLowerCase().includes(keyword)){
      summaryResults.push({...s, type: '壓縮摘要', idx: i});
    }
  });
  rollingSummaries.forEach((s, i) => {
    if(s.content && s.content.toLowerCase().includes(keyword)){
      summaryResults.push({...s, type: '滾動摘要', idx: i});
    }
  });
  
  if(!msgResults.length && !summaryResults.length){
    c.innerHTML=`<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">未找到匹配內容</div><div class="empty-desc">嘗試搜索其他關鍵詞<br><span style="font-size:11px;color:var(--text-tertiary)">（${allMsgs.length} 條消息中搜索）</span></div></div>`;
    return;
  }
  
  // 顯示結果
  let html = `<div style="padding:8px;color:var(--text-secondary);font-size:13px">找到 ${msgResults.length} 條消息`;
  if(summaryResults.length > 0) html += ` + ${summaryResults.length} 條摘要`;
  html += '</div>';
  
  // 顯示摘要結果（如果有）
  if(summaryResults.length > 0){
    html += '<div style="padding:4px 8px;font-size:12px;color:var(--primary);font-weight:600">📚 摘要中的匹配</div>';
    html += summaryResults.map(s => {
      const content = s.content || '';
      const lowerContent = content.toLowerCase();
      const idx = lowerContent.indexOf(keyword);
      const start = Math.max(0, idx - 40);
      const end = Math.min(content.length, idx + keyword.length + 60);
      let preview = content.slice(start, end);
      if(start > 0) preview = '...' + preview;
      if(end < content.length) preview = preview + '...';
      const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      const highlighted = esc(preview).replace(regex, '<mark style="background:var(--warning);color:black;padding:0 2px">$1</mark>');
      return `<div class="card"><div class="card-cover" style="background:var(--info)">📚</div><div class="card-info"><div class="card-header"><div class="card-title">${s.type} #${s.idx+1}</div><div class="card-time">${fmtDate(s.createdAt)}</div></div><div class="card-preview">${highlighted}</div></div></div>`;
    }).join('');
  }
  
  // 顯示消息結果
  if(msgResults.length > 0){
    if(summaryResults.length > 0) html += '<div style="padding:4px 8px;font-size:12px;color:var(--primary);font-weight:600;margin-top:8px">💬 消息中的匹配</div>';
    html += msgResults.map(m=>{
      const preview=m.content.slice(0,150);
      const keywordLower = keyword.toLowerCase();
      const previewLower = preview.toLowerCase();
      const idx = previewLower.indexOf(keywordLower);
      let highlighted = esc(preview);
      if(idx >= 0){
        const before = esc(preview.slice(0, idx));
        const match = esc(preview.slice(idx, idx + keyword.length));
        const after = esc(preview.slice(idx + keyword.length));
        highlighted = `${before}<mark style="background:var(--warning);color:black;padding:0 2px;border-radius:2px">${match}</mark>${after}`;
      }
      return `<div class="card" onclick="jumpToMessage('${m.id}')">
        <div class="card-cover" style="background:${m.role==='user'?'var(--primary)':'var(--bg-tertiary)'}">${m.role==='user'?'👤':'🤖'}</div>
        <div class="card-info">
          <div class="card-header"><div class="card-title">${m.role==='user'?'用戶':'AI'}</div><div class="card-time">${fmtDate(m.createdAt)}</div></div>
          <div class="card-preview">${highlighted}...</div>
        </div>
      </div>`;
    }).join('');
  }
  
  c.innerHTML = html;
}
function showAdvancedSearch(){
  document.getElementById('adv-search-keyword').value=document.getElementById('content-search').value;
  showModal('advanced-search-modal');
}
function doAdvancedSearch(){
  const keyword=document.getElementById('adv-search-keyword').value.trim();
  const scope=document.getElementById('adv-search-scope').value;
  const caseSensitive=document.getElementById('adv-search-case').checked;
  if(!keyword){toast(T('請輸入關鍵詞'),'warning');return;}
  
  closeModal('advanced-search-modal');
  const c=document.getElementById('search-results');
  
  if(!story||!msgs||!msgs.length){
    c.innerHTML='<div class="empty"><div class="empty-icon">📚</div><div class="empty-title">沒有可搜索的內容</div></div>';
    return;
  }
  
  let filtered=msgs;
  if(scope==='user')filtered=msgs.filter(m=>m.role==='user');
  else if(scope==='ai')filtered=msgs.filter(m=>m.role==='assistant');
  
  const results=filtered.filter(m=>{
    if(!m.content)return false;
    const content=caseSensitive?m.content:m.content.toLowerCase();
    const search=caseSensitive?keyword:keyword.toLowerCase();
    return content.includes(search);
  });
  
  if(!results.length){
    c.innerHTML='<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">未找到匹配內容</div></div>';
    return;
  }
  
  c.innerHTML=`<div style="padding:8px;color:var(--text-secondary);font-size:13px">找到 ${results.length} 條結果</div>`+results.map(m=>{
    const preview=m.content.slice(0,150);
    return `<div class="card" onclick="jumpToMessage('${m.id}')">
      <div class="card-cover" style="background:${m.role==='user'?'var(--primary)':'var(--bg-tertiary)'}">${m.role==='user'?'👤':'🤖'}</div>
      <div class="card-info">
        <div class="card-header"><div class="card-title">${m.role==='user'?'用戶':'AI'}</div><div class="card-time">${fmtDate(m.createdAt)}</div></div>
        <div class="card-preview">${esc(preview)}...</div>
      </div>
    </div>`;
  }).join('');
}
// 時間軸
async function renderTimeline(){
  if(!story)return;
  const c=document.getElementById('timeline-content');
  const tl=await db.timeline.where('storyId').equals(story.id).sortBy('order');

  let html=`<div class="timeline-current"><span>📅</span><span class="timeline-label">當前時間：</span><span class="timeline-value">${esc(story.storyTime||'未設定')}</span></div>`;

  if(!tl.length){
    html+='<div class="empty" style="padding:40px 20px"><div class="empty-icon">📅</div><div class="empty-title">時間軸為空</div></div>';
  } else {
    // 按日期分組
    const groups = {};
    const groupOrder = [];
    tl.forEach(t => {
      const date = t.date || '未分類';
      if(!groups[date]){
        groups[date] = [];
        groupOrder.push(date);
      }
      groups[date].push(t);
    });

    // 找出當前日期（包含當前時間的日期）
    let currentDate = null;
    for(const date of groupOrder){
      const hasCurrentTime = groups[date].some(t => t.timeLabel === story.storyTime);
      if(hasCurrentTime){
        currentDate = date;
        break;
      }
    }
    // 如果沒找到，默認展開最後一個日期
    if(!currentDate && groupOrder.length > 0){
      currentDate = groupOrder[groupOrder.length - 1];
    }

    html += '<div class="timeline-groups">';
    groupOrder.forEach((date, groupIdx) => {
      const items = groups[date];
      const isCurrent = date === currentDate;
      const isExpanded = isCurrent;

      // 計算該日期的總體摘要（取第一個有摘要的，或合併事件）
      const dateSummary = items.find(t => t.summary)?.summary ||
        items.flatMap(t => t.events || []).slice(0, 2).join('、') || '無事件';

      html += `
        <div class="timeline-group ${isCurrent ? 'current' : ''}" data-date="${escAttr(date)}">
          <div class="timeline-group-header" onclick="toggleTimelineGroup(this)">
            <span class="timeline-group-arrow">${isExpanded ? '▼' : '▶'}</span>
            <span class="timeline-group-date">${esc(date)}</span>
            <span class="timeline-group-count">(${items.length})</span>
            ${isCurrent ? '<span class="timeline-group-current">← 當前</span>' : ''}
            <span class="timeline-group-summary">${esc(dateSummary.slice(0, 30))}${dateSummary.length > 30 ? '...' : ''}</span>
          </div>
          <div class="timeline-group-content" style="display:${isExpanded ? 'block' : 'none'}">`;

      items.forEach(t => {
        const cur = t.timeLabel === story.storyTime;
        const evts = (t.events || []).map(e => `<div class="timeline-event"><div class="timeline-event-dot"></div><span>${esc(e)}</span></div>`).join('');
        const summaryHtml = t.summary ? `<div class="timeline-summary">${esc(t.summary)}</div>` : '';
        html += `
          <div class="timeline-item ${cur ? 'current' : ''}" data-id="${escAttr(t.id)}">
            <div class="timeline-item-header">
              <span class="timeline-time">${esc(t.timeLabel)}</span>
              ${cur ? '<span class="timeline-now">現在</span>' : ''}
              <span class="timeline-item-actions">
                <span onclick="editTimelineItem('${escAttr(t.id)}')" style="cursor:pointer" title="編輯">✏️</span>
                <span onclick="deleteTimelineItem('${escAttr(t.id)}')" style="cursor:pointer" title="刪除">🗑️</span>
              </span>
            </div>
            <div class="timeline-events">${evts}</div>
            ${summaryHtml}
          </div>`;
      });

      html += '</div></div>';
    });
    html += '</div>';
  }

  html += '<button class="action-btn primary" style="width:100%;margin-top:16px" onclick="addTimeline()">➕ 添加時間點</button>';
  c.innerHTML = html;
}

// 折疊/展開時間軸日期分組
function toggleTimelineGroup(header){
  const content = header.nextElementSibling;
  const arrow = header.querySelector('.timeline-group-arrow');
  if(content.style.display === 'none'){
    content.style.display = 'block';
    arrow.textContent = '▼';
  } else {
    content.style.display = 'none';
    arrow.textContent = '▶';
  }
}

// 時間軸功能
function addTimeline(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  resetTimelineModal();
  document.getElementById('timeline-date').value = story.storyDate || '';
  document.getElementById('timeline-label').value='';
  document.getElementById('timeline-event').value='';
  document.getElementById('timeline-summary').value='';
  document.getElementById('timeline-set-current').checked=true;
  showModal('timeline-modal');
}

// AI 生成時間軸摘要
async function generateTimelineSummary(){
  if(!msgs || msgs.length === 0){
    toast('沒有對話記錄可供分析', 'warning');
    return;
  }

  const btn = event.target;
  const originalText = btn.textContent;
  btn.textContent = '生成中...';
  btn.disabled = true;

  try {
    const preset = await db.apiPresets.filter(p => p.isActive).first();
    if(!preset || !preset.apiKey){
      throw new Error('未配置 API');
    }

    // 取最近的對話（最多20條）
    const recentMsgs = msgs.slice(-20);
    const content = recentMsgs.map(m => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      return `${role} ${m.content.slice(0, 300)}`;
    }).join('\n\n');

    const prompt = `請根據以下對話內容，用1-2句話簡短概括玩家在這段時間做了什麼（30-50字）：

${content}

要求：
- 只描述玩家的主要行動和發生的關鍵事件
- 用第三人稱描述
- 直接輸出摘要，不要其他說明`;

    let response;
    if(preset.type === 'anthropic'){
      response = await callAnthropicDirect(preset, prompt);
    } else if(preset.type === 'openai'){
      response = await callOpenAIDirect(preset, prompt);
    } else {
      response = await callCustomDirect(preset, prompt);
    }

    document.getElementById('timeline-summary').value = response.content.trim();
    toast('摘要已生成', 'success');
  } catch(e) {
    toast('生成失敗: ' + e.message, 'error');
  } finally {
    btn.textContent = originalText;
    btn.disabled = false;
  }
}

async function saveTimeline(){
  const date = document.getElementById('timeline-date').value.trim();
  const label=document.getElementById('timeline-label').value.trim();
  const event=document.getElementById('timeline-event').value.trim();
  const summary=document.getElementById('timeline-summary').value.trim();
  const setCurrent=document.getElementById('timeline-set-current').checked;

  if(!date){toast(T('請輸入日期分組'),'warning');return;}
  if(!label){toast(T('請輸入時間標記'),'warning');return;}

  // 組合完整時間標記（用於設為當前時間）
  const fullTimeLabel = `${date} ${label}`;

  // 查找是否已存在相同日期+時間的時間點
  const existing = await db.timeline.where('storyId').equals(story.id)
    .filter(t => t.date === date && t.timeLabel === label).first();

  if(existing){
    // 更新現有時間點
    const events = existing.events || [];
    if(event) events.push(event);
    await db.timeline.update(existing.id, {
      events,
      summary: summary || existing.summary
    });
  } else {
    // 創建新時間點
    const count = await db.timeline.where('storyId').equals(story.id).count();
    const tl = {
      id: crypto.randomUUID(),
      storyId: story.id,
      date: date,
      timeLabel: label,
      events: event ? [event] : [],
      summary: summary,
      order: count,
      messageId: msgs[msgs.length - 1]?.id,
      createdAt: Date.now()
    };
    await db.timeline.add(tl);
  }

  // 設為當前時間
  if(setCurrent){
    story.storyTime = label;
    story.storyDate = date;
    await db.stories.update(story.id, { storyTime: label, storyDate: date });
  }

  closeModal('timeline-modal');
  toast(T('時間點已添加'),'success');
  renderTimeline();
}

// 編輯時間軸項目
let editingTimelineId = null;

async function editTimelineItem(id){
  const item = await db.timeline.get(id);
  if(!item) return;

  editingTimelineId = id;
  document.getElementById('timeline-date').value = item.date || '';
  document.getElementById('timeline-label').value = item.timeLabel || '';
  document.getElementById('timeline-event').value = (item.events || []).join('\n');
  document.getElementById('timeline-summary').value = item.summary || '';
  document.getElementById('timeline-set-current').checked = false;

  // 修改 Modal 標題和保存按鈕
  document.querySelector('#timeline-modal .modal-title').textContent = '✏️ 編輯時間點';
  const confirmBtn = document.querySelector('#timeline-modal .modal-btn.confirm');
  confirmBtn.textContent = '更新';
  confirmBtn.onclick = updateTimelineItem;

  showModal('timeline-modal');
}

async function updateTimelineItem(){
  if(!editingTimelineId) return;

  const date = document.getElementById('timeline-date').value.trim();
  const label = document.getElementById('timeline-label').value.trim();
  const eventText = document.getElementById('timeline-event').value.trim();
  const summary = document.getElementById('timeline-summary').value.trim();
  const setCurrent = document.getElementById('timeline-set-current').checked;

  if(!date){toast(T('請輸入日期分組'),'warning');return;}
  if(!label){toast(T('請輸入時間標記'),'warning');return;}

  // 將事件文本按行分割
  const events = eventText ? eventText.split('\n').map(e => e.trim()).filter(e => e) : [];

  await db.timeline.update(editingTimelineId, {
    date,
    timeLabel: label,
    events,
    summary,
    updatedAt: Date.now()
  });

  if(setCurrent){
    story.storyTime = label;
    story.storyDate = date;
    await db.stories.update(story.id, { storyTime: label, storyDate: date });
  }

  // 重置 Modal
  resetTimelineModal();
  closeModal('timeline-modal');
  toast(T('時間點已更新'), 'success');
  renderTimeline();
}

async function deleteTimelineItem(id){
  if(!confirm('確定刪除這個時間點？')) return;

  await db.timeline.delete(id);
  toast(T('時間點已刪除'), 'success');
  renderTimeline();
}

function resetTimelineModal(){
  editingTimelineId = null;
  document.querySelector('#timeline-modal .modal-title').textContent = '📅 添加時間點';
  const confirmBtn = document.querySelector('#timeline-modal .modal-btn.confirm');
  confirmBtn.textContent = '保存';
  confirmBtn.onclick = saveTimeline;
}

async function timeJump(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  showInputDialog('時間跳躍','輸入要跳轉到的時間（例如：三天後、一月十日）',async(input)=>{
    if(!input)return;
    showLoading('正在讓 AI 處理時間跳躍...');
    try{
      const prompt=`故事時間從「${story.storyTime||'未知'}」跳躍到「${input}」。
請簡短描述這段時間內可能發生的事情（2-3句話），以及當前的場景狀況。
保持與故事風格一致。`;
      const resp=await callApi(prompt);
      hideLoading();

      // 解析日期和時間（嘗試從輸入中分離）
      // 如果輸入包含日期格式，嘗試分離；否則使用當前日期或輸入本身
      let newDate = story.storyDate || input;
      let newTime = input;

      // 更新故事時間
      story.storyTime = newTime;
      story.storyDate = newDate;
      await db.stories.update(story.id, { storyTime: newTime, storyDate: newDate });

      // 添加到時間軸
      const count=await db.timeline.where('storyId').equals(story.id).count();
      await db.timeline.add({
        id:crypto.randomUUID(),
        storyId:story.id,
        date: newDate,
        timeLabel: newTime,
        events:['時間跳躍'],
        summary: resp.content.slice(0, 100),
        order:count,
        messageId:msgs[msgs.length-1]?.id,
        createdAt:Date.now()
      });

      // 發送 AI 生成的過渡內容
      const aiMsgId=crypto.randomUUID();
      const aiMsg={id:aiMsgId,storyId:story.id,branchId:story.currentBranchId,role:'assistant',content:resp.content,tokens:resp.tokens||0,storyTime:newTime,createdAt:Date.now()};
      await db.messages.put(aiMsg);
      msgs.push(aiMsg);
      renderMsgs();
      toast(T('時間已跳躍'),'success');
    }catch(e){
      hideLoading();
      toast('時間跳躍失敗: '+e.message,'error');
    }
  });
}

// v26: 處理 AI 回覆中的時間更新（從 JSON 解析）
async function handleTimeUpdate(timeUpdate){
  if(!story || !timeUpdate || !timeUpdate.changed || !timeUpdate.newTime) return;
  if(timeUpdate.newTime === story.storyTime) return; // 時間沒變
  if(!settings.autoDetectTime) return; // 設置關閉則不自動更新

  const oldTime = story.storyTime || '未設定';
  const newTime = timeUpdate.newTime;
  const newDate = timeUpdate.newDate || story.storyDate || newTime;

  console.log('[Time] 檢測到時間變化:', oldTime, '->', newTime);

  // 更新故事時間
  story.storyTime = newTime;
  story.storyDate = newDate;
  await db.stories.update(story.id, { storyTime: newTime, storyDate: newDate });

  // 添加到時間軸（如果不存在相同日期+時間）
  const existing = await db.timeline
    .where('storyId').equals(story.id)
    .filter(t => t.date === newDate && t.timeLabel === newTime)
    .first();

  if(!existing){
    const count = await db.timeline.where('storyId').equals(story.id).count();
    await db.timeline.add({
      id: crypto.randomUUID(),
      storyId: story.id,
      date: newDate,
      timeLabel: newTime,
      events: [`從「${oldTime}」變化而來`],
      order: count,
      createdAt: Date.now()
    });
  }

  // 顯示提示
  toast(`🕐 時間更新：${newTime}`, 'info');
}

// v26: 自動檢測時間變化（舊版，保留作為備用）
async function autoDetectTimeChange(content){
  if(!story || !content) return;

  // 簡單的時間關鍵詞檢測
  const timeKeywords = [
    '第二天', '第三天', '第.*天', '次日', '隔天',
    '早上', '中午', '下午', '傍晚', '晚上', '深夜', '凌晨',
    '一小時後', '兩小時後', '幾小時後',
    '一天後', '幾天後', '數天後',
    '一週後', '一個月後', '數月後',
    '春天', '夏天', '秋天', '冬天',
    '.*月.*日', '.*年.*月'
  ];

  // 檢查是否包含時間關鍵詞
  const hasTimeKeyword = timeKeywords.some(keyword => {
    const regex = new RegExp(keyword, 'i');
    return regex.test(content);
  });

  if(!hasTimeKeyword) return;

  // 使用 AI 分析時間變化
  try {
    const prompt = `分析以下文本，判斷故事時間是否發生變化。

【當前時間】${story.storyTime || '未設定'}

【文本內容】
${content.slice(0, 500)}

請判斷：
1. 時間是否發生變化？（是/否）
2. 如果變化了，新的時間是什麼？（簡短描述，例如：第二天早上、三天後、一月十日）

請以 JSON 格式回覆：
\`\`\`json
{
  "changed": true/false,
  "newTime": "新時間描述",
  "reason": "判斷理由"
}
\`\`\``;

    const response = await callApi(prompt);

    // 解析 JSON
    const jsonMatch = response.content.match(/```json\s*([\s\S]*?)\s*```/);
    if(!jsonMatch) return;

    const result = JSON.parse(jsonMatch[1]);

    if(result.changed && result.newTime && result.newTime !== story.storyTime){
      // 顯示確認對話框
      showConfirm(
        `🕐 檢測到時間變化\n\n從「${story.storyTime || '未設定'}」→「${result.newTime}」\n\n原因：${result.reason}\n\n是否更新故事時間？`,
        async () => {
          // 更新時間
          story.storyTime = result.newTime;
          await db.stories.update(story.id, {storyTime: result.newTime});

          // 添加到時間軸
          const existing = await db.timeline
            .where('storyId').equals(story.id)
            .filter(t => t.timeLabel === result.newTime)
            .first();

          if(!existing){
            const count = await db.timeline.where('storyId').equals(story.id).count();
            await db.timeline.add({
              id: crypto.randomUUID(),
              storyId: story.id,
              timeLabel: result.newTime,
              events: ['時間推進'],
              order: count,
              messageId: msgs[msgs.length - 1]?.id,
              createdAt: Date.now()
            });
          }

          toast(`⏰ 時間已更新：${result.newTime}`, 'success');
          renderMsgs(); // 重新渲染以顯示時間分隔線
        }
      );
    }
  } catch(e) {
    console.error('[AutoDetectTime] 檢測失敗:', e);
    // 靜默失敗，不干擾用戶體驗
  }
}

// 伏筆/事件
let fTab='foreshadow';
let currentForeshadowId=null; // 當前編輯的伏筆 ID

async function renderForeshadow(){
  if(!story)return;
  const c=document.getElementById('foreshadow-content');
  if(fTab==='foreshadow'){
    const fs=await db.foreshadowing.where('storyId').equals(story.id).toArray();
    const unres=fs.filter(f=>!f.isResolved),res=fs.filter(f=>f.isResolved);

    // 添加工具欄
    let html='<div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">';
    html+='<button class="action-btn primary" onclick="aiSmartAnalyzeForeshadows()">🤖 AI 智能分析</button>';
    html+='<button class="action-btn secondary" onclick="showForeshadowTimeline()">📅 時間線</button>';
    html+='<button class="action-btn secondary" onclick="exportForeshadowReport()">📤 導出報告</button>';
    html+='</div>';

    html+='<div class="section-title"><span>📌</span><span>未回收的伏筆</span></div>';
    if(!unres.length)html+='<div style="text-align:center;padding:20px;color:var(--text-tertiary)">暫無</div>';
    else unres.forEach(f=>{
      const urgency=calculateForeshadowUrgency(f);
      const urgencyIcon={critical:'🔴',warning:'⚠️',notice:'🟡',normal:'💜'}[urgency]||'💜';
      const priorityBadge=f.priority?`<span style="font-size:10px;padding:2px 6px;background:var(--bg-tertiary);border-radius:4px;margin-left:4px">${{urgent:'🔴緊急',high:'🟠高',medium:'🟡中',low:'🟢低'}[f.priority]||''}</span>`:'';
      html+=`<div class="f-card ${urgency==='critical'?'warning':''}" onclick="showForeshadowDetail('${f.id}')" style="cursor:pointer">
        <div class="f-card-header">
          <span class="f-card-icon">${urgencyIcon}</span>
          <span class="f-card-title">${esc(f.title)}${priorityBadge}</span>
        </div>
        <div class="f-card-desc">${esc(f.description||'無描述')}</div>
        <div class="f-card-meta">
          <span>📍 ${esc(f.timeLabel||'')}</span>
          <span>已過 ${f.mentionCount||0} 條對話</span>
          ${f.tags&&f.tags.length?`<span>🏷️ ${f.tags.slice(0,2).join(', ')}</span>`:''}
        </div>
      </div>`;
    });

    if(res.length){
      html+=`<div class="section-title" style="margin-top:20px"><span>✅</span><span>已回收 (${res.length})</span></div>`;
      res.forEach(f=>{
        html+=`<div class="f-card resolved" onclick="showForeshadowDetail('${f.id}')" style="cursor:pointer">
          <div class="f-card-header">
            <span class="f-card-icon">✓</span>
            <span class="f-card-title">${esc(f.title)}</span>
          </div>
          <div class="f-card-desc">已回收</div>
        </div>`;
      });
    }
    c.innerHTML=html;
  }else{
    const evts=await db.events.where('storyId').equals(story.id).reverse().toArray();
    let html='<div class="section-title"><span>📋</span><span>重要事件記錄</span></div>';
    if(!evts.length)html+='<div style="text-align:center;padding:40px;color:var(--text-tertiary)">暫無</div>';
    else evts.forEach(e=>{const icons={character_change:'💀',relation_change:'🤝',plot_twist:'⚡',other:'📝'};html+=`<div class="f-card"><div class="f-card-header"><span class="f-card-icon">${icons[e.eventType]||'📝'}</span><span class="f-card-title">${esc(e.title)}</span></div><div class="f-card-desc">${esc(e.description)}</div><div class="f-card-meta"><span>📍 ${esc(e.storyTime||'')}</span></div></div>`;});
    c.innerHTML=html;
  }
}

// 計算伏筆緊急度
function calculateForeshadowUrgency(foreshadow){
  const age=foreshadow.mentionCount||0;
  const priority=foreshadow.priority||'medium';

  const urgencyThresholds={
    urgent:10,
    high:20,
    medium:30,
    low:50
  };

  const threshold=urgencyThresholds[priority];

  if(age>threshold*1.5)return 'critical';
  if(age>threshold)return 'warning';
  if(age>threshold*0.7)return 'notice';
  return 'normal';
}
function switchFTab(t,el){fTab=t;document.querySelectorAll('#view-foreshadow .tab-btn').forEach(b=>b.classList.remove('active'));el.classList.add('active');renderForeshadow();}

// 添加伏筆或事件
function addForeshadowOrEvent(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(fTab==='foreshadow'){
    showInputDialog('添加伏筆','輸入伏筆標題',async(title)=>{
      if(!title)return;
      showInputDialog('伏筆描述','描述這個伏筆的內容（可選）',async(desc)=>{
        const f={id:crypto.randomUUID(),storyId:story.id,messageId:msgs[msgs.length-1]?.id,title,description:desc||'',isResolved:false,mentionCount:0,timeLabel:story.storyTime,createdAt:Date.now()};
        await db.foreshadowing.add(f);
        toast(T('伏筆已添加'),'success');
        renderForeshadow();
      });
    });
  }else{
    showInputDialog('添加事件','輸入事件標題',async(title)=>{
      if(!title)return;
      showInputDialog('事件描述','描述這個事件（可選）',async(desc)=>{
        const e={id:crypto.randomUUID(),storyId:story.id,messageId:msgs[msgs.length-1]?.id,title,description:desc||'',eventType:'other',storyTime:story.storyTime,createdAt:Date.now()};
        await db.events.add(e);
        toast(T('事件已添加'),'success');
        renderForeshadow();
      });
    });
  }
}

// AI 分析伏筆
async function aiAnalyzeForeshadow(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  // 檢查是否有足夠的消息
  if(!msgs || msgs.length < 3){
    toast('消息太少，無法進行分析（至少需要3條消息）','warning');
    return;
  }

  showAiRangeSelector('🤖 AI 伏筆分析', (range) => doAiAnalyzeForeshadow(range), 30);
}

async function doAiAnalyzeForeshadow(range){
  showLoading('AI 正在檢測伏筆回收狀態...');
  try{
    const fs=await db.foreshadowing.where('storyId').equals(story.id).filter(f=>!f.isResolved).toArray();

    if(fs.length === 0){
      hideLoading();
      toast('目前沒有待回收的伏筆','info');
      return;
    }

    // 獲取上下文
    const recentMsgs = msgs.slice(-range);

    const prompt=`你是一個專業的故事分析AI，請分析以下故事中的伏筆狀態。

# 待檢查的伏筆
${fs.map((f,i)=>`${i+1}. **${f.title}**
   - 描述：${f.description||'無描述'}
   - 已過對話：${f.mentionCount||0}條
   - ID: ${f.id}`).join('\n\n')}

# 最近的故事內容（最近${range}條對話）
${recentMsgs.map((m,i)=>`[${i+1}] ${m.role==='user'?'玩家':'AI'}：${m.content}`).join('\n\n')}

# 任務
請仔細分析最近的對話內容，判斷每個伏筆的狀態。

**重要：請嚴格按照以下JSON格式回復，不要添加任何其他文字：**

\`\`\`json
{
  "resolved": [
    {
      "id": "伏筆ID",
      "title": "伏筆標題",
      "reason": "為什麼判斷已回收（引用具體對話內容）",
      "resolvedInMessage": "在哪條消息中回收（簡述）"
    }
  ],
  "needAttention": [
    {
      "id": "伏筆ID",
      "title": "伏筆標題",
      "urgency": "high/medium/low",
      "reason": "為什麼需要關注",
      "suggestion": "回收建議"
    }
  ],
  "summary": "總體分析摘要"
}
\`\`\`

**判斷標準：**
- **resolved（已回收）**：伏筆在對話中已經被明確提及、解決或揭示答案
- **needAttention（需要關注）**：
  - high: 已過20條對話且與當前劇情相關，應儘快回收
  - medium: 已過10條對話，不要忘記
  - low: 剛設下不久，可以慢慢鋪墊`;

    const resp=await callAIForAnalysis(prompt, '你是一個專業的故事伏筆分析師。你的任務是判斷伏筆的回收狀態和緊急程度。請仔細分析對話內容，積極識別已回收的伏筆和需要關注的伏筆。務必返回有效的 JSON 格式。');
    hideLoading();

    // 解析AI回復
    await parseForeshadowAnalysis(resp.content, fs);

  }catch(e){
    hideLoading();
    toast('分析失敗: '+e.message,'error');
  }
}

// 解析AI伏筆分析結果
async function parseForeshadowAnalysis(content, originalForeshadows){
  try{
    // 嘗試多種方式提取 JSON
    let jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
    if(!jsonMatch){
      jsonMatch = content.match(/```\s*([\s\S]*?)\s*```/);
    }
    if(!jsonMatch){
      jsonMatch = content.match(/\{[\s\S]*"resolved"[\s\S]*\}/);
    }
    if(!jsonMatch){
      jsonMatch = content.match(/\{[\s\S]*\}/);
    }

    let analysis;
    const jsonStr = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : content;

    try {
      analysis = JSON.parse(jsonStr);
    } catch(parseErr) {
      // 嘗試修復常見的 JSON 錯誤
      const fixedJson = jsonStr
        .replace(/,\s*}/g, '}')
        .replace(/,\s*]/g, ']')
        .replace(/'/g, '"');
      analysis = JSON.parse(fixedJson);
    }

    const resolved = analysis.resolved || [];
    const needAttention = analysis.needAttention || [];
    const summary = analysis.summary || '';

    // 如果檢測到已回收的伏筆，顯示確認對話框
    if(resolved.length > 0){
      showForeshadowResolvedConfirm(resolved, needAttention, summary);
    } else {
      // 沒有已回收的，只顯示分析結果
      showForeshadowAnalysisResult(needAttention, summary);
    }

  }catch(e){
    console.error('解析AI回復失敗:', e);
    // 如果解析失敗，顯示原始回復
    showAlert('AI 伏筆分析', content);
  }
}

// 顯示伏筆回收確認對話框
function showForeshadowResolvedConfirm(resolved, needAttention, summary){
  const modal = document.getElementById('foreshadow-resolved-confirm-modal');
  if(!modal){
    console.error('Modal foreshadow-resolved-confirm-modal not found');
    return;
  }

  // 填充已回收的伏筆列表
  const listEl = document.getElementById('resolved-foreshadow-list');
  if(!listEl){
    console.error('Element resolved-foreshadow-list not found');
    return;
  }

  listEl.innerHTML = resolved.map(f => {
    const safeReason = escHtml(f.reason || '').replace(/\n/g, '<br>');
    const safeResolved = escHtml(f.resolvedInMessage || '見最近對話').replace(/\n/g, '<br>');
    return `
    <div class="resolved-item" style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:10px">
      <label style="display:flex;align-items:flex-start;gap:10px;cursor:pointer">
        <input type="checkbox" class="resolved-checkbox" data-id="${escAttr(f.id)}" checked>
        <div style="flex:1">
          <div style="font-weight:600;margin-bottom:4px">✅ ${escHtml(f.title)}</div>
          <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px">${safeReason}</div>
          <div style="font-size:11px;color:var(--text-tertiary)">📍 ${safeResolved}</div>
        </div>
      </label>
    </div>
  `;}).join('');

  // 填充分析摘要
  const summaryEl = document.getElementById('foreshadow-analysis-summary');
  if(!summaryEl){
    console.error('Element foreshadow-analysis-summary not found');
    return;
  }

  // 保留換行符的轉義
  const safeSummary = escHtml(summary).replace(/\n/g, '<br>');
  let summaryHtml = `<div style="margin-bottom:16px;padding:12px;background:rgba(139,124,247,0.1);border-radius:8px">
    <div style="font-weight:600;margin-bottom:8px">📊 分析摘要</div>
    <div style="font-size:13px;line-height:1.6">${safeSummary}</div>
  </div>`;

  // 添加需要關注的伏筆
  if(needAttention.length > 0){
    summaryHtml += `<div style="margin-top:16px">
      <div style="font-weight:600;margin-bottom:8px">⚠️ 需要關注的伏筆</div>`;
    needAttention.forEach(f => {
      const urgencyColor = {high:'#EF4444',medium:'#F59E0B',low:'#10B981'}[f.urgency] || '#9CA3AF';
      const urgencyText = {high:'緊急',medium:'中等',low:'低'}[f.urgency] || '未知';
      const safeReason = escHtml(f.reason || '').replace(/\n/g, '<br>');
      const safeSuggestion = escHtml(f.suggestion || '').replace(/\n/g, '<br>');
      summaryHtml += `
        <div style="padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:8px;border-left:3px solid ${urgencyColor}">
          <div style="font-weight:500;margin-bottom:4px">${escHtml(f.title)} <span style="font-size:11px;color:${urgencyColor}">[${urgencyText}]</span></div>
          <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px">${safeReason}</div>
          <div style="font-size:11px;color:var(--text-tertiary)">💡 ${safeSuggestion}</div>
        </div>`;
    });
    summaryHtml += `</div>`;
  }

  summaryEl.innerHTML = summaryHtml;

  showModal('foreshadow-resolved-confirm-modal');
}

// 顯示伏筆分析結果（沒有已回收的情況）
function showForeshadowAnalysisResult(needAttention, summary){
  // 保留換行符的轉義
  const safeSummary = escHtml(summary).replace(/\n/g, '<br>');
  let content = `<div style="margin-bottom:16px">
    <strong>📊 分析摘要</strong>
    <div style="margin-top:8px;line-height:1.6">${safeSummary}</div>
  </div>`;

  if(needAttention.length > 0){
    content += `<div style="margin-top:16px">
      <strong>⚠️ 需要關注的伏筆</strong>`;
    needAttention.forEach(f => {
      const urgencyColor = {high:'#EF4444',medium:'#F59E0B',low:'#10B981'}[f.urgency] || '#9CA3AF';
      const urgencyText = {high:'緊急',medium:'中等',low:'低'}[f.urgency] || '未知';
      const safeReason = escHtml(f.reason || '').replace(/\n/g, '<br>');
      const safeSuggestion = escHtml(f.suggestion || '').replace(/\n/g, '<br>');
      content += `
        <div style="padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-top:8px;border-left:3px solid ${urgencyColor}">
          <div style="font-weight:500">${escHtml(f.title)} <span style="font-size:11px;color:${urgencyColor}">[${urgencyText}]</span></div>
          <div style="font-size:12px;color:var(--text-secondary);margin-top:4px">${safeReason}</div>
          <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">💡 ${safeSuggestion}</div>
        </div>`;
    });
    content += `</div>`;
  } else {
    content += `<div style="margin-top:16px;padding:12px;background:rgba(16,185,129,0.1);border-radius:8px;color:#10B981">
      ✅ 所有伏筆狀態良好，暫時不需要特別關注
    </div>`;
  }

  showAlert('AI 伏筆分析', content);
}

// 批量標記伏筆為已回收
async function batchMarkForeshadowResolved(){
  const checkboxes = document.querySelectorAll('.resolved-checkbox:checked');
  const ids = Array.from(checkboxes).map(cb => cb.dataset.id);

  if(ids.length === 0){
    toast('請至少選擇一個伏筆','warning');
    return;
  }

  try{
    showLoading('正在標記...');
    const now = Date.now();

    // 批量更新
    await Promise.all(ids.map(id =>
      db.foreshadowing.update(id, {
        isResolved: true,
        resolvedAt: now
      })
    ));

    hideLoading();
    closeModal('foreshadow-resolved-confirm-modal');
    toast(`已標記 ${ids.length} 個伏筆為已回收`,'success');

    // 刷新伏筆列表
    if(document.getElementById('view-foreshadow').classList.contains('active')){
      renderForeshadow();
    }
  }catch(e){
    hideLoading();
    toast('標記失敗: ' + e.message, 'error');
  }
}

// 顯示伏筆詳情
async function showForeshadowDetail(foreshadowId){
  try{
    const f=await db.foreshadowing.get(foreshadowId);
    if(!f){
      toast('伏筆不存在','error');
      return;
    }

    currentForeshadowId=foreshadowId;

    // 填充表單
    document.getElementById('f-detail-title').value=f.title||'';
    document.getElementById('f-detail-desc').value=f.description||'';
    document.getElementById('f-detail-time').textContent=f.timeLabel||'未知';
    document.getElementById('f-detail-status').value=f.isResolved?'true':'false';
    document.getElementById('f-detail-priority').value=f.priority||'medium';
    document.getElementById('f-detail-tags').value=(f.tags||[]).join(', ');
    document.getElementById('f-detail-plan').value=f.plan||'';
    document.getElementById('f-detail-count').textContent=f.mentionCount||0;
    document.getElementById('f-detail-created').textContent=new Date(f.createdAt).toLocaleString();

    // 顯示/隱藏回收信息
    const resolvedInfo=document.getElementById('f-detail-resolved-info');
    if(resolvedInfo){
      if(f.isResolved&&f.resolvedAt){
        resolvedInfo.style.display='block';
        document.getElementById('f-detail-resolved-time').textContent=new Date(f.resolvedAt).toLocaleString();
      }else{
        resolvedInfo.style.display='none';
      }
    }

    // 填充角色列表
    const chars=await db.characters.where('storyId').equals(story.id).toArray();
    const charSelect=document.getElementById('f-detail-characters');
    if(charSelect){
      charSelect.innerHTML=chars.map(c=>`<option value="${c.id}" ${(f.relatedCharacters||[]).includes(c.id)?'selected':''}>${c.avatar||'👤'} ${esc(c.name)}</option>`).join('');
    }

    showModal('foreshadow-detail-modal');
  }catch(e){
    console.error('[Foreshadow] 顯示詳情失敗:',e);
    toast('載入失敗: '+e.message,'error');
  }
}

// 保存伏筆詳情
async function saveForeshadowDetail(){
  if(!currentForeshadowId)return;

  try{
    const title=document.getElementById('f-detail-title').value.trim();
    if(!title){
      toast('標題不能為空','warning');
      return;
    }

    const currentData=await db.foreshadowing.get(currentForeshadowId);
    if(!currentData){
      toast('伏筆不存在','error');
      return;
    }

    const wasResolved=currentData.isResolved;
    const isResolved=document.getElementById('f-detail-status').value==='true';

    const updateData={
      title,
      description:document.getElementById('f-detail-desc').value.trim(),
      isResolved,
      priority:document.getElementById('f-detail-priority').value,
      tags:document.getElementById('f-detail-tags').value.split(',').map(t=>t.trim()).filter(t=>t),
      plan:document.getElementById('f-detail-plan').value.trim(),
      relatedCharacters:Array.from(document.getElementById('f-detail-characters').selectedOptions).map(o=>o.value),
      updatedAt:Date.now()
    };

    // 如果從未回收變為已回收，記錄回收時間
    if(!wasResolved&&isResolved){
      updateData.resolvedAt=Date.now();
    }

    await db.foreshadowing.update(currentForeshadowId,updateData);

    closeModal('foreshadow-detail-modal');
    toast('伏筆已更新','success');
    renderForeshadow();
    currentForeshadowId=null;
  }catch(e){
    console.error('[Foreshadow] 保存失敗:',e);
    toast('保存失敗: '+e.message,'error');
  }
}

// 刪除伏筆
async function deleteForeshadowDetail(){
  if(!currentForeshadowId)return;

  showConfirm('確定要刪除這個伏筆嗎？',async()=>{
    await db.foreshadowing.delete(currentForeshadowId);
    closeModal('foreshadow-detail-modal');
    toast('伏筆已刪除','success');
    renderForeshadow();
    currentForeshadowId=null;
  });
}

// 跳轉到伏筆原消息
function jumpToForeshadowMessage(){
  if(!currentForeshadowId)return;

  db.foreshadowing.get(currentForeshadowId).then(f=>{
    if(f&&f.messageId){
      closeModal('foreshadow-detail-modal');
      jumpToMessage(f.messageId);
    }else{
      toast('找不到原消息','warning');
    }
  }).catch(err=>{
    console.error('[Foreshadow] 跳轉失敗:',err);
    toast('跳轉失敗','error');
  });
}

// AI 生成回收方案
async function aiGenerateRecoveryPlan(){
  if(!currentForeshadowId)return;

  const f=await db.foreshadowing.get(currentForeshadowId);
  if(!f)return;

  showAiRangeSelector('🤖 AI 生成回收方案', (range) => doAiGenerateRecoveryPlan(f, range), 10);
}

async function doAiGenerateRecoveryPlan(f, range){
  showLoading('AI 正在生成回收方案...');

  try{
    const recentContext=msgs.slice(-range).map(m=>m.content).join('\n\n');

    const prompt=`當前故事情況：
${recentContext}

需要回收的伏筆：
標題：${f.title}
描述：${f.description||'無'}
埋下時間：${f.timeLabel||'未知'}
已過對話數：${f.mentionCount||0}

請提供 3 種不同的回收方案：

## 方案一：自然回收
如何在當前劇情中自然地回收這個伏筆

## 方案二：高潮回收
如何將這個伏筆作為劇情高潮回收

## 方案三：延後回收
如何為後續回收做鋪墊

每個方案包括：
- 具體步驟
- 預期效果
- 注意事項`;

    const resp=await callApi(prompt);
    hideLoading();

    // 將方案填入計劃欄
    document.getElementById('f-detail-plan').value=resp.content;

    // 同時保存到數據庫
    await db.foreshadowing.update(currentForeshadowId,{
      aiPlan:resp.content,
      updatedAt:Date.now()
    });

    toast('回收方案已生成','success');
  }catch(e){
    hideLoading();
    toast('生成失敗: '+e.message,'error');
  }
}

// AI 智能分析（合併：提取新伏筆 + 檢測已回收 + 關注建議）
async function aiSmartAnalyzeForeshadows(){
  if(!story){toast('請先選擇故事','warning');return;}

  if(!msgs || msgs.length === 0){
    toast('暫無對話內容可分析','info');
    return;
  }

  showAiRangeSelector('🤖 AI 智能分析', (range) => doAiSmartAnalysis(range), 30);
}

async function doAiSmartAnalysis(range){
  showLoading('AI 正在智能分析...');

  try{
    const recentMsgs = msgs.slice(-range);

    // 獲取已有伏筆
    const existingForeshadows = await db.foreshadowing
      .where('storyId').equals(story.id)
      .toArray();

    const unresolvedFs = existingForeshadows.filter(f => !f.isResolved);

    // 構建已有伏筆信息
    const existingInfo = unresolvedFs.length > 0
      ? unresolvedFs.map((f, i) => `${i+1}. **${f.title}** (ID: ${f.id})
   - 描述：${f.description || '無'}
   - 已過對話：${f.mentionCount || 0}條`).join('\n\n')
      : '（目前沒有未回收的伏筆）';

    const existingTitles = existingForeshadows.map(f => f.title).join('、') || '無';

    // 一次性 AI 分析
    const prompt = `你是一個專業的故事分析師，請對以下故事內容進行全面的伏筆分析。

## 最近的故事內容（${range}條對話）
${recentMsgs.map((m, i) => `[${i+1}] ${m.role === 'user' ? '玩家' : '劇情'}：${m.content}`).join('\n\n')}

## 目前已有的伏筆
${existingInfo}

## 已有伏筆標題列表（用於避免重複）
${existingTitles}

## 分析任務
請同時完成以下三項分析：

### 1. 發現新伏筆
找出對話中**尚未被記錄**的新伏筆（未解之謎、未完成事件、重要承諾、危機預兆等）
- 必須是新的，不要與已有伏筆重複或相似
- 只提取明確且重要的伏筆

### 2. 檢測已回收
判斷已有伏筆中，哪些在最近對話中**已經被回收**（被明確提及、解決或揭示答案）

### 3. 關注建議
對於未回收的伏筆，給出關注建議（是否需要盡快回收、如何回收等）

## 輸出格式
請嚴格按照以下 JSON 格式回復：

\`\`\`json
{
  "newForeshadows": [
    {
      "title": "簡短標題（5-15字）",
      "description": "詳細描述（20-50字）",
      "priority": "medium",
      "reason": "為什麼這是重要的伏筆"
    }
  ],
  "resolved": [
    {
      "id": "伏筆ID",
      "title": "伏筆標題",
      "reason": "為什麼判斷已回收（引用對話內容）"
    }
  ],
  "attention": [
    {
      "id": "伏筆ID",
      "title": "伏筆標題",
      "urgency": "high/medium/low",
      "suggestion": "回收建議"
    }
  ],
  "summary": "整體分析摘要（2-3句話）"
}
\`\`\`

注意：
- newForeshadows：如果沒有發現新伏筆，返回空數組
- resolved：如果沒有已回收的，返回空數組
- attention：只列出需要特別關注的伏筆（urgency 為 high 或 medium 的）
- priority 可選值：urgent/high/medium/low
- urgency 可選值：high/medium/low`;

    const resp = await callAIForAnalysis(prompt, '你是一個專業的故事伏筆分析師。你的任務是全面分析故事中的伏筆：發現新伏筆、檢測已回收的伏筆、給出關注建議。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。');
    hideLoading();

    if(!resp || !resp.content){
      toast('AI 分析失敗','error');
      return;
    }

    // 解析結果
    await parseSmartAnalysisResult(resp.content, existingForeshadows);

  } catch(e) {
    hideLoading();
    console.error('[Smart Analysis] 錯誤:', e);
    toast('分析失敗: ' + e.message, 'error');
  }
}

// 解析智能分析結果
async function parseSmartAnalysisResult(content, existingForeshadows){
  try {
    // 提取 JSON
    let jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
    if(!jsonMatch) jsonMatch = content.match(/```\s*([\s\S]*?)\s*```/);
    if(!jsonMatch) jsonMatch = content.match(/\{[\s\S]*"newForeshadows"[\s\S]*\}/);
    if(!jsonMatch) jsonMatch = content.match(/\{[\s\S]*\}/);

    if(!jsonMatch){
      showAlert('AI 分析結果', content);
      return;
    }

    let data;
    const jsonStr = jsonMatch[1] || jsonMatch[0];

    try {
      data = JSON.parse(jsonStr);
    } catch(e) {
      const fixedJson = jsonStr
        .replace(/,\s*}/g, '}')
        .replace(/,\s*]/g, ']')
        .replace(/'/g, '"');
      data = JSON.parse(fixedJson);
    }

    const newFs = data.newForeshadows || [];
    const resolved = data.resolved || [];
    const attention = data.attention || [];
    const summary = data.summary || '';

    // 檢查新伏筆的相似度
    const checkedNewFs = [];
    for(const f of newFs){
      const similar = checkForeshadowSimilarity(f, existingForeshadows);
      checkedNewFs.push({
        ...f,
        isDuplicate: similar !== null,
        similarTo: similar?.existing?.title,
        similarity: similar?.similarity
      });
    }

    // 保存分析數據供確認使用
    window.smartAnalysisData = {
      newForeshadows: checkedNewFs,
      resolved,
      attention,
      summary,
      existingForeshadows
    };

    // 顯示結果
    showSmartAnalysisResult(checkedNewFs, resolved, attention, summary);

  } catch(e) {
    console.error('[Smart Analysis] 解析失敗:', e);
    showAlert('AI 分析結果', content);
  }
}

// 顯示智能分析結果
function showSmartAnalysisResult(newFs, resolved, attention, summary){
  let html = '';

  // 摘要
  if(summary){
    html += `<div style="padding:12px;background:linear-gradient(135deg,rgba(139,124,247,0.15),rgba(139,124,247,0.05));border-radius:10px;margin-bottom:16px">
      <div style="font-weight:600;margin-bottom:6px">📊 分析摘要</div>
      <div style="font-size:13px;line-height:1.6">${esc(summary)}</div>
    </div>`;
  }

  // 統計
  const stats = [];
  if(newFs.length > 0) stats.push(`🆕 ${newFs.length} 個新伏筆`);
  if(resolved.length > 0) stats.push(`✅ ${resolved.length} 個已回收`);
  if(attention.length > 0) stats.push(`⚠️ ${attention.length} 個需關注`);

  if(stats.length > 0){
    html += `<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:16px;font-size:13px;color:var(--text-secondary)">
      ${stats.join('<span style="color:var(--divider)">|</span>')}
    </div>`;
  }

  // 計算非重複的新伏筆數量
  const nonDupNewFs = newFs.filter(f => !f.isDuplicate);

  // 新伏筆
  if(newFs.length > 0){
    html += `<div style="margin-bottom:16px">
      <div style="font-weight:600;margin-bottom:10px;display:flex;align-items:center;gap:6px">
        <span style="font-size:16px">🆕</span> 發現的新伏筆
        <label style="margin-left:auto;font-size:12px;font-weight:normal;cursor:pointer">
          <input type="checkbox" id="smart-select-all-new" onchange="toggleSmartSelectAll('new', this.checked)" ${nonDupNewFs.length === newFs.length ? 'checked' : (nonDupNewFs.length > 0 ? '' : '')}> 全選
        </label>
      </div>`;

    newFs.forEach((f, idx) => {
      const isDup = f.isDuplicate;
      const dupWarning = isDup
        ? `<div style="margin-top:6px;padding:6px 8px;background:rgba(239,68,68,0.1);border-radius:4px;font-size:11px;color:#EF4444">
            ⚠️ 可能與「${esc(f.similarTo)}」重複（${Math.round(f.similarity * 100)}%）
          </div>`
        : '';

      html += `<div style="background:${isDup ? 'rgba(239,68,68,0.05)' : 'var(--bg-tertiary)'};padding:12px;border-radius:8px;margin-bottom:8px;border-left:3px solid ${isDup ? '#EF4444' : 'var(--primary)'}">
        <label style="display:flex;gap:10px;cursor:pointer">
          <input type="checkbox" class="smart-new-cb" data-idx="${idx}" ${isDup ? '' : 'checked'}>
          <div style="flex:1">
            <div style="font-weight:600;margin-bottom:4px">${esc(f.title)}</div>
            <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px">${esc(f.description)}</div>
            <div style="font-size:11px;color:var(--text-tertiary)">💡 ${esc(f.reason || '')}</div>
            ${dupWarning}
          </div>
        </label>
      </div>`;
    });
    html += '</div>';
  }

  // 已回收
  if(resolved.length > 0){
    html += `<div style="margin-bottom:16px">
      <div style="font-weight:600;margin-bottom:10px;display:flex;align-items:center;gap:6px">
        <span style="font-size:16px">✅</span> 可能已回收的伏筆
        <label style="margin-left:auto;font-size:12px;font-weight:normal;cursor:pointer">
          <input type="checkbox" id="smart-select-all-resolved" onchange="toggleSmartSelectAll('resolved', this.checked)" checked> 全選
        </label>
      </div>`;

    resolved.forEach((f, idx) => {
      html += `<div style="background:rgba(16,185,129,0.08);padding:12px;border-radius:8px;margin-bottom:8px;border-left:3px solid #10B981">
        <label style="display:flex;gap:10px;cursor:pointer">
          <input type="checkbox" class="smart-resolved-cb" data-id="${escAttr(f.id)}" checked>
          <div style="flex:1">
            <div style="font-weight:600;margin-bottom:4px">${esc(f.title)}</div>
            <div style="font-size:12px;color:var(--text-secondary)">${esc(f.reason || '')}</div>
          </div>
        </label>
      </div>`;
    });
    html += '</div>';
  }

  // 需要關注
  if(attention.length > 0){
    html += `<div style="margin-bottom:16px">
      <div style="font-weight:600;margin-bottom:10px;display:flex;align-items:center;gap:6px">
        <span style="font-size:16px">⚠️</span> 需要關注的伏筆
      </div>`;

    attention.forEach(f => {
      const urgencyColor = {high: '#EF4444', medium: '#F59E0B', low: '#10B981'}[f.urgency] || '#9CA3AF';
      const urgencyText = {high: '緊急', medium: '中等', low: '一般'}[f.urgency] || '';

      html += `<div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:8px;border-left:3px solid ${urgencyColor}">
        <div style="font-weight:600;margin-bottom:4px">
          ${esc(f.title)}
          <span style="font-size:11px;color:${urgencyColor};margin-left:6px">[${urgencyText}]</span>
        </div>
        <div style="font-size:12px;color:var(--text-secondary)">💡 ${esc(f.suggestion || '')}</div>
      </div>`;
    });
    html += '</div>';
  }

  // 如果什麼都沒有
  if(newFs.length === 0 && resolved.length === 0 && attention.length === 0){
    html += `<div style="text-align:center;padding:40px;color:var(--text-tertiary)">
      <div style="font-size:48px;margin-bottom:12px">✨</div>
      <div>目前沒有需要處理的伏筆</div>
    </div>`;
  }

  document.getElementById('smart-analysis-content').innerHTML = html;

  // 根據是否有可操作項目，調整確認按鈕
  const confirmBtn = document.querySelector('#foreshadow-smart-analysis-modal .modal-btn.confirm');
  if(confirmBtn){
    if(newFs.length === 0 && resolved.length === 0){
      confirmBtn.style.display = 'none';
    } else {
      confirmBtn.style.display = '';
    }
  }

  showModal('foreshadow-smart-analysis-modal');
}

// 全選切換
function toggleSmartSelectAll(type, checked){
  const selector = type === 'new' ? '.smart-new-cb' : '.smart-resolved-cb';
  document.querySelectorAll(selector).forEach(cb => cb.checked = checked);
}

// 確認智能分析結果
async function confirmSmartAnalysis(){
  const data = window.smartAnalysisData;
  if(!data) return;

  const newToAdd = [];
  const resolvedToMark = [];

  // 收集選中的新伏筆
  document.querySelectorAll('.smart-new-cb:checked').forEach(cb => {
    const idx = parseInt(cb.dataset.idx);
    if(data.newForeshadows[idx]){
      newToAdd.push(data.newForeshadows[idx]);
    }
  });

  // 收集選中的已回收伏筆
  document.querySelectorAll('.smart-resolved-cb:checked').forEach(cb => {
    resolvedToMark.push(cb.dataset.id);
  });

  if(newToAdd.length === 0 && resolvedToMark.length === 0){
    toast('沒有選中任何項目', 'warning');
    return;
  }

  showLoading('正在處理...');

  try {
    // 添加新伏筆
    for(const f of newToAdd){
      await db.foreshadowing.add({
        id: crypto.randomUUID(),
        storyId: story.id,
        messageId: msgs[msgs.length - 1]?.id,
        title: f.title,
        description: f.description,
        isResolved: false,
        mentionCount: 0,
        priority: f.priority || 'medium',
        timeLabel: story.storyTime,
        createdAt: Date.now()
      });
    }

    // 標記已回收
    const now = Date.now();
    for(const id of resolvedToMark){
      await db.foreshadowing.update(id, {
        isResolved: true,
        resolvedAt: now
      });
    }

    hideLoading();
    closeModal('foreshadow-smart-analysis-modal');

    const msgs_arr = [];
    if(newToAdd.length > 0) msgs_arr.push(`添加 ${newToAdd.length} 個新伏筆`);
    if(resolvedToMark.length > 0) msgs_arr.push(`標記 ${resolvedToMark.length} 個為已回收`);
    toast(msgs_arr.join('，'), 'success');

    renderForeshadow();
    window.smartAnalysisData = null;

  } catch(e) {
    hideLoading();
    toast('處理失敗: ' + e.message, 'error');
  }
}

// AI 自動提取伏筆（改进版：先分析后提取）
async function aiAutoExtractForeshadows(){
  if(!story){toast('請先選擇故事','warning');return;}

  // 檢查消息數量
  if(!msgs||msgs.length===0){
    toast('暫無對話內容可分析','info');
    return;
  }

  showAiRangeSelector('🤖 AI 提取伏筆', (range) => doAiAutoExtractForeshadows(range), 20);
}

async function doAiAutoExtractForeshadows(range){
  showLoading('AI 正在分析對話...');

  try{
    const recentMessages=msgs.slice(-range);

    if(recentMessages.length===0){
      hideLoading();
      toast('沒有足夠的對話內容','info');
      return;
    }

    // 獲取已有伏筆，避免重複
    const existingForeshadows=await db.foreshadowing
      .where('storyId').equals(story.id)
      .toArray();

    // 改進：傳遞完整的伏筆信息（標題+描述）
    const existingInfo = existingForeshadows.length > 0
      ? existingForeshadows.map(f => `- ${f.title}：${f.description || '無描述'}`).join('\n')
      : '無';

    // 一次性分析並提取結構化伏筆
    const prompt=`請仔細閱讀以下對話內容，找出所有**尚未解決的伏筆和懸念**，並直接以結構化 JSON 格式返回。

## 對話內容
${recentMessages.map((m,i)=>`[${i+1}] ${m.role==='user'?'玩家':'劇情'}：${m.content}`).join('\n\n')}

## 已有伏筆（請仔細檢查，避免提取重複或相似的伏筆）
${existingInfo}

## 伏筆類型
請識別以下類型的伏筆：
1. **未解之謎**：提到但未解釋的神秘事物、現象、人物
2. **未完成的事件**：開始但未結束的情節、任務、行動
3. **重要承諾**：角色做出但未兌現的承諾、約定
4. **未達成的目標**：設定但未完成的目標、願望
5. **危機預兆**：暗示未來可能發生的危機、衝突
6. **懸而未決的問題**：提出但未回答的重要問題
7. **神秘線索**：出現但未解釋的線索、物品、信息

## 返回格式
請以 JSON 格式返回：
\`\`\`json
{
  "foreshadows": [
    {
      "title": "簡短標題（5-10字）",
      "description": "詳細描述這個伏筆的內容和背景（20-50字）",
      "keywords": ["關鍵詞1", "關鍵詞2"],
      "priority": "medium",
      "reason": "為什麼這是重要的伏筆？"
    }
  ]
}
\`\`\`

重要規則：
1. 積極識別，寧可多提取讓用戶篩選，也不要遺漏
2. 不要重複已有伏筆
3. 優先級可選值：urgent/high/medium/low
4. 只有在對話中完全沒有任何伏筆時，才返回空數組`;

    showLoading('AI 正在分析並提取伏筆...');
    const extractResponse=await callAIForAnalysis(prompt, '你是一個專業的故事伏筆分析師。你的任務是從對話中找出所有尚未解決的伏筆和懸念，並以結構化 JSON 格式返回。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。');
    hideLoading();

    if(!extractResponse||!extractResponse.content){
      toast('AI 提取失敗','error');
      return;
    }

    // 嘗試多種方式解析 JSON
    let jsonMatch=extractResponse.content.match(/```json\s*([\s\S]*?)\s*```/);
    if(!jsonMatch){
      jsonMatch=extractResponse.content.match(/```\s*([\s\S]*?)\s*```/);
    }
    if(!jsonMatch){
      jsonMatch=extractResponse.content.match(/\{[\s\S]*"foreshadows"[\s\S]*\}/);
    }
    if(!jsonMatch){
      jsonMatch=extractResponse.content.match(/\{[\s\S]*\}/);
    }

    if(!jsonMatch){
      // 如果沒有 JSON，顯示原始返回讓用戶查看
      showAlert('AI 分析結果',extractResponse.content+'\n\n---\n\n提取失敗，請手動添加伏筆。');
      return;
    }

    let data;
    try{
      const jsonStr = jsonMatch[1] || jsonMatch[0];
      data=JSON.parse(jsonStr);
    }catch(parseError){
      // 嘗試修復常見的 JSON 錯誤
      try {
        const fixedJson = (jsonMatch[1] || jsonMatch[0])
          .replace(/,\s*}/g, '}')
          .replace(/,\s*]/g, ']')
          .replace(/'/g, '"');
        data=JSON.parse(fixedJson);
      } catch(e) {
        console.error('[AI Extract] JSON 解析失敗:',parseError);
        // 顯示分析結果
        showAlert('AI 分析結果',extractResponse.content+'\n\n---\n\n提取失敗，請手動添加伏筆。');
        return;
      }
    }

    if(!data.foreshadows||!Array.isArray(data.foreshadows)||data.foreshadows.length===0){
      // 顯示分析結果，即使沒有提取到伏筆
      showAlert('AI 分析結果',extractResponse.content+'\n\n---\n\n未識別到明顯的新伏筆。');
      return;
    }

    // 顯示建議
    showForeshadowSuggestions(data.foreshadows);

  }catch(e){
    hideLoading();
    console.error('[AI Extract] 錯誤:',e);
    toast('提取失敗: '+e.message,'error');
  }
}

// 計算兩個文本的相似度（0-1之間，1表示完全相同）
function calculateTextSimilarity(text1, text2){
  if(!text1 || !text2) return 0;

  // 轉換為小寫並去除空格
  const t1 = text1.toLowerCase().replace(/\s+/g, '');
  const t2 = text2.toLowerCase().replace(/\s+/g, '');

  // 完全相同
  if(t1 === t2) return 1;

  // 計算編輯距離（Levenshtein distance）
  const len1 = t1.length;
  const len2 = t2.length;
  const matrix = [];

  for(let i = 0; i <= len1; i++){
    matrix[i] = [i];
  }
  for(let j = 0; j <= len2; j++){
    matrix[0][j] = j;
  }

  for(let i = 1; i <= len1; i++){
    for(let j = 1; j <= len2; j++){
      const cost = t1[i-1] === t2[j-1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i-1][j] + 1,      // 刪除
        matrix[i][j-1] + 1,      // 插入
        matrix[i-1][j-1] + cost  // 替換
      );
    }
  }

  const distance = matrix[len1][len2];
  const maxLen = Math.max(len1, len2);

  // 轉換為相似度（0-1）
  return 1 - (distance / maxLen);
}

// 檢查新伏筆是否與已有伏筆相似
function checkForeshadowSimilarity(newForeshadow, existingForeshadows){
  if(!existingForeshadows || existingForeshadows.length === 0) return null;

  let maxSimilarity = 0;
  let mostSimilar = null;

  for(const existing of existingForeshadows){
    // 計算標題相似度
    const titleSim = calculateTextSimilarity(newForeshadow.title, existing.title);

    // 計算描述相似度
    const descSim = calculateTextSimilarity(
      newForeshadow.description || '',
      existing.description || ''
    );

    // 綜合相似度（標題權重更高）
    const similarity = titleSim * 0.7 + descSim * 0.3;

    if(similarity > maxSimilarity){
      maxSimilarity = similarity;
      mostSimilar = existing;
    }
  }

  // 如果相似度超過70%，返回相似的伏筆
  if(maxSimilarity >= 0.7){
    return {
      similarity: maxSimilarity,
      existing: mostSimilar
    };
  }

  return null;
}

// 顯示伏筆建議
async function showForeshadowSuggestions(suggestions){
  let html='<div class="suggestions-list">';
  html+='<h3 style="margin-bottom:12px">AI 識別到以下潛在伏筆：</h3>';

  // 優化：一次性獲取所有已有伏筆，避免重複查詢
  const existingForeshadows = story
    ? await db.foreshadowing.where('storyId').equals(story.id).toArray()
    : [];

  // 檢查每個建議是否與已有伏筆相似
  for(let idx = 0; idx < suggestions.length; idx++){
    const s = suggestions[idx];
    const similarCheck = checkForeshadowSimilarity(s, existingForeshadows);

    const isDuplicate = similarCheck !== null;
    const duplicateClass = isDuplicate ? 'suggestion-duplicate' : '';
    const duplicateWarning = isDuplicate
      ? `<div class="duplicate-warning">⚠️ 可能與已有伏筆重複：「${esc(similarCheck.existing.title)}」（相似度 ${Math.round(similarCheck.similarity * 100)}%）</div>`
      : '';

    html+=`
      <div class="suggestion-item ${duplicateClass}">
        <input type="checkbox" id="sug-${idx}" ${isDuplicate ? '' : 'checked'}>
        <label for="sug-${idx}">
          <strong>${esc(s.title)}</strong>
          <p>${esc(s.description)}</p>
          <small>原因：${esc(s.reason)}</small>
          ${duplicateWarning}
        </label>
      </div>
    `;
  }

  html+='</div>';

  document.getElementById('suggestions-content').innerHTML=html;

  // 保存建議數據
  window.foreshadowSuggestions=suggestions;

  showModal('foreshadow-suggestions-modal');
}

// 確認添加建議的伏筆
async function confirmForeshadowSuggestions(){
  if(!window.foreshadowSuggestions)return;

  const selected=[];
  window.foreshadowSuggestions.forEach((s,idx)=>{
    if(document.getElementById(`sug-${idx}`).checked){
      selected.push(s);
    }
  });

  if(selected.length===0){
    toast('請至少選擇一個伏筆','warning');
    return;
  }

  showLoading('正在添加伏筆...');

  try{
    for(const s of selected){
      const f={
        id:crypto.randomUUID(),
        storyId:story.id,
        messageId:msgs[msgs.length-1]?.id,
        title:s.title,
        description:s.description,
        isResolved:false,
        mentionCount:0,
        priority:s.priority||'medium',
        tags:s.keywords||[],
        timeLabel:story.storyTime,
        createdAt:Date.now()
      };
      await db.foreshadowing.add(f);
    }

    hideLoading();
    closeModal('foreshadow-suggestions-modal');
    toast(`已添加 ${selected.length} 個伏筆`,'success');
    renderForeshadow();

    window.foreshadowSuggestions=null;
  }catch(e){
    hideLoading();
    toast('添加失敗: '+e.message,'error');
  }
}

// AI 檢測伏筆衝突
async function aiCheckForeshadowConflicts(){
  if(!story){toast('請先選擇故事','warning');return;}

  const foreshadows=await db.foreshadowing
    .where('storyId').equals(story.id)
    .filter(f=>!f.isResolved)
    .toArray();

  if(foreshadows.length<2){
    toast('伏筆數量不足，無需檢測衝突','info');
    return;
  }

  showLoading('AI 正在分析衝突...');

  try{
    const prompt=`分析以下伏筆是否存在衝突或矛盾：

${foreshadows.map((f,i)=>`
${i+1}. ${f.title}
   描述：${f.description||'無'}
   標籤：${(f.tags||[]).join(', ')||'無'}
`).join('\n')}

請指出：
1. 哪些伏筆可能相互衝突
2. 如何協調這些衝突
3. 建議的回收順序`;

    const response=await callApi(prompt);
    hideLoading();

    showAlert('伏筆衝突分析',response.content);
  }catch(e){
    hideLoading();
    toast('分析失敗: '+e.message,'error');
  }
}

// 顯示伏筆時間線
async function showForeshadowTimeline(){
  if(!story){toast('請先選擇故事','warning');return;}

  const foreshadows=await db.foreshadowing
    .where('storyId').equals(story.id)
    .toArray();

  if(foreshadows.length===0){
    toast('暫無伏筆','info');
    return;
  }

  // 按創建時間排序
  foreshadows.sort((a,b)=>a.createdAt-b.createdAt);

  let html='<div class="timeline-container">';

  foreshadows.forEach((f,idx)=>{
    const status=f.isResolved?'resolved':'pending';
    const urgency=calculateForeshadowUrgency(f);

    html+=`
      <div class="timeline-item ${status} ${urgency}" onclick="showForeshadowDetail('${f.id}')" style="cursor:pointer">
        <div class="timeline-marker">
          ${f.isResolved?'✓':idx+1}
        </div>
        <div class="timeline-content">
          <div class="timeline-title">${esc(f.title)}</div>
          <div class="timeline-meta">
            ${f.timeLabel||'未知時間'} ·
            已過 ${f.mentionCount||0} 條對話
            ${f.priority?` · ${{'urgent':'🔴緊急','high':'🟠高','medium':'🟡中','low':'🟢低'}[f.priority]||''}`:''}
          </div>
          ${f.isResolved?`
            <div class="timeline-resolved">
              ✅ 已回收於 ${f.resolvedAt?new Date(f.resolvedAt).toLocaleString():'未知'}
            </div>
          `:''}
        </div>
      </div>
    `;
  });

  html+='</div>';

  document.getElementById('foreshadow-timeline-content').innerHTML=html;
  showModal('foreshadow-timeline-modal');
}

// 導出伏筆報告
async function exportForeshadowReport(){
  if(!story){toast('請先選擇故事','warning');return;}

  const foreshadows=await db.foreshadowing
    .where('storyId').equals(story.id)
    .toArray();

  if(foreshadows.length===0){
    toast('暫無伏筆可導出','info');
    return;
  }

  let markdown=`# ${story.title} - 伏筆報告\n\n`;
  markdown+=`生成時間：${new Date().toLocaleString()}\n\n`;

  markdown+=`## 📊 統計\n\n`;
  markdown+=`- 總伏筆數：${foreshadows.length}\n`;
  markdown+=`- 未回收：${foreshadows.filter(f=>!f.isResolved).length}\n`;
  markdown+=`- 已回收：${foreshadows.filter(f=>f.isResolved).length}\n\n`;

  const unresolved=foreshadows.filter(f=>!f.isResolved);
  if(unresolved.length>0){
    markdown+=`## 📌 未回收伏筆\n\n`;
    unresolved.forEach(f=>{
      markdown+=`### ${f.title}\n\n`;
      markdown+=`- **描述**：${f.description||'無'}\n`;
      markdown+=`- **埋下時間**：${f.timeLabel||'未知'}\n`;
      markdown+=`- **已過對話**：${f.mentionCount||0} 條\n`;
      markdown+=`- **優先級**：${{'urgent':'緊急','high':'高','medium':'中','low':'低'}[f.priority||'medium']}\n`;
      if(f.tags&&f.tags.length>0){
        markdown+=`- **標籤**：${f.tags.join(', ')}\n`;
      }
      if(f.plan){
        markdown+=`- **回收計劃**：\n${f.plan}\n`;
      }
      markdown+=`\n`;
    });
  }

  const resolved=foreshadows.filter(f=>f.isResolved);
  if(resolved.length>0){
    markdown+=`## ✅ 已回收伏筆\n\n`;
    resolved.forEach(f=>{
      markdown+=`### ${f.title}\n\n`;
      markdown+=`- **描述**：${f.description||'無'}\n`;
      markdown+=`- **埋下時間**：${f.timeLabel||'未知'}\n`;
      markdown+=`- **回收時間**：${f.resolvedAt?new Date(f.resolvedAt).toLocaleString():'未知'}\n\n`;
    });
  }

  // 下載為 Markdown 文件
  const blob=new Blob([markdown],{type:'text/markdown;charset=utf-8'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=`${story.title}-伏筆報告.md`;
  a.click();
  URL.revokeObjectURL(url);

  toast('報告已導出','success');
}

// 更新伏筆計數（每次發送消息後調用）
async function updateForeshadowCounts(){
  if(!story)return;

  try{
    const foreshadows=await db.foreshadowing
      .where('storyId').equals(story.id)
      .filter(f=>!f.isResolved)
      .toArray();

    if(foreshadows.length===0)return;

    // 批量更新以提高性能
    const updates=foreshadows.map(f=>
      db.foreshadowing.update(f.id,{
        mentionCount:(f.mentionCount||0)+1
      })
    );

    await Promise.all(updates);
  }catch(e){
    console.error('[Foreshadow] 更新計數失敗:',e);
  }
}

// 顯示伏筆提醒橫幅
async function showForeshadowReminder(){
  if(!story)return;

  // 移除舊的提醒
  const oldReminder=document.getElementById('foreshadow-reminder-banner');
  if(oldReminder)oldReminder.remove();

  try{
    const unresolvedForeshadows=await db.foreshadowing
      .where('storyId').equals(story.id)
      .filter(f=>!f.isResolved)
      .toArray();

    const urgent=unresolvedForeshadows.filter(f=>
      calculateForeshadowUrgency(f)==='critical'
    );

    if(urgent.length>0){
      // 在輸入框上方顯示提醒橫幅
      const banner=document.createElement('div');
      banner.id='foreshadow-reminder-banner';
      banner.className='foreshadow-reminder warning';
      banner.innerHTML=`
        ⚠️ 有 ${urgent.length} 個伏筆需要盡快回收！
        <button onclick="goTo('view-foreshadow');closeAll();document.getElementById('foreshadow-reminder-banner').remove()">查看</button>
      `;

      // 插入到對話視圖中
      const chatView=document.getElementById('view-chat');
      if(chatView){
        chatView.insertBefore(banner,chatView.firstChild);

        // 5秒後自動隱藏
        setTimeout(()=>{
          if(banner.parentNode){
            banner.style.transition='opacity 0.3s';
            banner.style.opacity='0';
            setTimeout(()=>banner.remove(),300);
          }
        },5000);
      }
    }
  }catch(e){
    console.error('[Foreshadow] 顯示提醒失敗:',e);
  }
}

// 顯示警告/信息彈窗
function showAlert(title,content){
  showConfirm(content,null,false,title);
}

// 存檔
async function renderSaves(){
  if(!story)return;
  const c=document.getElementById('saves-content');
  const saves=await db.saves.where('storyId').equals(story.id).reverse().toArray();
  const manual=saves.filter(s=>!s.isAuto),auto=saves.filter(s=>s.isAuto);
  let html=`<div class="section-title"><span>💾</span><span>手動存檔 (${manual.length}/8)</span></div>`;
  if(!manual.length)html+='<div style="text-align:center;padding:20px;color:var(--text-tertiary)">暫無</div>';
  else manual.forEach(s=>html+=renderSaveCard(s));
  html+=`<div class="section-title" style="margin-top:20px"><span>🔄</span><span>自動存檔 (${auto.length}/5)</span></div>`;
  if(!auto.length)html+='<div style="text-align:center;padding:20px;color:var(--text-tertiary)">暫無</div>';
  else auto.forEach(s=>html+=renderSaveCard(s,true));
  c.innerHTML=html;
}
function renderSaveCard(s,isAuto=false){
  const t=timeAgo(s.createdAt),tagCls=s.labelColor==='#EF4444'?'be':s.labelColor==='#F59E0B'?'key':'';
  return `<div class="save-card"><div class="save-card-header"><div class="save-card-title">${isAuto?`自動 #${s.slotIndex}`:`存檔 ${s.slotIndex}`}${s.label?`<span class="save-card-tag ${tagCls}">${esc(s.label)}</span>`:''}</div></div><div class="save-card-preview">${esc(s.preview||'')}</div><div class="save-card-meta"><span>📍 ${esc(s.storyTime||'')}</span><span>🕐 ${t}</span></div><div class="save-card-actions"><button class="action-btn primary" onclick="loadSave('${s.id}')">讀取</button>${isAuto?`<button class="action-btn secondary" onclick="toast(T('轉為手動'))">轉為手動</button>`:`<button class="action-btn secondary" onclick="toast(T('覆蓋'))">覆蓋</button>`}<button class="action-btn secondary" onclick="deleteSave('${s.id}')">🗑️</button></div></div>`;
}
async function createSave(){
  if(!story||!msgs.length){toast(T('沒有可保存的內容'),'warning');return;}
  const existing=await db.saves.where('storyId').equals(story.id).filter(s=>!s.isAuto).toArray();
  if(existing.length>=8){toast(T('存檔槽位已滿'),'warning');return;}
  const slot=existing.length+1,last=msgs[msgs.length-1];
  const save={id:crypto.randomUUID(),storyId:story.id,slotIndex:slot,isAuto:false,label:'',preview:last?.content?.slice(0,100)||'',storyTime:story.storyTime||'',branchId:story.currentBranchId,messageId:last?.id,createdAt:Date.now()};
  await db.saves.put(save);
  toast(T('存檔創建成功！'),'success');
  renderSaves();
}
async function loadSave(id){showConfirm('確定要讀取此存檔嗎？當前進度將丟失。',async()=>{showLoading('讀取存檔...');try{const s=await db.saves.get(id);if(!s)throw new Error('存檔不存在');await db.stories.update(story.id,{currentBranchId:s.branchId,currentMessageId:s.messageId,storyTime:s.storyTime});await openStory(story.id);toast(T('存檔讀取成功！'),'success');}catch(e){toast('讀取失敗: '+e.message,'error');}hideLoading();});}
async function deleteSave(id){showConfirm('確定要刪除此存檔嗎？',async()=>{await db.saves.delete(id);toast(T('存檔已刪除'),'success');renderSaves();});}

// 指令
async function renderInst(){
  const c=document.getElementById('inst-list');
  const list=await db.instructions.toArray();
  if(!list.length){c.innerHTML='<div class="empty"><div class="empty-icon">📜</div><div class="empty-title">還沒有指令</div><div class="empty-desc">導入 .md 或 .txt 文件作為設定指令</div><button class="empty-btn" onclick="importInst()">導入指令</button></div>';return;}
  
  // 獲取所有綁定關係和故事名稱
  const allBindings = await db.storyInstructions.toArray();
  const allStories = await db.stories.toArray();
  const storyMap = Object.fromEntries(allStories.map(s=>[s.id, s.title]));
  
  // 為每個指令找到綁定的故事
  const enrichedList = list.map(inst => {
    const bindings = allBindings.filter(b => b.instructionId === inst.id);
    const boundStoryNames = bindings.map(b => storyMap[b.storyId]).filter(Boolean);
    return {
      ...inst,
      boundStoryNames: boundStoryNames.length ? boundStoryNames : null
    };
  });
  
  c.innerHTML=enrichedList.map(i=>`<div class="inst-card"><div class="inst-header"><div class="inst-icon">📄</div><div class="inst-info"><div class="inst-name">${esc(i.name)}</div><div class="inst-meta">${fmtNum(i.content?.length||0)} 字</div><div class="inst-binding">綁定：${i.boundStoryNames ? i.boundStoryNames.map(n=>esc(n)).join(', ') : '未綁定'}</div></div></div>${i.content?`<div class="inst-preview">${esc(i.content.slice(0,100))}...</div>`:''}<div class="inst-actions"><button class="action-btn secondary" onclick="previewInst('${i.id}')">預覽</button><button class="action-btn secondary" onclick="editInst('${i.id}')">編輯</button><button class="action-btn secondary" onclick="deleteInst('${i.id}')">🗑️</button></div></div>`).join('');
}

// 預覽指令
async function previewInst(id){
  const inst = await db.instructions.get(id);
  if(!inst) return;
  showConfirm(inst.content || '（空內容）', null, false, `📄 ${inst.name}`);
}

// 編輯指令
let editInstId = null;
async function editInst(id){
  const inst = await db.instructions.get(id);
  if(!inst) return;
  editInstId = id;
  document.getElementById('edit-inst-name').value = inst.name;
  document.getElementById('edit-inst-content').value = inst.content || '';
  showModal('edit-inst-modal');
}

async function saveEditInst(){
  if(!editInstId) return;
  const name = document.getElementById('edit-inst-name').value.trim();
  const content = document.getElementById('edit-inst-content').value;
  if(!name){toast(T('請輸入名稱'),'warning');return;}
  await db.instructions.update(editInstId, { name, content });
  closeModal('edit-inst-modal');
  toast(T('指令已更新'),'success');
  renderInst();
  editInstId = null;
}
function importInst(){
  const input=document.getElementById('file-input');
  input.onchange=async e=>{
    const f=e.target.files[0];if(!f)return;
    const content=await f.text();
    const inst={id:crypto.randomUUID(),name:f.name,content,createdAt:Date.now()};
    await db.instructions.put(inst);
    toast(T('指令導入成功！'),'success');
    renderInst();
    input.value='';
  };
  input.click();
}
async function deleteInst(id){showConfirm('確定要刪除此指令嗎？',async()=>{await db.instructions.delete(id);await db.storyInstructions.where('instructionId').equals(id).delete();toast(T('指令已刪除'),'success');renderInst();});}

// API預設
async function renderApi(){
  const c=document.getElementById('api-list');if(!c)return;
  const list=await db.apiPresets.toArray();
  if(!list.length){c.innerHTML='<div class="empty"><div class="empty-icon">🤖</div><div class="empty-title">未配置 API</div><div class="empty-desc">添加 Claude 或 OpenAI API 來開始</div><button class="empty-btn" onclick="addApi()">添加 API</button></div>';return;}
  c.innerHTML=list.map(p=>`<div class="api-card ${p.isActive?'active':''}"><div class="api-header" onclick="selectApi('${p.id}')"><span class="api-name">${esc(p.name)}</span>${p.isActive?'<span class="api-badge">使用中</span>':''}</div><div class="api-info" onclick="selectApi('${p.id}')">${p.type==='anthropic'?'Anthropic':p.type==='openai'?'OpenAI':'自定義'} · ${esc(p.model)}</div><div class="api-actions" style="display:flex;gap:8px;margin-top:10px"><button class="action-btn secondary" onclick="editApi('${p.id}')">✏️ 編輯</button><button class="action-btn secondary" onclick="deleteApi('${p.id}')" style="color:var(--error)">🗑️ 刪除</button></div></div>`).join('')+`<div style="text-align:center;margin-top:16px"><button class="action-btn primary" style="width:auto;padding:12px 24px" onclick="addApi()">➕ 添加新預設</button></div>`;
}
function addApi(){
  editApiId=null;
  document.getElementById('api-name').value='';
  document.getElementById('api-type').value='anthropic';
  document.getElementById('api-key').value='';
  document.getElementById('api-model').value='';
  document.getElementById('api-url').value='';
  // 重置自動補全復選框為選中狀態
  const autoCompleteCheckbox = document.getElementById('api-url-autocomplete');
  if(autoCompleteCheckbox) autoCompleteCheckbox.checked = true;
  updateApiFields();
  showModal('api-modal');
}
async function editApi(id){
  const p=await db.apiPresets.get(id);
  if(!p)return;
  editApiId=id;
  document.getElementById('api-name').value=p.name||'';
  document.getElementById('api-type').value=p.type||'anthropic';
  document.getElementById('api-key').value=p.apiKey||'';
  document.getElementById('api-url').value=p.url||'';
  updateApiFields();
  document.getElementById('api-model').value=p.model||'';
  // 加載自動補全設置
  const autoCompleteCheckbox = document.getElementById('api-url-autocomplete');
  if(autoCompleteCheckbox) autoCompleteCheckbox.checked = p.urlAutoComplete !== false;
  showModal('api-modal');
}
async function deleteApi(id){
  showConfirm('確定要刪除此 API 預設嗎？',async()=>{
    const p=await db.apiPresets.get(id);
    await db.apiPresets.delete(id);
    if(p&&p.isActive){
      const first=await db.apiPresets.toCollection().first();
      if(first)await db.apiPresets.update(first.id,{isActive:true});
    }
    toast(T('API 預設已刪除'),'success');
    renderApi();
  });
}
function updateApiFields(){
  const t=document.getElementById('api-type').value,m=document.getElementById('api-model'),dl=document.getElementById('model-list'),u=document.getElementById('api-url-group');
  if(t==='anthropic'){
    dl.innerHTML='<option value="claude-sonnet-4-20250514">Claude Sonnet 4</option><option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option><option value="claude-3-opus-20240229">Claude 3 Opus</option><option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>';
    m.placeholder='選擇或輸入模型名稱';
    u.classList.add('hidden');
  }else if(t==='openai'){
    dl.innerHTML='<option value="gpt-4o">GPT-4o</option><option value="gpt-4o-mini">GPT-4o Mini</option><option value="gpt-4-turbo">GPT-4 Turbo</option><option value="gpt-3.5-turbo">GPT-3.5 Turbo</option><option value="o1">o1</option><option value="o1-mini">o1-mini</option>';
    m.placeholder='選擇或輸入模型名稱';
    u.classList.add('hidden');
  }else{
    dl.innerHTML='';
    m.placeholder='輸入模型名稱';
    u.classList.remove('hidden');
  }
}
async function saveApi(){
  const name=document.getElementById('api-name').value.trim(),type=document.getElementById('api-type').value,apiKey=document.getElementById('api-key').value.trim(),model=document.getElementById('api-model').value.trim(),url=document.getElementById('api-url').value.trim();
  const urlAutoComplete = document.getElementById('api-url-autocomplete')?.checked ?? true;
  if(!name||!apiKey){toast(T('請填寫名稱和 API Key'),'warning');return;}
  if(!model){toast(T('請輸入或選擇模型'),'warning');return;}
  if(type==='custom'&&!url){toast(T('請輸入 API URL'),'warning');return;}
  
  // 如果是編輯，保留原本的 isActive 狀態；如果是新建，設為 true 並取消其他的激活狀態
  let isActive = true;
  if(editApiId){
    const existing = await db.apiPresets.get(editApiId);
    isActive = existing?.isActive || false;
  } else {
    // 新建時，取消其他 API 的激活狀態，讓新的成為激活狀態
    await db.apiPresets.toCollection().modify({isActive: false});
  }
  
  const p={id:editApiId||crypto.randomUUID(),name,type,apiKey,model,url:type==='custom'?url:'',urlAutoComplete,isActive,createdAt:Date.now()};
  await db.apiPresets.put(p);
  closeModal('api-modal');
  toast(T('API 預設已保存') + (isActive ? '（已激活）' : ''), 'success');
  renderApi();
}
async function testApi(){
  const type=document.getElementById('api-type').value,apiKey=document.getElementById('api-key').value.trim(),model=document.getElementById('api-model').value.trim(),url=document.getElementById('api-url').value.trim();
  const resultEl=document.getElementById('api-test-result');
  resultEl.style.display='block';
  resultEl.style.color='var(--text-secondary)';
  resultEl.innerHTML='<span class="typing"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span></span> 測試連接中...';
  if(!apiKey){resultEl.style.color='var(--error)';resultEl.textContent='❌ 請先填寫 API Key';return;}
  if(!model){resultEl.style.color='var(--error)';resultEl.textContent='❌ 請先填寫模型名稱';return;}
  
  // 創建超時控制
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 30000);

  try{
    let r;
    // iOS 兼容性：明確設置 mode 和 credentials
    const fetchOptions = {
      signal: controller.signal,
      method: 'POST',
      mode: 'cors',
      credentials: 'omit',
      cache: 'no-cache'
    };

    if(type==='anthropic'){
      r=await fetch('https://api.anthropic.com/v1/messages',{
        ...fetchOptions,
        headers:{
          'Content-Type':'application/json',
          'x-api-key':apiKey,
          'anthropic-version':'2023-06-01',
          'anthropic-dangerous-direct-browser-access':'true'
        },
        body:JSON.stringify({model:model,max_tokens:10,messages:[{role:'user',content:'Hi'}]})
      });
    }else if(type==='openai'){
      r=await fetch('https://api.openai.com/v1/chat/completions',{
        ...fetchOptions,
        headers:{
          'Content-Type':'application/json',
          'Authorization':`Bearer ${apiKey}`
        },
        body:JSON.stringify({model:model,messages:[{role:'user',content:'Hi'}],max_tokens:10})
      });
    }else{
      if(!url){resultEl.style.color='var(--error)';resultEl.textContent='❌ 請先填寫 API URL';return;}
      const autoComplete = document.getElementById('api-url-autocomplete')?.checked ?? true;
      const apiUrl = normalizeApiUrl(url, autoComplete);
      console.log('Testing Custom API:', url, '→', apiUrl, '(autoComplete:', autoComplete, ')');
      r=await fetch(apiUrl,{
        ...fetchOptions,
        headers:{
          'Content-Type':'application/json',
          'Authorization':`Bearer ${apiKey}`
        },
        body:JSON.stringify({model:model,messages:[{role:'user',content:'Hi'}],max_tokens:10})
      });
    }
    const text = await r.text();
    console.log('Test API response:', r.status, text.slice(0, 500));
    if(r.ok){
      try {
        const d = JSON.parse(text);
        const hasValidStructure = d.choices?.[0]?.message !== undefined || d.content?.[0] !== undefined;
        if(hasValidStructure) {
          resultEl.style.color='var(--success)';
          resultEl.textContent='✅ 連接成功！API 可正常使用';
        } else {
          resultEl.style.color='var(--warning)';
          resultEl.textContent='⚠️ 連接成功但返回格式異常';
        }
      } catch(e) {
        resultEl.style.color='var(--error)';
        resultEl.textContent='❌ 返回非JSON: ' + text.slice(0, 50);
      }
    }else{
      try {
        const e = JSON.parse(text);
        resultEl.style.color='var(--error)';
        resultEl.textContent='❌ ' + (e.error?.message || `HTTP ${r.status}`);
      } catch(e) {
        resultEl.style.color='var(--error)';
        resultEl.textContent='❌ HTTP ' + r.status + ': ' + text.slice(0, 50);
      }
    }
  }catch(e){
    resultEl.style.color='var(--error)';
    console.error('Test API error:', e);
    const errMsg = e.message || e.toString() || '未知錯誤';
    if(e.name === 'AbortError') {
      resultEl.innerHTML='❌ 連接超時（30秒）<br><span style="font-size:11px;color:var(--text-tertiary)">請檢查網絡或 URL 是否正確</span>';
    } else if(errMsg.includes('Load failed') || errMsg.includes('Failed to fetch') || errMsg.includes('NetworkError') || e.name === 'TypeError') {
      // 檢測是否為 iOS
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      let hint = '瀏覽器安全策略阻止了請求。';
      if(isIOS) {
        hint += '<br>iOS 設備可能需要：<br>• 檢查 Safari 設置中的「阻止跨網站追蹤」<br>• 嘗試關閉「隱私瀏覽」模式';
      }
      hint += '<br>• 確認 API 服務已開啟 CORS 支持';
      resultEl.innerHTML='❌ 連接失敗<br><span style="font-size:11px;color:var(--text-tertiary)">' + hint + '</span>';
    } else {
      resultEl.innerHTML='❌ 連接失敗: ' + errMsg;
    }
  } finally {
    clearTimeout(timeoutId);
  }
}
async function selectApi(id){await db.apiPresets.toCollection().modify({isActive:false});await db.apiPresets.update(id,{isActive:true});toast(T('已切換 API'),'success');renderApi();}

// 面板和菜單
function showSheet(){
  document.getElementById('overlay').classList.add('active');
  const sheet=document.getElementById('sheet');
  // 全屏模式下不限制寬度
  if(settings.screen==='fullscreen'){
    sheet.style.maxWidth='100%';
  }else{
    sheet.style.maxWidth='420px';
  }
  sheet.classList.add('active');
}
function showMore(e){
  e.stopPropagation();
  const m=document.getElementById('more-menu');
  m.style.top='100px';
  m.style.right='16px';
  // v19: 根據模式顯示/隱藏經營模式選項
  const isSimMode = story?.mode === 'simulation';
  m.querySelectorAll('.sim-only').forEach(el => {
    el.style.display = isSimMode ? '' : 'none';
  });
  m.classList.add('active');
}
function showMsgMenu(e,id){e.preventDefault();e.stopPropagation();selMsgId=id;const m=document.getElementById('msg-menu');m.style.top=Math.min(e.clientY,window.innerHeight-300)+'px';m.style.left=Math.min(e.clientX,window.innerWidth-180)+'px';m.classList.add('active');}

// 点击弹出消息操作菜单
function showMsgActionMenu(e, msgId, msgType) {
  e.preventDefault();
  e.stopPropagation();
  
  // 移除已存在的菜单
  const existingMenu = document.querySelector('.msg-action-menu');
  if (existingMenu) existingMenu.remove();
  
  selMsgId = msgId;
  
  // 创建菜单
  const menu = document.createElement('div');
  menu.className = 'msg-action-menu';
  
  // 檢查消息是否已標記為重要
  const msg = msgs.find(m => m.id === msgId);
  const isImportant = msg && msg.isImportant;

  let menuHtml = '';
  if (msgType === 'user') {
    menuHtml = `
      <div class="msg-action-item" onclick="toggleMsgImportanceFromMenu()"><span class="icon">${isImportant ? '⭐' : '☆'}</span>${isImportant ? '取消重要標記' : '標記為重要'}</div>
      <div class="msg-action-item" onclick="editMsgFromMenu()"><span class="icon">✏️</span>編輯</div>
      <div class="msg-action-item danger" onclick="deleteMsgFromMenu()"><span class="icon">🗑️</span>刪除</div>
    `;
  } else {
    menuHtml = `
      <div class="msg-action-item" onclick="toggleMsgImportanceFromMenu()"><span class="icon">${isImportant ? '⭐' : '☆'}</span>${isImportant ? '取消重要標記' : '標記為重要'}</div>
      <div class="msg-action-item" onclick="regenMsgFromMenu()"><span class="icon">🔄</span>重新生成</div>
      <div class="msg-action-item" onclick="editMsgFromMenu()"><span class="icon">✏️</span>編輯</div>
      <div class="msg-action-item" onclick="copyMsgFromMenu()"><span class="icon">📋</span>複製</div>
      <div class="msg-action-item danger" onclick="deleteMsgFromMenu()"><span class="icon">🗑️</span>刪除</div>
    `;
  }
  menu.innerHTML = menuHtml;
  
  // 定位菜单
  document.body.appendChild(menu);
  const rect = e.target.getBoundingClientRect();
  let top = rect.bottom + 4;
  let left = rect.left - 60;
  
  // 防止超出屏幕
  if (top + 180 > window.innerHeight) top = rect.top - 180;
  if (left < 10) left = 10;
  if (left + 130 > window.innerWidth) left = window.innerWidth - 140;
  
  menu.style.top = top + 'px';
  menu.style.left = left + 'px';
  
  // 点击其他地方关闭菜单
  setTimeout(() => {
    document.addEventListener('click', closeMsgActionMenu, { once: true });
  }, 10);
}

function closeMsgActionMenu() {
  const menu = document.querySelector('.msg-action-menu');
  if (menu) menu.remove();
}

function editMsgFromMenu() {
  closeMsgActionMenu();
  editMsg();
}

function deleteMsgFromMenu() {
  closeMsgActionMenu();
  deleteMsg();
}

async function regenMsgFromMenu() {
  closeMsgActionMenu();
  if (!selMsgId || generating) return;
  
  // 找到这条AI消息
  const msgIndex = msgs.findIndex(m => m.id === selMsgId);
  if (msgIndex < 0) return;
  
  const currentMsg = msgs[msgIndex];
  if (currentMsg.role !== 'assistant') {
    toast(T('只能重新生成 AI 回覆'), 'warning');
    return;
  }
  
  // 删除当前AI消息
  await db.messages.delete(selMsgId);
  msgs.splice(msgIndex, 1);
  renderMsgs();
  
  // 重新生成
  generating = true;
  const sendBtn = document.getElementById('send-btn');
  sendBtn.disabled = true;
  
  toast(T('正在重新生成...'), 'info');
  
  const useStreaming = settings.enableStreaming;
  // 获取上一条用户消息作为上下文
  const lastUserMsg = msgs.filter(m => m.role === 'user').pop();
  const content = lastUserMsg?.content || '繼續';
  
  if (useStreaming) {
    await sendWithStreaming(content, sendBtn);
  } else {
    showTyping();
    try {
      const resp = await callAI(content);
      hideTyping();
      const aiMsgId = crypto.randomUUID();
      const estimatedTokens = Math.round(resp.content.length / 2);
      const aiMsg = {id: aiMsgId, storyId: story.id, branchId: story.currentBranchId, role: 'assistant', content: resp.content, tokens: resp.tokens || estimatedTokens, storyTime: story.storyTime || '', createdAt: Date.now()};
      await db.messages.put(aiMsg);
      msgs.push(aiMsg);
      await db.stories.update(story.id, {updatedAt: Date.now(), preview: resp.content.slice(0, 100), currentMessageId: aiMsgId});
      renderMsgs();
      parsePlayerStatusFromAI(resp.content);
    } catch (e) {
      hideTyping();
      toast('重新生成失敗: ' + e.message, 'error');
    }
  }
  
  generating = false;
  sendBtn.disabled = false;
}

async function copyMsgFromMenu() {
  closeMsgActionMenu();
  if (!selMsgId) return;
  
  const msg = msgs.find(m => m.id === selMsgId);
  if (!msg) return;
  
  try {
    await navigator.clipboard.writeText(msg.content);
    toast(T('已複製到剪貼板'), 'success');
  } catch (e) {
    toast(T('複製失敗'), 'error');
  }
}

async function toggleMsgImportanceFromMenu() {
  closeMsgActionMenu();
  if (!selMsgId) return;

  const msgIndex = msgs.findIndex(m => m.id === selMsgId);
  if (msgIndex < 0) return;

  const msg = msgs[msgIndex];
  const newImportance = !msg.isImportant;

  // 更新記憶中的消息
  msgs[msgIndex].isImportant = newImportance;

  // 更新數據庫
  try {
    await db.messages.update(selMsgId, { isImportant: newImportance });
    toast(newImportance ? '⭐ 已標記為重要記憶' : '已取消重要標記', 'success');
    renderMsgs();
  } catch (e) {
    console.error('[Important] 更新失敗:', e);
    toast('操作失敗', 'error');
  }
}

function hideMenu(){document.querySelectorAll('.context-menu').forEach(m=>m.classList.remove('active'));closeMsgActionMenu();}

// 故事菜單相關
let menuStoryId = null;
function showStoryMenu(id) {
  menuStoryId = id;
  const m = document.getElementById('story-menu');
  m.style.top = '120px';
  m.style.left = '50%';
  m.style.transform = 'translateX(-50%)';
  m.classList.add('active');
}
function editStoryCover() {
  hideMenu();
  if (!menuStoryId) return;
  // 設置上傳目標為帶有storyId的對象，避免async導致的安全策略問題
  imageUploadTarget = { type: 'storyCover', storyId: menuStoryId };
  document.getElementById('image-upload').click();
}
async function renameStoryFromMenu() {
  hideMenu();
  if (!menuStoryId) return;
  const s = await db.stories.get(menuStoryId);
  if (!s) return;

  const newTitle = prompt('請輸入新的故事名稱：', s.title);
  if (!newTitle || newTitle.trim() === '') {
    toast('故事名稱不能為空', 'warning');
    return;
  }

  if (newTitle.trim() === s.title) {
    return; // 名稱沒有改變
  }

  await db.stories.update(menuStoryId, {
    title: newTitle.trim(),
    updatedAt: Date.now()
  });

  // 如果重命名的是當前打開的故事，也更新全局變量
  if (story && story.id === menuStoryId) {
    story.title = newTitle.trim();
    // 更新導航欄標題
    const navTitle = document.querySelector('#view-story .nav-title');
    if (navTitle) navTitle.textContent = story.title;
  }

  toast('故事已重命名', 'success');
  await renderStories();
}

async function renameCurrentStory() {
  closeAll();
  if (!story) return;

  const newTitle = prompt('請輸入新的故事名稱：', story.title);
  if (!newTitle || newTitle.trim() === '') {
    toast('故事名稱不能為空', 'warning');
    return;
  }

  if (newTitle.trim() === story.title) {
    return; // 名稱沒有改變
  }

  await db.stories.update(story.id, {
    title: newTitle.trim(),
    updatedAt: Date.now()
  });

  story.title = newTitle.trim();

  // 更新導航欄標題
  const navTitle = document.querySelector('#view-story .nav-title');
  if (navTitle) navTitle.textContent = story.title;

  toast('故事已重命名', 'success');
  await renderStories();
}

async function toggleStoryPin() {
  hideMenu();
  if (!menuStoryId) return;
  const s = await db.stories.get(menuStoryId);
  if (!s) return;
  await db.stories.update(menuStoryId, { isPinned: !s.isPinned });
  toast(s.isPinned ? '已取消置頂' : '已置頂', 'success');
  await renderStories();
}
async function deleteStoryFromMenu() {
  hideMenu();
  if (!menuStoryId) return;
  const s = await db.stories.get(menuStoryId);
  if (!s) return;
  showConfirm(`確定要刪除「${s.title}」嗎？此操作不可恢復！`, async () => {
    // 刪除故事本身
    await db.stories.delete(menuStoryId);
    // 刪除聊天記錄
    await db.messages.where('storyId').equals(menuStoryId).delete();
    // 刪除分支
    await db.branches.where('storyId').equals(menuStoryId).delete();
    // 刪除角色數據
    await db.characters.where('storyId').equals(menuStoryId).delete();
    await db.characterSnapshots.where('storyId').equals(menuStoryId).delete();
    await db.characterHistory.where('storyId').equals(menuStoryId).delete();
    await db.characterStates.where('storyId').equals(menuStoryId).delete();
    // 刪除 Lorebook
    await db.lorebook.where('storyId').equals(menuStoryId).delete();
    await db.lorebookTriggerLog.where('storyId').equals(menuStoryId).delete();
    // 刪除存檔和書籤
    await db.saves.where('storyId').equals(menuStoryId).delete();
    await db.bookmarks.where('storyId').equals(menuStoryId).delete();
    // 刪除章節
    await db.chapters.where('storyId').equals(menuStoryId).delete();
    // 刪除伏筆和事件
    await db.foreshadowing.where('storyId').equals(menuStoryId).delete();
    await db.events.where('storyId').equals(menuStoryId).delete();
    // 刪除時間軸
    await db.timeline.where('storyId').equals(menuStoryId).delete();
    // 刪除標籤
    await db.plotTags.where('storyId').equals(menuStoryId).delete();
    // 刪除玩家面板
    await db.playerPanels.where('storyId').equals(menuStoryId).delete();
    toast(T('故事已刪除'), 'success');
    await renderStories();
  }, true);
}

// 重新開始故事（清空聊天記錄但保留設定）
async function restartStory() {
  closeAll();
  if(!story?.id) return;
  
  showConfirm(`確定要重新開始嗎？\n\n將清空所有聊天記錄、分支、存檔、書籤等，並重置角色狀態到初始值。\n\n故事設定（指令、角色、Lorebook等）會保留。`, async () => {
    showLoading(T('正在重置...'));
    try {
      // 清空聊天記錄
      await db.messages.where('storyId').equals(story.id).delete();
      // 清空分支
      await db.branches.where('storyId').equals(story.id).delete();
      // 清空存檔
      await db.saves.where('storyId').equals(story.id).delete();
      // 清空書籤
      await db.bookmarks.where('storyId').equals(story.id).delete();
      // 清空章節
      await db.chapters.where('storyId').equals(story.id).delete();
      // 清空伏筆事件
      await db.foreshadowing.where('storyId').equals(story.id).delete();
      await db.events.where('storyId').equals(story.id).delete();
      // 清空時間軸
      await db.timeline.where('storyId').equals(story.id).delete();
      // 清空標籤
      await db.plotTags.where('storyId').equals(story.id).delete();
      // 清空記憶摘要
      await db.stories.update(story.id, {
        compressedSummaries: [],
        rollingSummaries: [],
        importantMemories: [],
        updatedAt: Date.now()
      });
      
      // 重置玩家面板數值（保留結構，恢復默認值）
      const panel = await db.playerPanels.where('storyId').equals(story.id).first();
      if(panel && panel.values) {
        const resetValues = {};
        for(const attr of (panel.attributes || [])) {
          resetValues[attr.name] = attr.defaultValue;
        }
        await db.playerPanels.update(panel.id, { values: resetValues });
      }
      
      // 重置角色狀態到初始值
      const characters = await db.characters.where('storyId').equals(story.id).toArray();
      for(const char of characters) {
        // 優先使用完整的 initialState，否則使用 initialStats
        if(char.initialState && Object.keys(char.initialState).length > 0) {
          // 恢復完整的初始設定
          const updateData = {
            updatedAt: Date.now()
          };
          
          // 恢復所有保存的字段
          const fieldsToRestore = [
            'name', 'title', 'avatar', 'category', 'description', 'personality', 'tags',
            'first_mes', 'scenario', 'mes_example', 'alternate_greetings',
            'system_prompt', 'post_history_instructions', 'creator_notes', 'creator', 'character_version',
            'stats', 'character_book', 'relationships', 'expressions', 'expressionMode', 'avatarImage'
          ];
          
          for(const field of fieldsToRestore) {
            if(char.initialState[field] !== undefined) {
              updateData[field] = char.initialState[field];
            }
          }
          
          await db.characters.update(char.id, updateData);
        } else if(char.initialStats && Object.keys(char.initialStats).length > 0) {
          // 兼容舊版：只恢復屬性
          await db.characters.update(char.id, { 
            stats: { ...char.initialStats },
            updatedAt: Date.now()
          });
        }
      }
      
      // 重置 Lorebook 觸發計數
      const lorebookEntries = await db.lorebook.where('storyId').equals(story.id).toArray();
      for(const entry of lorebookEntries) {
        await db.lorebook.update(entry.id, { 
          triggerCount: 0,
          lastTriggeredAt: null
        });
      }
      
      hideLoading();
      toast(T('已重新開始，角色狀態已重置'), 'success');
      
      // 重新載入故事
      await openStory(story.id);
      
    } catch(err) {
      hideLoading();
      console.error('重新開始失敗:', err);
      toast(T('重新開始失敗: ') + err.message, 'error');
    }
  }, true);
}

function closeAll(){
  document.getElementById('overlay').classList.remove('active');
  document.getElementById('sheet').classList.remove('active');
  // 關閉所有 active 的 modal
  document.querySelectorAll('.modal.active').forEach(modal => {
    modal.classList.remove('active');
  });
  hideMenu();
  // 重置角色編輯狀態
  editingCharacterId = null;
  currentCharacterId = null;  // 🔧 修復Bug #4: 清理currentCharacterId避免狀態泄漏
}
document.addEventListener('click',e=>{if(!e.target.closest('.context-menu')&&!e.target.closest('.nav-btn'))hideMenu();});

// Modal
function showModal(id){document.getElementById('overlay').classList.add('active');document.getElementById(id).classList.add('active');}
function closeModal(id){
  document.getElementById('overlay').classList.remove('active');
  document.getElementById(id).classList.remove('active');
  
  // 特殊處理：角色編輯模態框關閉時重置狀態
  if(id === 'char-add-modal'){
    const titleSpan = document.getElementById('char-modal-title');
    if(titleSpan) titleSpan.textContent = '➕ 添加角色';
    const modal = document.getElementById('char-add-modal');
    if(modal){
      const confirmBtn = modal.querySelector('.modal-btn.confirm');
      if(confirmBtn) confirmBtn.onclick = saveCharacterManual;
    }
    currentCharacterId = null;
  }
}
// 取消回調變量
let cancelCb = null;

function showConfirm(msg,cb,danger=false,title='確認',onCancel=null){
  document.getElementById('confirm-title').textContent=title;
  const contentEl = document.getElementById('confirm-content');
  contentEl.textContent=msg;
  contentEl.style.whiteSpace=title==='確認'?'normal':'pre-wrap';
  contentEl.style.maxHeight='50vh';
  contentEl.style.overflowY='auto';
  const b=document.getElementById('confirm-btn');
  const cancelBtn = document.querySelector('#confirm-modal .modal-btn.cancel');
  b.className=danger?'modal-btn danger':'modal-btn confirm';
  b.style.display=cb?'':'none';
  // 當沒有確認回調時，將取消按鈕改為"關閉"
  cancelBtn.textContent = cb ? '取消' : '關閉';
  confirmCb=cb;
  cancelCb=onCancel;  // 保存取消回調
  showModal('confirm-modal');
}
function confirmAction(){closeModal('confirm-modal');if(confirmCb){confirmCb();confirmCb=null;}cancelCb=null;}
function cancelConfirm(){closeModal('confirm-modal');if(cancelCb){cancelCb();cancelCb=null;}confirmCb=null;}
function showInputDialog(title,ph,cb){document.getElementById('input-title').textContent=title;document.getElementById('modal-input').placeholder=ph;document.getElementById('modal-input').value='';inputCb=cb;showModal('input-modal');}
function confirmInput(){const v=document.getElementById('modal-input').value.trim();closeModal('input-modal');if(inputCb){inputCb(v);inputCb=null;}}

// 消息操作
async function markForeshadow(){hideMenu();showInputDialog('標記伏筆','輸入伏筆標題',async t=>{if(!t)return;const f={id:crypto.randomUUID(),storyId:story.id,messageId:selMsgId,title:t,description:'',isResolved:false,mentionCount:0,timeLabel:story.storyTime,createdAt:Date.now()};await db.foreshadowing.put(f);toast(T('伏筆已標記'),'success');});}
function copyMsg(){hideMenu();const m=msgs.find(x=>x.id===selMsgId);if(m){navigator.clipboard.writeText(m.content);toast(T('已複製'),'success');}}

// 刪除消息
function deleteMsg(){
  hideMenu();
  showConfirm('確定要刪除這條消息嗎？此操作不可撤銷。',async()=>{
    const idx=msgs.findIndex(m=>m.id===selMsgId);
    if(idx===-1)return;
    await db.messages.delete(selMsgId);
    msgs.splice(idx,1);
    const el=document.querySelector(`.msg[data-id="${selMsgId}"]`);
    if(el)el.remove();
    toast(T('消息已刪除'),'success');
  });
}

// 編輯消息
function editMsg(){
  hideMenu();
  const m=msgs.find(x=>x.id===selMsgId);
  if(!m)return;
  document.getElementById('edit-msg-content').value=m.content;
  showModal('edit-msg-modal');
}
async function saveEditMsg(){
  const content=document.getElementById('edit-msg-content').value.trim();
  if(!content){toast(T('內容不能為空'),'warning');return;}
  const m=msgs.find(x=>x.id===selMsgId);
  if(!m)return;
  m.content=content;
  await db.messages.update(selMsgId,{content});

  // 修复：重新渲染所有消息以正确解析JSON和角色状态
  renderMsgs();

  closeModal('edit-msg-modal');
  toast(T('消息已更新'),'success');
}

// 重新生成
function regenerateMsg(){
  hideMenu();
  const m=msgs.find(x=>x.id===selMsgId);
  if(!m||m.role!=='assistant'){toast(T('只能重新生成 AI 消息'),'warning');return;}
  document.getElementById('regen-note').value='';
  showModal('regen-modal');
}

// 重新發送
function resendMsg(){
  hideMenu();
  const m=msgs.find(x=>x.id===selMsgId);
  if(!m)return;
  if(m.role!=='user'){toast(T('只能重新發送用戶消息'),'warning');return;}
  // 將消息內容填入輸入框
  const input=document.getElementById('user-input');
  if(input){
    input.value=m.content;
    input.focus();
    toast(T('消息內容已填入輸入框'),'success');
  }
}
async function doRegenerate(){
  closeModal('regen-modal');
  if(generating){toast(T('正在生成中'),'warning');return;}
  const note=document.getElementById('regen-note').value.trim();
  const idx=msgs.findIndex(m=>m.id===selMsgId);
  if(idx===-1)return;
  
  // 找到這條消息之前的用戶消息
  let userMsg='';
  for(let i=idx-1;i>=0;i--){
    if(msgs[i].role==='user'){userMsg=msgs[i].content;break;}
  }
  if(note)userMsg+='\n\n[補充說明：'+note+']';
  
  // 刪除當前消息
  await db.messages.delete(selMsgId);
  msgs.splice(idx,1);
  const el=document.querySelector(`.msg[data-id="${selMsgId}"]`);
  if(el)el.remove();
  
  // 重新生成
  generating=true;
  showTyping();
  try{
    const resp=await callApi(userMsg);
    hideTyping();
    const aiMsg={id:crypto.randomUUID(),storyId:story.id,branchId:story.currentBranchId,role:'assistant',content:resp.content,tokens:resp.tokens,createdAt:Date.now()};
    await db.messages.add(aiMsg);
    msgs.push(aiMsg);
    await typewriter(aiMsg);
    toast(T('重新生成完成'),'success');
  }catch(e){
    hideTyping();
    toast('生成失敗: '+e.message,'error');
  }
  generating=false;
}

// 回溯到此
function rollbackTo(){
  hideMenu();
  const idx=msgs.findIndex(m=>m.id===selMsgId);
  if(idx===-1)return;
  const deleteCount=msgs.length-idx-1;
  if(deleteCount===0){toast(T('已經是最新消息'),'info');return;}
  showConfirm(`確定要回溯到此消息嗎？將刪除之後的 ${deleteCount} 條消息。`,async()=>{
    const toDelete=msgs.slice(idx+1).map(m=>m.id);
    await db.messages.bulkDelete(toDelete);
    msgs=msgs.slice(0,idx+1);
    renderMsgs();
    toast(T('已回溯'),'success');
  });
}

// 記憶管理
async function showMemoryManager(){
  closeAll();
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  try {
    // 計算 Token 估算
    let totalChars = 0;
    msgs.forEach(m => totalChars += (m.content || '').length);
    // 粗略估算：中文約 1.5-2.5 字符/token（因模型而異）
    // 此處使用 2 作為中間值，僅供參考
    // 注意：實際 token 數可能因中英文混合、標點符號等因素有所差異
    const estimatedTokens = Math.round(totalChars / 2);
    const tokenColor = estimatedTokens > 8000 ? 'var(--error)' : estimatedTokens > 4000 ? 'var(--warning)' : 'var(--success)';

    // 計算受保護消息數
    const protectedMsgIds = new Set();

    try {
      const foreshadows = await db.foreshadowing.where('storyId').equals(story.id).toArray();
      foreshadows.forEach(f => protectedMsgIds.add(f.messageId));
    } catch(e) {
      console.warn('[Memory] 加載伏筆失敗:', e);
    }

    try {
      const bookmarks = await db.bookmarks.where('storyId').equals(story.id).toArray();
      bookmarks.forEach(b => protectedMsgIds.add(b.messageId));
    } catch(e) {
      console.warn('[Memory] 加載書籤失敗:', e);
    }

    try {
      const plotTags = await db.plotTags.where('storyId').equals(story.id).toArray();
      plotTags.forEach(t => protectedMsgIds.add(t.messageId));
    } catch(e) {
      console.warn('[Memory] 加載標籤失敗:', e);
    }

    // 計算滾動摘要數
    const rollingSummaries = (story.rollingSummaries || []).length;

    // 更新 UI - 添加安全檢查
    const updateElement = (id, value) => {
      const el = document.getElementById(id);
      if(el) el.textContent = value;
    };

    updateElement('memory-msg-count', msgs.length);
    updateElement('memory-compressed', story.compressedCount || 0);
    updateElement('memory-summary-count', story.summaries?.length || 0);
    updateElement('memory-rolling-count', rollingSummaries);

    const tokenEl = document.getElementById('memory-token-estimate');
    if(tokenEl){
      tokenEl.innerHTML = `≈ <span style="color:${tokenColor}">${fmtNum(estimatedTokens)}</span> tokens`;
    }

    const protectedInfo = document.getElementById('memory-protected-info');
    if(protectedInfo){
      if(protectedMsgIds.size > 0){
        protectedInfo.textContent = `⚠️ ${protectedMsgIds.size} 條重要消息受保護（伏筆/書籤/標籤）`;
        protectedInfo.style.display = '';
      } else {
        protectedInfo.style.display = 'none';
      }
    }

    // 初始化滾動摘要設置
    const rollingEnabled = story.rollingEnabled || false;
    const rollingInterval = story.rollingInterval || 30;
    const rollingToggle = document.getElementById('tog-rolling-summary');
    if(rollingToggle){
      rollingToggle.classList.toggle('active', rollingEnabled);
    }
    const rollingIntervalEl = document.getElementById('rolling-interval');
    if(rollingIntervalEl){
      rollingIntervalEl.value = rollingInterval;
    }

    // 加載章節選項
    try {
      await updateCompressOptions();
    } catch(e) {
      console.warn('[Memory] 加載章節選項失敗:', e);
    }

    // 重置選項卡
    switchMemTab('compress');

    showModal('memory-modal');

  } catch(e) {
    console.error('[Memory] 記憶管理加載失敗:', e);
    toast('記憶管理加載失敗: ' + e.message, 'error');
  }
}

// 切換記憶管理選項卡
function switchMemTab(tab){
  ['compress','rolling','search','viz','analyze'].forEach(t => {
    document.getElementById('mem-tab-'+t).classList.toggle('secondary', t===tab);
    document.getElementById('mem-tab-'+t).style.background = t===tab ? '' : 'var(--bg-tertiary)';
    document.getElementById('mem-panel-'+t).style.display = t===tab ? '' : 'none';
  });
  // 更新按鈕文字
  const btn = document.getElementById('mem-compress-btn');
  if(tab === 'compress'){
    btn.textContent = '🤖 智能壓縮';
    btn.onclick = compressMemory;
    btn.style.display = '';
  } else {
    btn.style.display = 'none';
  }

  // 如果切換到可視化標籤，更新數據
  if(tab === 'viz'){
    updateMemoryViz();
  }
}

// 更新壓縮選項
async function updateCompressOptions(){
  const mode = document.getElementById('compress-mode').value;
  document.getElementById('compress-count-group').style.display = mode === 'count' ? '' : 'none';
  document.getElementById('compress-chapter-group').style.display = mode === 'chapter' ? '' : 'none';
  document.getElementById('compress-manual-group').style.display = mode === 'manual' ? '' : 'none';

  if(mode === 'chapter' && story){
    const chapters = await db.chapters.where('storyId').equals(story.id).sortBy('order');
    const select = document.getElementById('compress-chapter');
    if(chapters.length === 0){
      select.innerHTML = '<option value="">暫無章節，請先添加章節</option>';
    } else {
      select.innerHTML = chapters.map((ch, i) => 
        `<option value="${ch.messageId}">第 ${i+1} 章：${esc(ch.title)}</option>`
      ).join('');
    }
  }
}

// 切換滾動摘要
async function toggleRollingSummary(){
  if(!story) return;
  const toggle = document.getElementById('tog-rolling-summary');
  const enabled = !toggle.classList.contains('active');
  toggle.classList.toggle('active', enabled);
  
  const interval = parseInt(document.getElementById('rolling-interval').value) || 30;
  await db.stories.update(story.id, { rollingEnabled: enabled, rollingInterval: interval });
  story.rollingEnabled = enabled;
  story.rollingInterval = interval;

  toast(enabled ? '已啟用自動滾動摘要' : '已關閉自動滾動摘要', 'success');
}

// 保存滾動摘要間隔
async function saveRollingInterval(){
  if(!story) return;
  const interval = parseInt(document.getElementById('rolling-interval').value) || 30;
  await db.stories.update(story.id, { rollingInterval: interval });
  story.rollingInterval = interval;
}

// 記憶壓縮臨時數據
let pendingCompressData = null;

// 全局變量：手動選擇的消息ID
let manualSelectedMsgIds = new Set();

// 壓縮操作鎖（防止競態條件）
let isCompressing = false;

// 通用安全更新 UI 元素的輔助函數
function safeUpdateElement(id, value){
  const el = document.getElementById(id);
  if(el) el.textContent = value;
}

// 顯示手動選擇消息的Modal
async function showManualSelectModal(){
  if(!story || !msgs || msgs.length === 0){
    toast('暫無消息可選擇','warning');
    return;
  }

  // 獲取受保護的消息 ID
  const protectedMsgIds = new Set();
  try{
    const foreshadows = await db.foreshadowing.where('storyId').equals(story.id).toArray();
    const bookmarks = await db.bookmarks.where('storyId').equals(story.id).toArray();
    const plotTags = await db.plotTags.where('storyId').equals(story.id).toArray();
    foreshadows.forEach(f => f.messageId && protectedMsgIds.add(f.messageId));
    bookmarks.forEach(b => b.messageId && protectedMsgIds.add(b.messageId));
    plotTags.forEach(t => t.messageId && protectedMsgIds.add(t.messageId));
  }catch(e){
    console.error('獲取保護消息失敗:', e);
  }

  // 渲染消息列表
  const listEl = document.getElementById('manual-select-list');
  if(!listEl){
    console.error('manual-select-list not found');
    return;
  }

  listEl.innerHTML = msgs.map((msg, idx) => {
    const isProtected = protectedMsgIds.has(msg.id);
    const isSelected = manualSelectedMsgIds.has(msg.id);
    const isUser = msg.role === 'user';
    const preview = msg.content.slice(0, 100);
    const floor = idx + 1;

    return `
    <div class="msg-select-item" style="padding:10px;margin-bottom:8px;background:var(--bg-tertiary);border-radius:8px;display:flex;align-items:flex-start;gap:10px;${isProtected?'opacity:0.5;':''}" data-msg-id="${escAttr(msg.id)}">
      <input type="checkbox" class="msg-select-checkbox" data-msg-id="${escAttr(msg.id)}" ${isSelected?'checked':''} ${isProtected?'disabled':''} onchange="updateManualSelectCount()" style="margin-top:4px;cursor:${isProtected?'not-allowed':'pointer'}">
      <div style="flex:1;min-width:0">
        <div style="font-size:11px;color:var(--text-tertiary);margin-bottom:4px">
          #${floor} ${isUser?'玩家':'AI'} · ${new Date(msg.createdAt).toLocaleString()}
          ${isProtected?' <span style="color:var(--warning)">🔒 受保護</span>':''}
        </div>
        <div style="font-size:12px;line-height:1.4;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical">${escHtml(preview)}</div>
      </div>
    </div>
    `;
  }).join('');

  updateManualSelectCount();
  showModal('manual-select-modal');
}

// 更新手動選擇計數
function updateManualSelectCount(){
  const checkboxes = document.querySelectorAll('.msg-select-checkbox:checked');
  const count = checkboxes.length;

  // 更新Modal內的計數
  const modalCount = document.getElementById('modal-selected-count');
  if(modalCount) modalCount.textContent = count;

  // 更新記憶管理頁面的計數
  const pageCount = document.getElementById('manual-select-count');
  if(pageCount) pageCount.textContent = count;

  // 更新全局變量
  manualSelectedMsgIds.clear();
  checkboxes.forEach(cb => {
    manualSelectedMsgIds.add(cb.dataset.msgId);
  });
}

// 全選消息
function selectAllMessages(){
  const checkboxes = document.querySelectorAll('.msg-select-checkbox:not(:disabled)');
  checkboxes.forEach(cb => cb.checked = true);
  updateManualSelectCount();
}

// 取消全選
function unselectAllMessages(){
  const checkboxes = document.querySelectorAll('.msg-select-checkbox');
  checkboxes.forEach(cb => cb.checked = false);
  updateManualSelectCount();
}

// 選擇前50條消息
function selectOldMessages(){
  const checkboxes = document.querySelectorAll('.msg-select-checkbox:not(:disabled)');
  const count = Math.min(50, checkboxes.length);
  for(let i = 0; i < count; i++){
    checkboxes[i].checked = true;
  }
  updateManualSelectCount();
}

// 確認手動選擇
function confirmManualSelection(){
  if(manualSelectedMsgIds.size === 0){
    toast('請至少選擇一條消息','warning');
    return;
  }

  closeModal('manual-select-modal');
  toast(`已選擇 ${manualSelectedMsgIds.size} 條消息`,'success');
}

async function compressMemory(){
  // 防止重複觸發壓縮操作
  if(isCompressing){
    toast('正在處理壓縮操作，請稍候...', 'warning');
    return;
  }

  // 安全檢查
  if(!msgs || msgs.length === 0){
    toast('沒有可壓縮的消息', 'info');
    return;
  }

  const modeEl = document.getElementById('compress-mode');
  if(!modeEl){
    toast('界面未正確加載，請重試', 'error');
    return;
  }

  const mode = modeEl.value;
  let count = 0;
  let toCompress = [];

  // 獲取受保護的消息 ID
  const protectedMsgIds = new Set();
  const foreshadows = await db.foreshadowing.where('storyId').equals(story.id).toArray();
  const bookmarks = await db.bookmarks.where('storyId').equals(story.id).toArray();
  const plotTags = await db.plotTags.where('storyId').equals(story.id).toArray();
  foreshadows.forEach(f => protectedMsgIds.add(f.messageId));
  bookmarks.forEach(b => protectedMsgIds.add(b.messageId));
  plotTags.forEach(t => protectedMsgIds.add(t.messageId));

  // 保護標記為重要的消息
  msgs.forEach(m => {
    if(m.isImportant){
      protectedMsgIds.add(m.id);
    }
  });
  
  if(mode === 'chapter'){
    // 按章節壓縮
    const chapterEl = document.getElementById('compress-chapter');
    if(!chapterEl){
      toast('界面未正確加載，請重試', 'error');
      return;
    }
    const chapterMsgId = chapterEl.value;
    if(!chapterMsgId){
      toast(T('請選擇章節'),'warning');
      return;
    }
    const chapterMsgIdx = msgs.findIndex(m => m.id === chapterMsgId);
    if(chapterMsgIdx <= 0){
      toast(T('該章節之前沒有可壓縮的消息'),'info');
      closeModal('memory-modal');
      return;
    }
    // 壓縮章節之前的消息（排除受保護的）
    for(let i = 0; i < chapterMsgIdx; i++){
      if(!protectedMsgIds.has(msgs[i].id)){
        toCompress.push(msgs[i]);
      }
    }
    count = toCompress.length;
  } else if(mode === 'manual'){
    // 手動選擇
    if(manualSelectedMsgIds.size === 0){
      toast(T('請先選擇要壓縮的消息'),'warning');
      return;
    }

    // 根據選中的ID獲取消息
    for(const msg of msgs){
      if(manualSelectedMsgIds.has(msg.id)){
        toCompress.push(msg);
      }
    }
    count = toCompress.length;
  } else {
    // 按數量壓縮
    const countEl = document.getElementById('compress-count');
    if(!countEl){
      toast('界面未正確加載，請重試', 'error');
      return;
    }
    const option = countEl.value;
    let targetCount = parseInt(option) || 10;
    if(option === 'all') targetCount = Math.max(0, msgs.length - 20);

    // 從最早的消息開始，排除受保護的
    for(let i = 0; i < msgs.length && toCompress.length < targetCount; i++){
      if(!protectedMsgIds.has(msgs[i].id)){
        toCompress.push(msgs[i]);
      }
    }
    count = toCompress.length;
  }
  
  if(count <= 0){
    toast(T('沒有可壓縮的消息（重要消息已受保護）'),'info');
    closeModal('memory-modal');
    return;
  }

  // 顯示確認
  let skipped = 0;
  if(mode === 'chapter'){
    const chapterEl = document.getElementById('compress-chapter');
    if(chapterEl){
      const chapterMsgIdx = msgs.findIndex(m => m.id === chapterEl.value);
      if(chapterMsgIdx >= 0){
        skipped = chapterMsgIdx - count;
      }
    }
  } else if(mode === 'manual'){
    skipped = manualSelectedMsgIds.size - count;
  } else {
    const countEl = document.getElementById('compress-count');
    const targetCount = countEl ?
      (countEl.value === 'all' ? Math.max(0, msgs.length - 20) : (parseInt(countEl.value) || 10)) : 10;
    skipped = targetCount - count;
  }

  let confirmMsg = `將壓縮 ${count} 條消息`;
  if(skipped > 0){
    confirmMsg += `（已跳過 ${skipped} 條受保護消息）`;
  }
  if(mode === 'manual'){
    confirmMsg += '\n\n已選擇的消息將被合併成一條智能摘要。';
  }
  confirmMsg += '\n\nAI 將生成智能摘要保留關鍵信息。確定繼續？';
  
  // 先關閉記憶管理界面，再顯示確認對話框
  closeModal('memory-modal');
  
  showConfirm(confirmMsg, async () => {
    // 設置壓縮鎖
    isCompressing = true;

    showLoading('AI 正在生成智能摘要...');
    try{
      // 壓縮前保存角色快照
      await saveCharacterSnapshot();

      // 使用 AI 生成智能摘要
      let summary;
      try {
        summary = await generateAISummary(toCompress);
      } catch(aiError) {
        console.warn('AI 摘要生成失敗，使用簡單摘要:', aiError);
        summary = generateSimpleSummary(toCompress);
      }

      hideLoading();

      // 保存待壓縮數據，顯示預覽讓用戶編輯
      pendingCompressData = {
        toCompress,
        count,
        summary
      };

      // 顯示摘要預覽
      const previewEl = document.getElementById('summary-preview-content');
      if(!previewEl){
        hideLoading();
        isCompressing = false;
        toast('預覽界面加載失敗，請重試', 'error');
        return;
      }
      previewEl.value = summary;
      showModal('summary-preview-modal');

    }catch(e){
      hideLoading();
      isCompressing = false; // 發生錯誤時釋放鎖
      toast('生成摘要失敗: '+e.message,'error');
    }
  });
}

// 取消摘要預覽
function cancelSummaryPreview(){
  // 檢測狀態衝突
  if(pendingCompressSummariesData && pendingCompressData){
    console.error('[Preview] 狀態衝突：兩個壓縮操作同時存在');
    // 清理所有狀態
    pendingCompressSummariesData = null;
    pendingCompressData = null;
    pendingMergeSummariesData = null;
    isCompressing = false;
    manualSelectedSummaryIndices.clear();
    closeModal('summary-preview-modal');
    toast('狀態異常，已重置','warning');
    return;
  }

  // 判斷是壓縮記憶還是壓縮摘要還是合併摘要
  if(pendingMergeSummariesData){
    pendingMergeSummariesData = null;
    manualSelectedSummaryIndices.clear();
    closeModal('summary-preview-modal');
    toast('已取消合併','info');
  } else if(pendingCompressSummariesData){
    cancelSummariesCompress();
  } else if(pendingCompressData) {
    closeModal('summary-preview-modal');
    pendingCompressData = null;
    isCompressing = false; // 釋放壓縮鎖
    toast(T('已取消壓縮'),'info');
  } else {
    closeModal('summary-preview-modal');
  }
}

// 確認壓縮摘要
async function confirmSummaryCompress(){
  // 檢測狀態衝突
  if(pendingCompressSummariesData && pendingCompressData){
    console.error('[Preview] 狀態衝突：兩個壓縮操作同時存在');
    pendingCompressSummariesData = null;
    pendingCompressData = null;
    pendingMergeSummariesData = null;
    isCompressing = false;
    manualSelectedSummaryIndices.clear();
    closeModal('summary-preview-modal');
    toast('狀態異常，已重置','warning');
    return;
  }

  // 判斷是合併摘要、壓縮摘要還是壓縮記憶
  if(pendingMergeSummariesData){
    await confirmMergeSummariesAfterPreview();
    return;
  }

  if(pendingCompressSummariesData){
    await confirmSummariesCompressAfterPreview();
    return;
  }

  if(!pendingCompressData){
    toast(T('沒有待壓縮的數據'),'error');
    closeModal('summary-preview-modal');
    return;
  }

  const { toCompress, count } = pendingCompressData;
  const previewEl = document.getElementById('summary-preview-content');
  if(!previewEl){
    toast('預覽界面異常，請重試', 'error');
    closeModal('summary-preview-modal');
    pendingCompressData = null;
    isCompressing = false;
    return;
  }
  const editedSummary = previewEl.value.trim();

  if(!editedSummary){
    toast(T('摘要內容不能為空'),'warning');
    return;
  }
  
  showLoading('正在壓縮消息...');
  
  try{
    // 刪除舊消息
    const ids = toCompress.map(m => m.id);
    await db.messages.bulkDelete(ids);
    msgs = msgs.filter(m => !ids.includes(m.id));
    
    // 保存摘要到故事
    const summaries = story.summaries || [];
    summaries.push({
      content: editedSummary,
      createdAt: Date.now(),
      count,
      isAI: true,
      type: 'compressed'
    });
    await db.stories.update(story.id, {summaries, compressedCount: (story.compressedCount||0)+count});
    story.summaries = summaries;
    story.compressedCount = (story.compressedCount||0)+count;
    
    renderMsgs();
    hideLoading();
    closeModal('summary-preview-modal');
    pendingCompressData = null;

    // 清空手動選擇集（避免幽靈選擇）
    manualSelectedMsgIds.clear();

    // 釋放壓縮鎖
    isCompressing = false;

    // 顯示成功提示，告知用戶可以編輯
    showConfirm(
      `✅ 已成功壓縮 ${count} 條消息！\n\n摘要已保存。如需修改，可前往「記憶管理」→「📊 查看」編輯摘要內容。`,
      null, false, '壓縮完成'
    );
  }catch(e){
    hideLoading();
    isCompressing = false; // 釋放壓縮鎖
    toast('壓縮失敗: '+e.message,'error');
  }
}

// v18: AI 智能摘要生成
async function generateAISummary(messages){
  const preset = await db.apiPresets.filter(p=>p.isActive).first();
  if(!preset || !preset.apiKey){
    throw new Error('未配置 API');
  }
  
  // 構建要摘要的內容
  const content = messages.map(m => {
    const role = m.role === 'user' ? '【玩家行動】' : '【劇情發展】';
    return `${role}\n${m.content}`;
  }).join('\n\n---\n\n');
  
  // 不限制長度（注意：內容過長可能超出 API token 限制）
  const truncatedContent = content;
  
  const summaryPrompt = `請為以下互動小說片段生成一份結構化摘要。這份摘要將用於幫助 AI 在後續劇情中保持連貫性。

【要摘要的內容】
${truncatedContent}

【摘要要求】
請按以下格式輸出摘要（總長度 1000-1500 字）：

## 📖 劇情概要
（用 3-4 段話詳細概述主要事件發展，300-400字）

## 👥 角色動態
（列出出現的重要角色及其狀態變化、關係變化、心理變化，300-400字）

## 🔑 關鍵信息
（列出重要的地點、物品、線索、約定、伏筆等需要記住的細節，200-300字）

## ⚡ 當前局勢
（詳細描述目前的處境、待解決的問題、可能的發展方向，200-300字）

**🚨 極其重要的要求：**
1. 你必須完整輸出所有 4 個部分（📖 劇情概要、👥 角色動態、🔑 關鍵信息、⚡ 當前局勢）
2. 每個部分都必須達到指定字數，不可提前結束
3. 你有 16000 tokens 的額度，完全足夠輸出 1500 字的中文內容
4. 請一次性完整輸出所有內容，不要中途停止
5. 如果內容不夠詳細，請補充更多細節、對話、情緒描寫

現在開始輸出完整的摘要：`;

  // 調用 AI
  let response;
  if(preset.type === 'anthropic'){
    response = await callAnthropicDirect(preset, summaryPrompt);
  } else if(preset.type === 'openai'){
    response = await callOpenAIDirect(preset, summaryPrompt);
  } else {
    response = await callCustomDirect(preset, summaryPrompt);
  }

  return response.content;
}

// 直接調用 API（不帶故事上下文）
async function callAnthropicDirect(p, prompt){
  const r = await fetch('https://api.anthropic.com/v1/messages',{
    method:'POST',
    headers:{
      'Content-Type':'application/json',
      'x-api-key':p.apiKey,
      'anthropic-version':'2023-06-01',
      'anthropic-dangerous-direct-browser-access':'true'
    },
    body:JSON.stringify({
      model: p.model,
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages: [{role:'user', content: prompt}]
    })
  });
  if(!r.ok){
    const e = await r.json().catch(()=>({}));
    throw new Error(e.error?.message || `API錯誤 (${r.status})`);
  }
  const d = await r.json();
  return {content: d.content[0].text};
}

async function callOpenAIDirect(p, prompt){
  const r = await fetch('https://api.openai.com/v1/chat/completions',{
    method:'POST',
    headers:{
      'Content-Type':'application/json',
      'Authorization':'Bearer '+p.apiKey
    },
    body:JSON.stringify({
      model: p.model,
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages: [{role:'user', content: prompt}]
    })
  });
  if(!r.ok){
    const e = await r.json().catch(()=>({}));
    throw new Error(e.error?.message || `API錯誤 (${r.status})`);
  }
  const d = await r.json();
  return {content: d.choices[0].message.content};
}

async function callCustomDirect(p, prompt){
  const autoComplete = p.urlAutoComplete !== false;
  const apiUrl = normalizeApiUrl(p.url, autoComplete, p.model);

  // 智能判斷格式：如果 URL 包含 /messages，使用 Anthropic 格式，否則使用 OpenAI 格式
  const isAnthropicFormat = apiUrl.includes('/messages') || apiUrl.includes('/anthropic');

  let requestBody;
  let headers = {
    'Content-Type':'application/json',
    'Authorization':'Bearer '+p.apiKey
  };

  if(isAnthropicFormat){
    // Anthropic 格式
    headers['anthropic-version'] = '2023-06-01';
    requestBody = {
      model: p.model,
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages: [{role:'user', content: prompt}]
    };
  } else {
    // OpenAI 格式
    requestBody = {
      model: p.model,
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages: [{role:'user', content: prompt}]
    };
  }

  const r = await fetch(apiUrl,{
    method:'POST',
    headers: headers,
    body:JSON.stringify(requestBody)
  });
  if(!r.ok){
    const e = await r.json().catch(()=>({}));
    throw new Error(e.error?.message || `API錯誤 (${r.status})`);
  }
  const d = await r.json();

  // 根據格式解析回應
  let content;
  if(isAnthropicFormat){
    // Anthropic 格式：d.content[0].text
    content = d.content?.[0]?.text || d.choices?.[0]?.message?.content || d.response || '';
  } else {
    // OpenAI 格式：d.choices[0].message.content
    content = d.choices?.[0]?.message?.content || d.content?.[0]?.text || d.response || '';
  }

  if(!content) throw new Error('無法解析 API 回應');
  return {content};
}

// 簡單摘要（AI 失敗時的備選方案）
function generateSimpleSummary(messages){
  const events = [];
  const characters = new Set();
  const locations = new Set();
  
  messages.forEach(m => {
    if(m.role === 'user'){
      events.push(`• 玩家：${m.content.slice(0, 80)}${m.content.length > 80 ? '...' : ''}`);
    } else {
      // 提取前 200 字作為摘要
      const preview = m.content.slice(0, 200).replace(/\n+/g, ' ');
      events.push(`• 劇情：${preview}${m.content.length > 200 ? '...' : ''}`);
      
      // 嘗試提取角色名（簡單啟發式）
      const nameMatches = m.content.match(/「[^」]+」|『[^』]+』|【[^】]+】/g);
      if(nameMatches){
        nameMatches.slice(0, 5).forEach(n => characters.add(n));
      }
    }
  });
  
  let summary = '## 📖 劇情概要\n';
  summary += events.slice(0, 15).join('\n') + '\n';
  
  if(characters.size > 0){
    summary += '\n## 👥 出現角色\n';
    summary += Array.from(characters).slice(0, 10).join('、') + '\n';
  }
  
  summary += '\n## ⚠️ 注意\n';
  summary += '此為簡易摘要，部分細節可能遺漏。';
  
  return summary;
}

// v18: 查看摘要
let editSummaryIdx = null;
let editSummaryType = null; // 'compressed' | 'rolling'

function viewSummaries(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  // 重置模態框狀態
  document.querySelector('#summaries-modal .modal-title').textContent = '📚 記憶摘要';
  const clearBtn = document.querySelector('#summaries-modal .modal-btn[onclick="clearAllSummaries()"]');
  if(clearBtn) clearBtn.style.display = '';

  const summaries = story.summaries || [];
  const rollingSummaries = story.rollingSummaries || [];
  const c = document.getElementById('summaries-list');

  if(!summaries.length && !rollingSummaries.length){
    c.innerHTML = '<div class="empty" style="padding:30px"><div class="empty-icon">📭</div><div class="empty-title">暫無摘要</div><div class="empty-desc">壓縮記憶或生成滾動摘要後會顯示在這裡</div></div>';
    showModal('summaries-modal');
    return;
  }
  
  let html = '';
  
  // 壓縮摘要
  if(summaries.length > 0){
    html += '<div style="font-weight:600;margin-bottom:8px;color:var(--primary)">📦 壓縮摘要</div>';
    html += summaries.map((s, idx) => {
      const time = new Date(s.createdAt).toLocaleString();
      const aiTag = s.isAI ? '<span style="background:var(--primary);color:white;padding:2px 6px;border-radius:4px;font-size:11px;margin-left:6px">🤖 AI</span>' : '<span style="background:var(--text-tertiary);color:white;padding:2px 6px;border-radius:4px;font-size:11px;margin-left:6px">簡易</span>';
      const typeTag = s.type === 'merged' ? '<span style="background:var(--warning);color:black;padding:2px 6px;border-radius:4px;font-size:11px;margin-left:6px">已合併</span>' : '';
      return `
        <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:12px">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <span style="font-weight:600">記憶片段 ${idx + 1}${aiTag}${typeTag}</span>
            <span style="font-size:12px;color:var(--text-tertiary)">${time}</span>
          </div>
          <div style="font-size:12px;color:var(--text-secondary);margin-bottom:8px">壓縮了 ${s.count || 0} 條消息</div>
          <div style="font-size:13px;white-space:pre-wrap;line-height:1.6;max-height:200px;overflow-y:auto;background:var(--bg-secondary);padding:10px;border-radius:6px">${esc(s.content)}</div>
          <div style="margin-top:8px;text-align:right;display:flex;justify-content:flex-end;gap:12px">
            <button onclick="editSummary(${idx},'compressed')" style="background:none;border:none;color:var(--primary);cursor:pointer;font-size:12px">✏️ 編輯</button>
            <button onclick="deleteSummary(${idx},'compressed')" style="background:none;border:none;color:var(--error);cursor:pointer;font-size:12px">🗑️ 刪除</button>
          </div>
        </div>
      `;
    }).join('');
  }
  
  // 滾動摘要
  if(rollingSummaries.length > 0){
    html += '<div style="font-weight:600;margin:16px 0 8px;color:var(--success)">📜 滾動摘要（不刪除原文）</div>';
    html += rollingSummaries.map((s, idx) => {
      const time = new Date(s.createdAt).toLocaleString();
      return `
        <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:12px;border-left:3px solid var(--success)">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <span style="font-weight:600">背景摘要 ${idx + 1}</span>
            <span style="font-size:12px;color:var(--text-tertiary)">${time}</span>
          </div>
          <div style="font-size:12px;color:var(--text-secondary);margin-bottom:8px">涵蓋 ${s.msgCount || '?'} 條消息</div>
          <div style="font-size:13px;white-space:pre-wrap;line-height:1.6;max-height:150px;overflow-y:auto;background:var(--bg-secondary);padding:10px;border-radius:6px">${esc(s.content)}</div>
          <div style="margin-top:8px;text-align:right;display:flex;justify-content:flex-end;gap:12px">
            <button onclick="editSummary(${idx},'rolling')" style="background:none;border:none;color:var(--primary);cursor:pointer;font-size:12px">✏️ 編輯</button>
            <button onclick="deleteSummary(${idx},'rolling')" style="background:none;border:none;color:var(--error);cursor:pointer;font-size:12px">🗑️ 刪除</button>
          </div>
        </div>
      `;
    }).join('');
  }
  
  c.innerHTML = html;
  showModal('summaries-modal');
}

// 編輯摘要
function editSummary(idx, type){
  const summaries = type === 'rolling' ? (story.rollingSummaries || []) : (story.summaries || []);
  const summary = summaries[idx];
  if(!summary) return;
  
  editSummaryIdx = idx;
  editSummaryType = type;
  
  const title = type === 'rolling' ? `✏️ 編輯滾動摘要 #${idx + 1}` : `✏️ 編輯記憶片段 #${idx + 1}`;
  document.getElementById('edit-summary-title').textContent = title;
  document.getElementById('edit-summary-content').value = summary.content;
  
  showModal('edit-summary-modal');
}

// 保存摘要編輯
async function saveSummaryEdit(){
  // 使用局部變量避免錯誤時狀態不一致
  const currentIdx = editSummaryIdx;
  const currentType = editSummaryType;

  if(currentIdx === null || !currentType) return;

  const content = document.getElementById('edit-summary-content').value.trim();
  if(!content){
    toast(T('摘要內容不能為空'),'warning');
    return;
  }

  try {
    const field = currentType === 'rolling' ? 'rollingSummaries' : 'summaries';
    const summaries = story[field] || [];

    if(summaries[currentIdx]){
      summaries[currentIdx].content = content;
      summaries[currentIdx].updatedAt = Date.now();

      await db.stories.update(story.id, { [field]: summaries });
      story[field] = summaries;

      closeModal('edit-summary-modal');
      viewSummaries(); // 刷新列表
      toast(T('摘要已更新'), 'success');
    }
  } catch(e) {
    toast('更新失敗: ' + e.message, 'error');
  } finally {
    // 無論成功或失敗都重置全局變量
    editSummaryIdx = null;
    editSummaryType = null;
  }
}

// 刪除單條摘要
async function deleteSummary(idx, type = 'compressed'){
  const typeName = type === 'rolling' ? '滾動摘要' : '記憶摘要';
  if(!confirm(`確定刪除這條${typeName}？刪除後 AI 將無法參考這段記憶。`)) return;
  
  const field = type === 'rolling' ? 'rollingSummaries' : 'summaries';
  const summaries = story[field] || [];
  summaries.splice(idx, 1);
  
  await db.stories.update(story.id, { [field]: summaries });
  story[field] = summaries;

  // 更新UI計數（使用安全更新）
  if(type === 'rolling'){
    safeUpdateElement('memory-rolling-count', summaries.length);
  } else {
    safeUpdateElement('memory-summary-count', summaries.length);
  }

  viewSummaries(); // 刷新列表
  toast(T('摘要已刪除'), 'success');
}

// 清空所有摘要
async function clearAllSummaries(){
  if(!story){return;}
  
  const summaries = story.summaries || [];
  const rollingSummaries = story.rollingSummaries || [];
  const totalCount = summaries.length + rollingSummaries.length;
  
  if(totalCount === 0){
    toast(T('暫無摘要可清空'), 'info');
    return;
  }
  
  let confirmMsg = `確定清空全部摘要嗎？\n\n`;
  if(summaries.length > 0) confirmMsg += `• ${summaries.length} 條壓縮摘要\n`;
  if(rollingSummaries.length > 0) confirmMsg += `• ${rollingSummaries.length} 條滾動摘要\n`;
  confirmMsg += `\n⚠️ 清空後 AI 將完全失去對這些劇情的記憶！`;
  
  if(!confirm(confirmMsg)) return;
  
  await db.stories.update(story.id, {
    summaries: [],
    rollingSummaries: [],
    compressedCount: 0
  });
  story.summaries = [];
  story.rollingSummaries = [];
  story.compressedCount = 0;

  // 清空相關緩存變量
  pendingCompressData = null;
  manualSelectedMsgIds.clear();

  safeUpdateElement('memory-summary-count', '0');
  safeUpdateElement('memory-compressed', '0');
  safeUpdateElement('memory-rolling-count', '0');

  // 刷新記憶可視化數據
  updateMemoryViz();

  closeModal('summaries-modal');
  toast(T('所有摘要已清空'), 'success');
}

// ============ 記憶可視化 ============

// 更新記憶可視化數據
function updateMemoryViz(){
  if(!story) return;

  try {
    const importantCount = msgs.filter(m => m.isImportant).length;
    const summariesCount = (story.summaries || []).length;
    const rollingCount = (story.rollingSummaries || []).length;
    const messagesCount = msgs.length;
    const total = importantCount + summariesCount + rollingCount + messagesCount;

    // 更新上下文數量顯示
    const contextCount = settings.contextCount || 20;
    const actualContextCount = Math.min(contextCount, messagesCount);

    // 安全更新元素
    const updateElement = (id, value) => {
      const el = document.getElementById(id);
      if(el) el.textContent = value;
    };

    const updateStyle = (id, property, value) => {
      const el = document.getElementById(id);
      if(el) el.style[property] = value;
    };

    updateElement('viz-context-count', actualContextCount);
    updateElement('viz-count-important', importantCount);
    updateElement('viz-count-summaries', summariesCount);
    updateElement('viz-count-rolling', rollingCount);
    updateElement('viz-count-messages', messagesCount);

    // 更新進度條（按比例）
    const maxCount = Math.max(importantCount, summariesCount, rollingCount, messagesCount, 1);
    updateStyle('viz-bar-important', 'width', (importantCount / maxCount * 100) + '%');
    updateStyle('viz-bar-summaries', 'width', (summariesCount / maxCount * 100) + '%');
    updateStyle('viz-bar-rolling', 'width', (rollingCount / maxCount * 100) + '%');
    updateStyle('viz-bar-messages', 'width', (messagesCount / maxCount * 100) + '%');

    // 估算 Token 使用
    const importantTokens = importantCount * 150; // 每條重要記憶約150 tokens
    const summariesTokens = summariesCount * 100; // 每條摘要約100 tokens
    const rollingTokens = rollingCount * 80; // 每條滾動摘要約80 tokens
    const contextTokens = actualContextCount * 200; // 實際上下文數量，每條約200 tokens
    const totalTokens = importantTokens + summariesTokens + rollingTokens + contextTokens;

    updateElement('viz-tokens-important', `~${importantTokens} tokens`);
    updateElement('viz-tokens-summaries', `~${summariesTokens + rollingTokens} tokens`);
    updateElement('viz-tokens-context', `~${contextTokens} tokens`);
    updateElement('viz-tokens-total', `~${totalTokens} tokens`);

    // 計算健康度
    let healthScore = 100;
    let healthText = '優秀';
    let healthColor = 'var(--success)';
    let tips = [];

    // 如果消息太多但沒有摘要
    if(messagesCount > 50 && summariesCount === 0 && rollingCount === 0){
      healthScore -= 30;
      tips.push('建議生成摘要以優化記憶管理');
    }

    // 如果Token使用過高
    if(totalTokens > 8000){
      healthScore -= 20;
      tips.push('Token使用較高，建議壓縮部分舊消息');
    }

    // 如果沒有重要記憶標記
    if(messagesCount > 20 && importantCount === 0){
      healthScore -= 15;
      tips.push('可標記關鍵劇情為重要記憶');
    }

    // 如果滾動摘要過多
    if(rollingCount > 15){
      healthScore -= 10;
      tips.push('滾動摘要較多，可考慮合併');
    }

    if(healthScore >= 90){
      healthText = '優秀';
      healthColor = 'var(--success)';
    } else if(healthScore >= 70){
      healthText = '良好';
      healthColor = 'var(--info)';
    } else if(healthScore >= 50){
      healthText = '一般';
      healthColor = 'var(--warning)';
    } else {
      healthText = '需要優化';
      healthColor = 'var(--error)';
    }

    updateElement('viz-health-score', healthText);
    updateStyle('viz-health-score', 'color', healthColor);
    updateStyle('viz-health-bar', 'width', healthScore + '%');
    updateStyle('viz-health-bar', 'background', healthColor);

    const tipsEl = document.getElementById('viz-health-tips');
    if(tipsEl){
      if(tips.length > 0){
        tipsEl.innerHTML = '💡 <strong>建議：</strong><br>' + tips.join('<br>');
      } else {
        tipsEl.innerHTML = '✨ 記憶系統運行良好，無需額外優化！';
      }
    }

  } catch(e) {
    console.error('[Memory] 可視化更新失敗:', e);
  }
}

// 查看所有重要消息
function showImportantMessages(){
  const importantMsgs = msgs.filter(m => m.isImportant);

  if(importantMsgs.length === 0){
    toast('暫無重要記憶標記', 'info');
    return;
  }

  // 檢查數量是否過多
  const warningThreshold = 30;
  let warningHtml = '';
  if(importantMsgs.length > warningThreshold){
    warningHtml = `
      <div style="background:rgba(239,68,68,0.1);border:1px solid var(--error);border-radius:8px;padding:12px;margin-bottom:12px">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <span style="font-size:18px">⚠️</span>
          <span style="font-weight:600;color:var(--error)">重要消息過多警告</span>
        </div>
        <div style="font-size:13px;color:var(--text-secondary);line-height:1.6">
          你已標記 ${importantMsgs.length} 條重要消息，可能會擠占上下文配額。建議保持在 ${warningThreshold} 條以內，取消不再重要的標記。
        </div>
      </div>
    `;
  }

  let html = warningHtml;

  // 添加批量操作按鈕
  html += `
    <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">
      <button class="action-btn secondary" onclick="selectAllImportantMessages()" style="padding:6px 12px;font-size:12px">✅ 全選</button>
      <button class="action-btn secondary" onclick="deselectAllImportantMessages()" style="padding:6px 12px;font-size:12px">❌ 取消全選</button>
      <button class="action-btn secondary" onclick="selectOldImportantMessages()" style="padding:6px 12px;font-size:12px">🕐 選擇舊消息</button>
      <button class="action-btn" onclick="batchRemoveImportantMark()" style="padding:6px 12px;font-size:12px;background:var(--error)">🗑️ 批量取消標記</button>
    </div>
  `;

  importantMsgs.forEach((msg, idx) => {
    const role = msg.role === 'user' ? '【玩家】' : '【劇情】';
    const preview = msg.content.slice(0, 150);
    const daysAgo = Math.floor((Date.now() - msg.createdAt) / 86400000);
    const timeInfo = daysAgo > 0 ? `${daysAgo} 天前` : '今天';

    html += `
      <div class="important-msg-item" data-msg-id="${msg.id}" style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:10px;border-left:3px solid #FFD700;cursor:pointer" onclick="toggleImportantMsgSelection('${msg.id}')">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <input type="checkbox" class="important-msg-checkbox" data-msg-id="${msg.id}" onclick="event.stopPropagation()" onchange="updateImportantMsgSelection('${msg.id}', this.checked)" style="cursor:pointer">
          <div style="font-size:12px;color:var(--text-tertiary);flex:1">⭐ 重要記憶 #${idx + 1} ${role} · ${timeInfo}</div>
        </div>
        <div style="font-size:13px;line-height:1.6">${esc(preview)}${msg.content.length > 150 ? '...' : ''}</div>
        <div style="font-size:11px;color:var(--text-tertiary);margin-top:6px">
          ${new Date(msg.createdAt).toLocaleString('zh-CN')}
        </div>
      </div>
    `;
  });

  // 使用 summaries-list 容器來顯示
  document.getElementById('summaries-list').innerHTML = html;
  document.querySelector('#summaries-modal .modal-title').textContent = `⭐ 重要記憶列表 (${importantMsgs.length} 條)`;

  // 隱藏清空按鈕（重要記憶不應該批量清空）
  const clearBtn = document.querySelector('#summaries-modal .modal-btn[onclick="clearAllSummaries()"]');
  if(clearBtn) clearBtn.style.display = 'none';

  showModal('summaries-modal');
  // 注意：viewSummaries() 會自動重置模態框狀態
}

// 批量管理重要消息的輔助函數
const selectedImportantMsgIds = new Set();

function toggleImportantMsgSelection(msgId){
  const checkbox = document.querySelector(`.important-msg-checkbox[data-msg-id="${msgId}"]`);
  if(checkbox){
    checkbox.checked = !checkbox.checked;
    updateImportantMsgSelection(msgId, checkbox.checked);
  }
}

function updateImportantMsgSelection(msgId, checked){
  if(checked){
    selectedImportantMsgIds.add(msgId);
  } else {
    selectedImportantMsgIds.delete(msgId);
  }
}

function selectAllImportantMessages(){
  document.querySelectorAll('.important-msg-checkbox').forEach(cb => {
    cb.checked = true;
    selectedImportantMsgIds.add(cb.dataset.msgId);
  });
}

function deselectAllImportantMessages(){
  document.querySelectorAll('.important-msg-checkbox').forEach(cb => {
    cb.checked = false;
  });
  selectedImportantMsgIds.clear();
}

function selectOldImportantMessages(){
  const thirtyDaysAgo = Date.now() - (30 * 86400000);
  const importantMsgs = msgs.filter(m => m.isImportant);

  importantMsgs.forEach(msg => {
    if(msg.createdAt < thirtyDaysAgo){
      const checkbox = document.querySelector(`.important-msg-checkbox[data-msg-id="${msg.id}"]`);
      if(checkbox){
        checkbox.checked = true;
        selectedImportantMsgIds.add(msg.id);
      }
    }
  });

  const count = selectedImportantMsgIds.size;
  if(count > 0){
    toast(`已選擇 ${count} 條 30 天前的重要消息`, 'info');
  } else {
    toast('沒有 30 天前的重要消息', 'info');
  }
}

async function batchRemoveImportantMark(){
  if(selectedImportantMsgIds.size === 0){
    toast('請先選擇要取消標記的消息', 'warning');
    return;
  }

  const count = selectedImportantMsgIds.size;
  showConfirm(`確定要取消 ${count} 條消息的重要標記嗎？`, async () => {
    showLoading('正在處理...');

    try {
      // 批量更新數據庫
      for(const msgId of selectedImportantMsgIds){
        await db.messages.update(msgId, { isImportant: false });
        const msgIndex = msgs.findIndex(m => m.id === msgId);
        if(msgIndex >= 0){
          msgs[msgIndex].isImportant = false;
        }
      }

      selectedImportantMsgIds.clear();
      hideLoading();
      closeModal('summaries-modal');
      renderMsgs();
      toast(`✅ 已取消 ${count} 條消息的重要標記`, 'success');
    } catch(e) {
      hideLoading();
      toast('操作失敗: ' + e.message, 'error');
    }
  });
}

// ============ v22 新增：滾動摘要、智能分析、摘要搜索 ============

// 生成滾動摘要（不刪除原文）
async function generateRollingSummary(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(msgs.length < 10){toast(T('消息太少，建議累積更多內容後再生成'),'info');return;}
  
  showLoading('正在生成滾動摘要...');
  try{
    const preset = await db.apiPresets.filter(p=>p.isActive).first();
    if(!preset || !preset.apiKey){
      throw new Error('未配置 API');
    }
    
    // 取最近的消息（排除已有滾動摘要覆蓋的部分）
    const rollingSummaries = story.rollingSummaries || [];
    const lastSummaryMsgIdx = rollingSummaries.length > 0 ? 
      msgs.findIndex(m => m.id === rollingSummaries[rollingSummaries.length - 1].lastMessageId) : -1;
    
    const startIdx = lastSummaryMsgIdx >= 0 ? lastSummaryMsgIdx + 1 : 0;
    const toSummarize = msgs.slice(startIdx);
    
    if(toSummarize.length < 5){
      hideLoading();
      toast(T('距離上次摘要後消息太少，建議繼續遊戲後再生成'),'info');
      return;
    }
    
    // 構建內容
    const content = toSummarize.map(m => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      return `${role} ${m.content.slice(0, 500)}`;
    }).join('\n\n');
    
    const prompt = `請為以下互動小說片段生成一份簡短的背景摘要（200字以內）。這份摘要將作為上下文背景，幫助AI理解故事進展。

【內容】
${content.slice(0, 8000)}

【要求】
- 用 2-3 句話概述主要事件
- 記錄關鍵的角色互動或狀態變化
- 不需要詳細，只需要核心要點
- 直接輸出摘要，不要其他說明`;

    let response;
    if(preset.type === 'anthropic'){
      response = await callAnthropicDirect(preset, prompt);
    } else if(preset.type === 'openai'){
      response = await callOpenAIDirect(preset, prompt);
    } else {
      response = await callCustomDirect(preset, prompt);
    }

    // 保存滾動摘要
    if(msgs.length === 0){
      throw new Error('消息列表為空，無法保存滾動摘要');
    }

    rollingSummaries.push({
      content: response.content,
      createdAt: Date.now(),
      lastMessageId: msgs[msgs.length - 1].id,
      msgCount: toSummarize.length
    });

    await db.stories.update(story.id, { rollingSummaries });
    story.rollingSummaries = rollingSummaries;

    hideLoading();
    const countEl = document.getElementById('memory-rolling-count');
    if(countEl) countEl.textContent = rollingSummaries.length;
    toast(T('滾動摘要已生成（原消息保留）'),'success');
  }catch(e){
    hideLoading();
    toast('生成失敗: '+e.message,'error');
  }
}

// 自動生成滾動摘要（後台運行，不阻塞用戶）
async function autoGenerateRollingSummary(){
  if(!story || !settings.autoSummary) return;
  if(!msgs || msgs.length === 0) return; // 安全檢查

  try {
    const rollingSummaries = story.rollingSummaries || [];

    // 計算距離上次摘要後的消息數
    const lastSummaryMsgIdx = rollingSummaries.length > 0 ?
      msgs.findIndex(m => m.id === rollingSummaries[rollingSummaries.length - 1].lastMessageId) : -1;

    const startIdx = lastSummaryMsgIdx >= 0 ? lastSummaryMsgIdx + 1 : 0;
    const toSummarize = msgs.slice(startIdx);

    // 檢查是否達到自動摘要頻率
    if(toSummarize.length < settings.autoSummaryFrequency) return;

    console.log(`[AutoSummary] 檢測到 ${toSummarize.length} 條新消息，開始自動生成摘要...`);

    const preset = await db.apiPresets.filter(p=>p.isActive).first();
    if(!preset || !preset.apiKey){
      console.warn('[AutoSummary] 未配置 API，跳過自動摘要');
      return;
    }

    // 構建內容
    const content = toSummarize.map(m => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      return `${role} ${m.content.slice(0, 500)}`;
    }).join('\n\n');

    const prompt = `請為以下互動小說片段生成一份簡短的背景摘要（150字以內）。

【內容】
${content.slice(0, 8000)}

【要求】
- 用 2-3 句話概述主要事件
- 記錄關鍵的角色互動或狀態變化
- 不需要詳細，只需要核心要點
- 直接輸出摘要，不要其他說明`;

    let response;
    if(preset.type === 'anthropic'){
      response = await callAnthropicDirect(preset, prompt);
    } else if(preset.type === 'openai'){
      response = await callOpenAIDirect(preset, prompt);
    } else {
      response = await callCustomDirect(preset, prompt);
    }

    // 保存滾動摘要
    rollingSummaries.push({
      content: response.content,
      createdAt: Date.now(),
      lastMessageId: msgs[msgs.length - 1].id,
      msgCount: toSummarize.length,
      auto: true  // 標記為自動生成
    });

    // 限制最大摘要數量，移除最舊的
    const maxLimit = settings.maxRollingSummaries || 10; // 默認最大 10 條
    if(maxLimit > 0 && rollingSummaries.length > maxLimit){
      const removeCount = rollingSummaries.length - maxLimit;
      const removed = rollingSummaries.splice(0, removeCount);
      console.log(`[AutoSummary] 超出最大限制，移除了 ${removed.length} 條舊摘要`);
    }

    await db.stories.update(story.id, { rollingSummaries });
    story.rollingSummaries = rollingSummaries;

    const countEl = document.getElementById('memory-rolling-count');
    if(countEl) countEl.textContent = rollingSummaries.length;

    console.log(`[AutoSummary] 自動摘要已生成，當前共 ${rollingSummaries.length} 條`);
    toast('📝 已自動生成故事摘要', 'info');
  } catch(e) {
    console.error('[AutoSummary] 自動摘要失敗:', e);
    // 靜默失敗，不干擾用戶體驗
  }
}

// 合併多條摘要
async function mergeSummaries(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  
  const summaries = story.summaries || [];
  if(summaries.length < 2){
    toast(T('至少需要 2 條摘要才能合併'),'info');
    return;
  }
  
  showConfirm(`確定要合併 ${summaries.length} 條摘要嗎？\n\nAI 將重新整理所有摘要，生成一份更精簡的統一版本。`, async () => {
    showLoading('AI 正在合併摘要...');
    try{
      const preset = await db.apiPresets.filter(p=>p.isActive).first();
      if(!preset || !preset.apiKey){
        throw new Error('未配置 API');
      }
      
      const allContent = summaries.map((s, i) => {
        const time = new Date(s.createdAt).toLocaleString();
        const msgCount = s.count || 0;
        const tag = s.isAI ? 'AI摘要' : '簡易摘要';
        return `--- 摘要 ${i+1}（${tag}，涵蓋 ${msgCount} 條消息，${time}）---\n${s.content}`;
      }).join('\n\n');

      const totalContentLen = summaries.reduce((sum, s) => sum + (s.content||'').length, 0);
      const targetLen = Math.min(2000, Math.max(300, Math.round(totalContentLen * 0.5)));

      const prompt = `你正在處理一個互動小說的記憶管理系統。以下是多份劇情摘要，請將它們合併整理成一份統一的摘要。

【摘要的用途】
合併後的摘要會注入到 AI 的系統提示中，幫助 AI 記住之前的劇情發展。因此內容必須是客觀的劇情記錄，包含足夠的細節讓 AI 能延續故事。

${allContent.slice(0, 12000)}

【合併要求】
- 保留所有重要的劇情事件、角色互動、場景變化，去除重複內容
- 按時間順序整理，較新的摘要（編號較大）通常包含較新的劇情
- 總長度控制在 ${targetLen} 字左右
- 如果有矛盾信息，以較新的摘要為準
- 使用以下格式：

## 📖 完整劇情回顧
（按時間順序概述所有重要事件）

## 👥 角色狀態
（當前各角色的狀態和關係）

## 🔑 關鍵要點
（需要記住的重要信息、伏筆、未解決的衝突等）

直接輸出合併後的摘要。`;

      let response;
      if(preset.type === 'anthropic'){
        response = await callAnthropicDirect(preset, prompt);
      } else if(preset.type === 'openai'){
        response = await callOpenAIDirect(preset, prompt);
      } else {
        response = await callCustomDirect(preset, prompt);
      }
      
      // 計算總壓縮數
      const totalCount = summaries.reduce((sum, s) => sum + (s.count || 0), 0);
      
      // 用新摘要替換所有舊摘要
      const newSummaries = [{
        content: response.content,
        createdAt: Date.now(),
        count: totalCount,
        isAI: true,
        type: 'merged'
      }];
      
      await db.stories.update(story.id, { summaries: newSummaries });
      story.summaries = newSummaries;

      hideLoading();
      safeUpdateElement('memory-summary-count', '1');
      closeModal('memory-modal');
      toast(T('摘要已合併為一份'),'success');
    }catch(e){
      hideLoading();
      toast('合併失敗: '+e.message,'error');
    }
  });
}

// ========== 手動選擇摘要合併功能 ==========

// 全局變量：手動選擇的摘要索引
let manualSelectedSummaryIndices = new Set();

// 顯示手動選擇摘要合併的Modal
async function showManualMergeSummariesModal(){
  if(!story){
    toast('請先選擇故事','warning');
    return;
  }

  const summaries = story.summaries || [];

  if(summaries.length < 2){
    toast('至少需要 2 條摘要才能合併','info');
    return;
  }

  // 渲染摘要列表
  const listEl = document.getElementById('manual-merge-summaries-list');
  if(!listEl){
    console.error('manual-merge-summaries-list not found');
    return;
  }

  listEl.innerHTML = summaries.map((summary, idx) => {
    const isSelected = manualSelectedSummaryIndices.has(idx);
    const time = new Date(summary.createdAt).toLocaleString();
    const preview = summary.content.slice(0, 150);
    const aiTag = summary.isAI ? '🤖 AI' : '簡易';
    let typeTag = '';
    if(summary.type === 'merged') typeTag = ' 🔗已合併';
    else if(summary.type === 'compressed') typeTag = ' 🗜️已壓縮';

    return `
    <div class="summary-select-item" style="padding:12px;margin-bottom:8px;background:var(--bg-tertiary);border-radius:8px;display:flex;align-items:flex-start;gap:10px" data-summary-idx="${idx}">
      <input type="checkbox" class="summary-select-checkbox" data-summary-idx="${idx}" ${isSelected?'checked':''} onchange="updateSummarySelectCount()" style="margin-top:4px;cursor:pointer">
      <div style="flex:1;min-width:0">
        <div style="font-size:11px;color:var(--text-tertiary);margin-bottom:4px">
          #${idx + 1} ${aiTag}${typeTag} · ${time}
        </div>
        <div style="font-size:12px;color:var(--text-secondary);margin-bottom:6px">
          壓縮了 ${summary.count || 0} 條消息
        </div>
        <div style="font-size:12px;line-height:1.4;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical">${esc(preview)}</div>
      </div>
    </div>
    `;
  }).join('');

  updateSummarySelectCount();
  showModal('manual-merge-summaries-modal');
}

// 更新摘要選擇計數
function updateSummarySelectCount(){
  const checkboxes = document.querySelectorAll('.summary-select-checkbox:checked');
  const count = checkboxes.length;

  const countEl = document.getElementById('summary-selected-count');
  if(countEl) countEl.textContent = count;

  // 更新全局變量
  manualSelectedSummaryIndices.clear();
  checkboxes.forEach(cb => {
    manualSelectedSummaryIndices.add(parseInt(cb.dataset.summaryIdx));
  });
}

// 全選摘要
function selectAllSummaries(){
  const checkboxes = document.querySelectorAll('.summary-select-checkbox');
  checkboxes.forEach(cb => cb.checked = true);
  updateSummarySelectCount();
}

// 取消全選摘要
function unselectAllSummaries(){
  const checkboxes = document.querySelectorAll('.summary-select-checkbox');
  checkboxes.forEach(cb => cb.checked = false);
  updateSummarySelectCount();
}

// 確認手動選擇摘要合併
async function confirmManualMergeSummaries(){
  if(manualSelectedSummaryIndices.size < 2){
    toast('請至少選擇 2 條摘要','warning');
    return;
  }

  const summaries = story.summaries || [];
  const selectedSummaries = Array.from(manualSelectedSummaryIndices)
    .sort((a, b) => a - b)
    .map(idx => summaries[idx]);

  closeModal('manual-merge-summaries-modal');

  showConfirm(`確定要合併 ${selectedSummaries.length} 條摘要嗎？\n\nAI 將重新整理選中的摘要，生成一份更精簡的統一版本。`, async () => {
    showLoading('AI 正在合併摘要...');
    try{
      const preset = await db.apiPresets.filter(p=>p.isActive).first();
      if(!preset || !preset.apiKey){
        throw new Error('未配置 API');
      }

      const allContent = selectedSummaries.map((s, i) => {
        const time = new Date(s.createdAt).toLocaleString();
        const msgCount = s.count || 0;
        const tag = s.isAI ? 'AI摘要' : '簡易摘要';
        return `--- 摘要 ${i+1}（${tag}，涵蓋 ${msgCount} 條消息，${time}）---\n${s.content}`;
      }).join('\n\n');

      const totalContentLen = selectedSummaries.reduce((sum, s) => sum + (s.content||'').length, 0);
      const targetLen = Math.min(2000, Math.max(300, Math.round(totalContentLen * 0.5)));

      const prompt = `你正在處理一個互動小說的記憶管理系統。以下是多份劇情摘要，請將它們合併整理成一份統一的摘要。

【摘要的用途】
合併後的摘要會注入到 AI 的系統提示中，幫助 AI 記住之前的劇情發展。因此內容必須是客觀的劇情記錄，包含足夠的細節讓 AI 能延續故事。

${allContent.slice(0, 12000)}

【合併要求】
- 保留所有重要的劇情事件、角色互動、場景變化，去除重複內容
- 按時間順序整理，較新的摘要（編號較大）通常包含較新的劇情
- 總長度控制在 ${targetLen} 字左右
- 如果有矛盾信息，以較新的摘要為準
- 使用以下格式：

## 📖 完整劇情回顧
（按時間順序概述所有重要事件）

## 👥 角色狀態
（當前各角色的狀態和關係）

## 🔑 關鍵要點
（需要記住的重要信息、伏筆、未解決的衝突等）

直接輸出合併後的摘要。`;

      let response;
      if(preset.type === 'anthropic'){
        response = await callAnthropicDirect(preset, prompt);
      } else if(preset.type === 'openai'){
        response = await callOpenAIDirect(preset, prompt);
      } else {
        response = await callCustomDirect(preset, prompt);
      }

      // 計算總壓縮數
      const totalCount = selectedSummaries.reduce((sum, s) => sum + (s.count || 0), 0);

      hideLoading();

      // 存入待確認數據，顯示預覽
      pendingMergeSummariesData = {
        selectedSummaries,
        selectedIndices: new Set(manualSelectedSummaryIndices),
        totalCount,
        aiContent: response.content
      };

      // 設置預覽 Modal 內容
      document.getElementById('summary-preview-title').textContent = '📝 摘要合併預覽';
      document.getElementById('summary-preview-desc').textContent = `AI 已將 ${selectedSummaries.length} 條摘要合併為以下內容，你可以編輯後再確認：`;
      document.getElementById('summary-preview-content').value = response.content;
      document.getElementById('summary-preview-tips').innerHTML = `
        <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px">
          <span>💡</span><span style="font-weight:600">提示</span>
        </div>
        <div>確認後將刪除選中的 ${selectedSummaries.length} 條舊摘要，替換為此合併摘要。</div>`;
      document.getElementById('summary-preview-confirm-btn').textContent = '確認合併';

      showModal('summary-preview-modal');

    }catch(e){
      hideLoading();
      toast('合併失敗: '+e.message,'error');
    }
  });
}

// 待合併摘要預覽數據
let pendingMergeSummariesData = null;

// 預覽確認後執行摘要合併
async function confirmMergeSummariesAfterPreview(){
  if(!pendingMergeSummariesData){
    toast('沒有待合併的摘要數據','error');
    closeModal('summary-preview-modal');
    return;
  }

  const { selectedSummaries, selectedIndices, totalCount } = pendingMergeSummariesData;
  const contentEl = document.getElementById('summary-preview-content');

  if(!contentEl){
    toast('預覽界面異常，請重試','error');
    closeModal('summary-preview-modal');
    pendingMergeSummariesData = null;
    manualSelectedSummaryIndices.clear();
    return;
  }

  const editedContent = contentEl.value.trim();
  if(!editedContent){
    toast('摘要內容不能為空','warning');
    return;
  }

  showLoading('正在保存合併摘要...');

  try {
    const summaries = story.summaries || [];

    const newSummary = {
      content: editedContent,
      createdAt: Date.now(),
      count: totalCount,
      isAI: true,
      type: 'merged'
    };

    const remainingSummaries = summaries.filter((s, idx) => !selectedIndices.has(idx));
    remainingSummaries.push(newSummary);

    await db.stories.update(story.id, { summaries: remainingSummaries });
    story.summaries = remainingSummaries;

    hideLoading();
    closeModal('summary-preview-modal');
    safeUpdateElement('memory-summary-count', remainingSummaries.length);

    pendingMergeSummariesData = null;
    manualSelectedSummaryIndices.clear();

    toast(`已成功合併 ${selectedSummaries.length} 條摘要為 1 條`,'success');
  } catch(e) {
    hideLoading();
    pendingMergeSummariesData = null;
    toast('合併保存失敗: ' + e.message, 'error');
  }
}

// ========== 手動選擇摘要合併功能結束 ==========

// ========== 手動壓縮摘要功能開始 ==========
// 待壓縮摘要數據
let pendingCompressSummariesData = null;

// 確認壓縮選中的摘要
async function confirmCompressSummaries(){
  if(manualSelectedSummaryIndices.size < 1){
    toast('請至少選擇 1 條摘要','warning');
    return;
  }

  const summaries = story.summaries || [];

  // 驗證選中的索引是否有效
  const validIndices = Array.from(manualSelectedSummaryIndices)
    .filter(idx => idx >= 0 && idx < summaries.length);

  if(validIndices.length < 1){
    toast('請至少選擇 1 條有效摘要','warning');
    manualSelectedSummaryIndices.clear();
    return;
  }

  // 更新選中索引為有效索引
  if(validIndices.length < manualSelectedSummaryIndices.size){
    manualSelectedSummaryIndices.clear();
    validIndices.forEach(idx => manualSelectedSummaryIndices.add(idx));
  }

  const selectedSummaries = validIndices
    .sort((a, b) => a - b)
    .map(idx => summaries[idx]);

  closeModal('manual-merge-summaries-modal');

  showConfirm(`確定要壓縮 ${selectedSummaries.length} 條摘要嗎？\n\nAI 將重新精簡選中的摘要，去除冗餘信息，保留核心要點。\n\n壓縮後會替換原摘要。`, async () => {
    showLoading('AI 正在壓縮摘要...');
    try{
      const preset = await db.apiPresets.filter(p=>p.isActive).first();
      if(!preset || !preset.apiKey){
        throw new Error('未配置 API');
      }

      // 為每個選中的摘要分別壓縮
      const compressedSummaries = [];
      for(let i = 0; i < selectedSummaries.length; i++){
        // 更新進度提示
        if(selectedSummaries.length > 1){
          showLoading(`AI 正在壓縮摘要... (${i+1}/${selectedSummaries.length})`);
        }

        const summary = selectedSummaries[i];

        const prompt = `以下是一份互動小說的劇情摘要，請將其壓縮精簡，去除冗餘信息，保留所有核心要點。

${summary.content.slice(0, 15000)}

【要求】
- 保留所有關鍵劇情、角色狀態、重要物品等核心信息
- 去除冗長描述、重複內容、次要細節
- 總長度控制在原文的 60-70% 左右
- 保持原有格式結構（如有標題、分段等）
- 確保壓縮後仍能完整還原故事脈絡

直接輸出壓縮後的摘要，不要添加任何說明文字。`;

        let response;
        if(preset.type === 'anthropic'){
          response = await callAnthropicDirect(preset, prompt);
        } else if(preset.type === 'openai'){
          response = await callOpenAIDirect(preset, prompt);
        } else {
          response = await callCustomDirect(preset, prompt);
        }

        compressedSummaries.push({
          content: response.content,
          createdAt: Date.now(),
          count: summary.count || 0,
          isAI: true,
          type: 'compressed',
          originalLength: summary.content.length,
          compressedLength: response.content.length
        });
      }

      hideLoading();

      // 保存待壓縮數據，顯示預覽讓用戶確認
      pendingCompressSummariesData = {
        selectedSummaries,
        compressedSummaries,
        selectedIndicesArray: Array.from(manualSelectedSummaryIndices).sort((a, b) => a - b)
      };

      // 計算壓縮率
      const totalOriginal = compressedSummaries.reduce((sum, s) => sum + (s.originalLength || 0), 0);
      const totalCompressed = compressedSummaries.reduce((sum, s) => sum + (s.compressedLength || 0), 0);
      const ratio = totalOriginal > 0 ? ((1 - totalCompressed / totalOriginal) * 100).toFixed(1) : '0.0';

      // 顯示摘要預覽
      const titleEl = document.getElementById('summary-preview-title');
      const descEl = document.getElementById('summary-preview-desc');
      const contentEl = document.getElementById('summary-preview-content');

      if(!titleEl || !descEl || !contentEl){
        hideLoading();
        pendingCompressSummariesData = null;
        toast('預覽界面加載失敗，請重試', 'error');
        return;
      }

      titleEl.textContent = '📦 壓縮摘要預覽';
      descEl.textContent = `AI 已壓縮 ${selectedSummaries.length} 條摘要（節省 ${ratio}% 空間），你可以編輯後再確認：`;

      // 如果只有一條摘要，直接顯示內容；多條則合併顯示
      const previewContent = compressedSummaries.length === 1
        ? compressedSummaries[0].content
        : compressedSummaries.map((s, i) => `=== 摘要 ${i + 1} ===\n${s.content}`).join('\n\n');

      contentEl.value = previewContent;
      showModal('summary-preview-modal');

    }catch(e){
      hideLoading();
      pendingCompressSummariesData = null;
      toast('壓縮失敗: '+e.message,'error');
    }
  });
}

// 取消摘要壓縮預覽
function cancelSummariesCompress(){
  closeModal('summary-preview-modal');
  if(pendingCompressSummariesData){
    pendingCompressSummariesData = null;
    manualSelectedSummaryIndices.clear();
    toast('已取消壓縮摘要','info');
  }
}

// 確認壓縮摘要（預覽後）
async function confirmSummariesCompressAfterPreview(){
  if(!pendingCompressSummariesData){
    toast('沒有待壓縮的摘要數據','error');
    closeModal('summary-preview-modal');
    return;
  }

  const { selectedSummaries, compressedSummaries, selectedIndicesArray } = pendingCompressSummariesData;
  const contentEl = document.getElementById('summary-preview-content');

  if(!contentEl){
    toast('預覽界面異常，請重試','error');
    closeModal('summary-preview-modal');
    pendingCompressSummariesData = null;
    manualSelectedSummaryIndices.clear();
    return;
  }

  const editedContent = contentEl.value.trim();

  if(!editedContent){
    toast('摘要內容不能為空','warning');
    return;
  }

  showLoading('正在保存壓縮摘要...');

  try{
    const summaries = story.summaries || [];

    // 如果用戶編輯了內容，需要更新壓縮摘要
    let finalCompressedSummaries;
    if(compressedSummaries.length === 1){
      // 單條摘要，直接使用編輯內容
      finalCompressedSummaries = [{
        ...compressedSummaries[0],
        content: editedContent,
        compressedLength: editedContent.length
      }];
    } else {
      // 多條摘要，需要拆分編輯內容
      const parts = editedContent.split(/={3,}\s*摘要\s*\d+\s*={3,}\s*/);
      if(parts.length > 1 && parts[0].trim() === ''){
        parts.shift(); // 移除第一個空元素
      }

      if(parts.length === compressedSummaries.length){
        // 用戶保留了分隔符，使用拆分內容
        finalCompressedSummaries = compressedSummaries.map((s, i) => ({
          ...s,
          content: parts[i].trim(),
          compressedLength: parts[i].trim().length
        }));
      } else {
        // 用戶可能刪除了分隔符，使用整體內容更新第一條
        finalCompressedSummaries = compressedSummaries.map((s, i) => {
          if(i === 0){
            return {
              ...s,
              content: editedContent,
              compressedLength: editedContent.length
            };
          }
          return s;
        });
      }
    }

    // 創建新的摘要列表：保留未選中的，替換選中的為壓縮版
    const newSummaries = summaries.map((s, idx) => {
      const selectedIdx = selectedIndicesArray.indexOf(idx);
      if(selectedIdx >= 0 && selectedIdx < finalCompressedSummaries.length){
        return finalCompressedSummaries[selectedIdx];
      }
      return s;
    });

    await db.stories.update(story.id, { summaries: newSummaries });
    story.summaries = newSummaries;

    hideLoading();
    closeModal('summary-preview-modal');
    safeUpdateElement('memory-summary-count', newSummaries.length);

    // 清空選擇和待處理數據
    manualSelectedSummaryIndices.clear();
    pendingCompressSummariesData = null;

    // 計算最終壓縮率
    const totalOriginal = finalCompressedSummaries.reduce((sum, s) => sum + (s.originalLength || 0), 0);
    const totalCompressed = finalCompressedSummaries.reduce((sum, s) => sum + (s.compressedLength || 0), 0);
    const ratio = totalOriginal > 0 ? Math.max(0, ((1 - totalCompressed / totalOriginal) * 100)).toFixed(1) : '0.0';

    toast(`已成功壓縮 ${selectedSummaries.length} 條摘要，節省 ${ratio}% 空間`,'success');
  }catch(e){
    hideLoading();
    pendingCompressSummariesData = null;
    toast('保存壓縮摘要失敗: '+e.message,'error');
  }
}
// ========== 手動壓縮摘要功能結束 ==========

// ========== 記憶搜尋功能開始 ==========

// 執行記憶搜尋
async function executeMemorySearch(){
  if(!story){
    toast('請先選擇故事','warning');
    return;
  }

  const keyword = document.getElementById('memory-search-input').value.trim();
  if(!keyword){
    toast('請輸入搜尋關鍵詞','warning');
    return;
  }

  // 獲取搜尋選項
  const searchMessages = document.getElementById('search-messages').checked;
  const searchSummaries = document.getElementById('search-summaries').checked;
  const searchLorebook = document.getElementById('search-lorebook').checked;
  const importantOnly = document.getElementById('search-important-only').checked;
  const roleFilter = document.getElementById('search-role-filter').value;

  if(!searchMessages && !searchSummaries && !searchLorebook){
    toast('請至少選擇一個搜尋範圍','warning');
    return;
  }

  console.log(`[MemorySearch] 開始搜尋關鍵詞: "${keyword}"`);

  const results = [];

  try {
    // 1. 搜尋消息
    if(searchMessages && msgs && msgs.length > 0){
      msgs.forEach((msg, idx) => {
        // 角色過濾
        if(roleFilter !== 'all' && msg.role !== roleFilter) return;
        // 重要性過濾
        if(importantOnly && !msg.isImportant) return;
        // 關鍵詞匹配（不區分大小寫）
        if(msg.content && msg.content.toLowerCase().includes(keyword.toLowerCase())){
          results.push({
            type: 'message',
            role: msg.role,
            content: msg.content,
            time: msg.createdAt,
            isImportant: msg.isImportant || false,
            floor: idx + 1,
            id: msg.id
          });
        }
      });
    }

    // 2. 搜尋摘要
    if(searchSummaries){
      const summaries = story.summaries || [];
      summaries.forEach((summary, idx) => {
        if(summary.content && summary.content.toLowerCase().includes(keyword.toLowerCase())){
          results.push({
            type: 'summary',
            content: summary.content,
            time: summary.createdAt,
            count: summary.count || 0,
            summaryType: summary.type || 'normal',
            index: idx
          });
        }
      });

      // 搜尋滾動摘要
      const rollingSummaries = story.rollingSummaries || [];
      rollingSummaries.forEach((summary, idx) => {
        if(summary.content && summary.content.toLowerCase().includes(keyword.toLowerCase())){
          results.push({
            type: 'rolling-summary',
            content: summary.content,
            time: summary.createdAt,
            msgCount: summary.msgCount || 0,
            index: idx
          });
        }
      });
    }

    // 3. 搜尋Lorebook
    if(searchLorebook){
      const lorebooks = await db.lorebook.where('storyId').equals(story.id).toArray();
      lorebooks.forEach(lore => {
        const matchName = lore.name && lore.name.toLowerCase().includes(keyword.toLowerCase());
        const matchContent = lore.content && lore.content.toLowerCase().includes(keyword.toLowerCase());
        const matchKeywords = lore.keywords && lore.keywords.some(k => k.toLowerCase().includes(keyword.toLowerCase()));

        if(matchName || matchContent || matchKeywords){
          results.push({
            type: 'lorebook',
            name: lore.name,
            content: lore.content,
            keywords: lore.keywords || [],
            time: lore.createdAt,
            isEnabled: lore.isEnabled,
            id: lore.id
          });
        }
      });
    }

    // 按時間排序（最新的在前）
    results.sort((a, b) => b.time - a.time);

    console.log(`[MemorySearch] 找到 ${results.length} 筆結果`);

    // 顯示結果
    displaySearchResults(results, keyword);

  } catch(e) {
    console.error('[MemorySearch] 搜尋失敗:', e);
    toast('搜尋失敗: ' + e.message, 'error');
  }
}

// 顯示搜尋結果
function displaySearchResults(results, keyword){
  const container = document.getElementById('search-results-container');
  const list = document.getElementById('search-results-list');
  const count = document.getElementById('search-result-count');

  if(results.length === 0){
    container.style.display = '';
    count.textContent = '找到 0 筆';
    list.innerHTML = `
      <div style="text-align:center;padding:40px 20px;color:var(--text-tertiary)">
        <div style="font-size:32px;margin-bottom:12px">🔍</div>
        <div style="font-size:14px">沒有找到包含「${esc(keyword)}」的內容</div>
      </div>
    `;
    return;
  }

  container.style.display = '';
  count.textContent = `找到 ${results.length} 筆`;

  const html = results.map(result => {
    const time = new Date(result.time).toLocaleString();
    let typeLabel = '';
    let typeColor = '';
    let icon = '';

    switch(result.type){
      case 'message':
        typeLabel = result.role === 'user' ? '用戶消息' : 'AI消息';
        typeColor = result.role === 'user' ? '#3B82F6' : '#10B981';
        icon = result.role === 'user' ? '👤' : '🤖';
        break;
      case 'summary':
        typeLabel = '故事摘要';
        typeColor = '#8B7CF7';
        icon = '📚';
        break;
      case 'rolling-summary':
        typeLabel = '滾動摘要';
        typeColor = '#F59E0B';
        icon = '📜';
        break;
      case 'lorebook':
        typeLabel = 'Lorebook';
        typeColor = '#EC4899';
        icon = '📖';
        break;
    }

    // 高亮關鍵詞
    const highlightedContent = highlightKeyword(result.content || result.name || '', keyword);

    return `
      <div style="background:var(--bg-card);border-radius:8px;padding:12px;margin-bottom:8px;border-left:3px solid ${typeColor}">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px">
          <div style="display:flex;align-items:center;gap:6px">
            <span style="font-size:16px">${icon}</span>
            <span style="font-size:12px;font-weight:600;color:${typeColor}">${typeLabel}</span>
            ${result.isImportant ? '<span style="font-size:12px">⭐</span>' : ''}
            ${result.type === 'message' ? `<span style="font-size:11px;color:var(--text-tertiary)">#${result.floor}</span>` : ''}
          </div>
          <span style="font-size:11px;color:var(--text-tertiary)">${time}</span>
        </div>
        ${result.type === 'lorebook' ? `
          <div style="font-size:13px;font-weight:600;margin-bottom:6px">${esc(result.name)}</div>
          ${result.keywords.length > 0 ? `
            <div style="margin-bottom:6px;display:flex;gap:4px;flex-wrap:wrap">
              ${result.keywords.map(k => `<span style="font-size:10px;padding:2px 6px;background:var(--bg-tertiary);border-radius:3px;color:var(--text-secondary)">${esc(k)}</span>`).join('')}
            </div>
          ` : ''}
        ` : ''}
        <div style="font-size:12px;line-height:1.6;color:var(--text-secondary);overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:4;-webkit-box-orient:vertical">
          ${highlightedContent}
        </div>
        ${result.type === 'message' ? `
          <div style="margin-top:8px">
            <button class="action-btn secondary" onclick="jumpToMessage('${escAttr(result.id)}')" style="font-size:11px;padding:4px 8px">📍 跳轉到此消息</button>
          </div>
        ` : ''}
      </div>
    `;
  }).join('');

  list.innerHTML = html;
}

// 高亮關鍵詞
function highlightKeyword(text, keyword){
  if(!text || !keyword) return esc(text);

  // 使用正則表達式進行不區分大小寫的替換
  const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
  const escaped = esc(text);
  return escaped.replace(regex, '<mark style="background:#FFD700;color:#000;padding:2px 4px;border-radius:2px">$1</mark>');
}

// 跳轉到指定消息
function jumpToMessage(msgId){
  // 關閉所有可能打開的 modal（安全檢查）
  if(document.getElementById('memory-manager')) closeModal('memory-manager');
  if(document.getElementById('advanced-search-modal')) closeModal('advanced-search-modal');

  // 檢查當前是否在閱讀頁面
  const readView = document.getElementById('view-reading');
  const isInReadView = readView && readView.classList.contains('active');

  // 如果不在閱讀頁面，先導航到閱讀頁面
  if(!isInReadView){
    goTo('view-reading');
  }

  // 滾動到消息位置（手機上需要更長延遲）
  const delay = isInReadView ? 150 : 600;
  setTimeout(() => {
    let msgEl = document.querySelector(`.msg[data-id="${msgId}"]`);

    // 如果找不到，嘗試用 CSS.escape
    if(!msgEl){
      const safeId = CSS.escape(msgId);
      msgEl = document.querySelector(`.msg[data-id="${safeId}"]`);
    }

    if(msgEl){
      msgEl.scrollIntoView({behavior: 'smooth', block: 'center'});
      // 高亮提示
      msgEl.style.background = 'rgba(139,124,247,0.3)';
      msgEl.style.transition = 'background 0.3s';
      setTimeout(() => {
        msgEl.style.background = '';
      }, 2500);
      toast('已跳轉到目標消息','success');
    } else {
      // 再試一次，可能頁面還沒完全渲染
      setTimeout(() => {
        let retryEl = document.querySelector(`.msg[data-id="${msgId}"]`);
        if(!retryEl){
          const safeId = CSS.escape(msgId);
          retryEl = document.querySelector(`.msg[data-id="${safeId}"]`);
        }
        if(retryEl){
          retryEl.scrollIntoView({behavior: 'smooth', block: 'center'});
          retryEl.style.background = 'rgba(139,124,247,0.3)';
          retryEl.style.transition = 'background 0.3s';
          setTimeout(() => {
            retryEl.style.background = '';
          }, 2500);
          toast('已跳轉到目標消息','success');
        } else {
          toast('找不到該消息，可能已被刪除或壓縮','warning');
        }
      }, 500);
    }
  }, delay);
}

// 支持Enter鍵搜尋
document.addEventListener('DOMContentLoaded', () => {
  const searchInput = document.getElementById('memory-search-input');
  if(searchInput){
    searchInput.addEventListener('keypress', (e) => {
      if(e.key === 'Enter'){
        executeMemorySearch();
      }
    });
  }
});

// ========== 記憶搜尋功能結束 ==========

// 智能分析記憶
async function analyzeMemory(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(msgs.length < 5){toast(T('消息太少，無需分析'),'info');return;}
  
  const resultEl = document.getElementById('memory-analysis-result');
  resultEl.style.display = '';
  resultEl.innerHTML = '🔄 AI 正在分析...';
  
  try{
    const preset = await db.apiPresets.filter(p=>p.isActive).first();
    if(!preset || !preset.apiKey){
      throw new Error('未配置 API');
    }
    
    // 構建分析內容
    const content = msgs.slice(0, 50).map((m, i) => {
      const role = m.role === 'user' ? '【玩家】' : '【AI】';
      return `[${i+1}] ${role} ${m.content.slice(0, 300)}`;
    }).join('\n\n');
    
    const prompt = `請分析以下互動小說對話，從記憶管理角度提供建議。

【對話內容】（共 ${msgs.length} 條消息）
${content.slice(0, 10000)}

【分析要求】
1. 識別哪些消息包含重要信息（關鍵劇情、角色設定、伏筆）
2. 識別哪些消息可以安全壓縮（日常對話、過渡性描寫）
3. 給出具體的壓縮建議

請用以下格式輸出：

🔴 重要消息（建議保留）：
- [消息編號] 原因

🟢 可壓縮消息：
- [消息編號範圍] 原因

💡 建議：
（具體的記憶管理建議）`;

    let response;
    if(preset.type === 'anthropic'){
      response = await callAnthropicDirect(preset, prompt);
    } else if(preset.type === 'openai'){
      response = await callOpenAIDirect(preset, prompt);
    } else {
      response = await callCustomDirect(preset, prompt);
    }
    
    resultEl.innerHTML = `<div style="white-space:pre-wrap;line-height:1.6">${esc(response.content)}</div>`;
  }catch(e){
    resultEl.innerHTML = `<div style="color:var(--error)">分析失敗: ${esc(e.message)}</div>`;
  }
}

// 搜索摘要
function searchSummaries(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  document.getElementById('summary-search-input').value = '';
  document.getElementById('summary-search-results').innerHTML = '<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">輸入關鍵詞搜索</div></div>';
  closeModal('memory-modal');
  showModal('summary-search-modal');
}

function doSummarySearch(){
  const keyword = document.getElementById('summary-search-input').value.trim().toLowerCase();
  const resultsEl = document.getElementById('summary-search-results');
  
  if(!keyword){
    resultsEl.innerHTML = '<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">輸入關鍵詞搜索</div></div>';
    return;
  }
  
  const summaries = story.summaries || [];
  const rollingSummaries = story.rollingSummaries || [];
  const allSummaries = [
    ...summaries.map((s, i) => ({...s, type: '壓縮摘要', idx: i})),
    ...rollingSummaries.map((s, i) => ({...s, type: '滾動摘要', idx: i}))
  ];
  
  const results = allSummaries.filter(s => s.content.toLowerCase().includes(keyword));
  
  if(results.length === 0){
    resultsEl.innerHTML = '<div class="empty"><div class="empty-icon">🔍</div><div class="empty-title">未找到匹配內容</div></div>';
    return;
  }
  
  resultsEl.innerHTML = results.map(s => {
    const content = s.content;
    const lowerContent = content.toLowerCase();
    const idx = lowerContent.indexOf(keyword);
    const start = Math.max(0, idx - 50);
    const end = Math.min(content.length, idx + keyword.length + 50);
    let preview = content.slice(start, end);
    if(start > 0) preview = '...' + preview;
    if(end < content.length) preview = preview + '...';
    
    // 高亮關鍵詞
    const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    preview = esc(preview).replace(regex, '<mark style="background:var(--warning);color:black;padding:0 2px">$1</mark>');
    
    return `
      <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:8px">
        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:4px">${s.type} #${s.idx + 1}</div>
        <div style="font-size:13px;line-height:1.5">${preview}</div>
      </div>
    `;
  }).join('');
}

// 檢查是否需要自動生成滾動摘要
async function checkAutoRollingSummary(){
  // 新版自動摘要系統：後台靜默運行，不阻塞用戶
  if(settings.autoSummary){
    // 不阻塞，後台執行
    autoGenerateRollingSummary().catch(e => {
      console.warn('[AutoSummary] 後台摘要生成失敗:', e);
    });
  }
}

// AI自動提取Lorebook
async function checkAutoLorebookExtract(){
  if(!settings.autoLorebook || !story || !msgs || msgs.length === 0) return;

  try {
    // 計算距離上次提取後的消息數
    const lastExtractMsg = settings.lastLorebookExtractMsg || 0;
    const currentMsgCount = msgs.length;
    const newMsgCount = currentMsgCount - lastExtractMsg;

    // 檢查是否達到自動提取頻率
    if(newMsgCount < settings.autoLorebookFrequency) return;

    console.log(`[AutoLorebook] 檢測到 ${newMsgCount} 條新消息，觸發自動提取...`);

    // 更新最後提取消息計數
    settings.lastLorebookExtractMsg = currentMsgCount;
    await saveSetting('lastLorebookExtractMsg', currentMsgCount);

    // 異步執行提取，不阻塞用戶
    setTimeout(async () => {
      try {
        await autoExtractLorebook();
      } catch(e) {
        console.warn('[AutoLorebook] 自動提取失敗:', e);
      }
    }, 1000); // 延遲1秒執行，避免影響用戶體驗

  } catch(e) {
    console.error('[AutoLorebook] 檢查失敗:', e);
  }
}

// 自動提取Lorebook（後台靜默執行）
async function autoExtractLorebook(){
  if(!story || !msgs || msgs.length === 0) return;

  const rangeValue = settings.autoLorebookFrequency * 2; // 分析範圍為頻率的2倍
  const recentMsgs = msgs.slice(-rangeValue);
  const dialogueContent = recentMsgs.map((m) => {
    const role = m.role === 'user' ? '【玩家】' : '【劇情】';
    return `${role} ${m.content}`;
  }).join('\n\n');

  if(dialogueContent.length < 50) return;

  console.log(`[AutoLorebook] 開始分析最近 ${rangeValue} 條消息...`);

  try {
    // ✨ 優化：獲取現有Lorebook列表
    const existingLorebook = await db.lorebook.where('storyId').equals(story.id).toArray();

    // 構建現有條目列表（用於AI參考）
    let existingEntriesText = '';
    if(existingLorebook.length > 0){
      existingEntriesText = '\n【現有Lorebook條目（請勿重複提取）】\n';
      // 只列出名稱和簡短說明，避免prompt太長
      existingLorebook.forEach(lore => {
        if(lore.name){
          const shortContent = (lore.content || '').slice(0, 50);
          existingEntriesText += `- ${lore.name}${shortContent ? ': ' + shortContent + '...' : ''}\n`;
        }
      });
      existingEntriesText += '\n⚠️ 重要：以上條目已存在，除非有重大更新，否則不要重複提取。\n';
    }

    const response = await callAIForAnalysis(`請從以下對話劇情中提取關鍵信息，生成結構化的 Lorebook 條目。
${existingEntriesText}
【最近對話內容】
${dialogueContent}

【提取要求】
1. **關鍵詞設計**：為每個條目設定 2-5 個觸發關鍵詞，包括：
   - 名稱本身（角色名、地點名、物品名等）
   - 相關的別稱、稱呼
   - 特徵詞（如：銀髮少女、神秘組織、魔法劍等）

2. **提取類型**：
   - 角色：姓名、身份、性格特徵、外貌特徵、能力
   - 地點：名稱、位置、特徵、重要性
   - 物品：名稱、類型、用途、特殊屬性
   - 事件：重要的劇情轉折、衝突、秘密
   - 設定：世界觀、規則、組織、系統

3. **內容要求**：
   - 每個條目簡潔明確，50-200字
   - 聚焦核心信息，去除多餘描述
   - 只提取對話中明確提到的信息，不要腦補
   - 【去重關鍵】只提取新出現的信息，絕對不要重複現有條目
   - 如果某個條目已存在但有重大更新（如角色升級、地點被毀等），可以用新名稱標註（如：艾莉丝（進階）、神秘森林（已探索）)

4. 不需要特別標記角色
5. 不需要提取玩家屬性

請用 JSON 格式返回：
\`\`\`json
{
  "entries": [
    {
      "name": "條目名稱",
      "keywords": ["關鍵詞1", "關鍵詞2"],
      "content": "條目內容...",
      "isCharacter": false
    }
  ]
}
\`\`\`

如果沒有新的重要信息需要記錄，返回空數組。`, '你是一個專業的 Lorebook 提取專家。你的任務是從角色扮演對話中提取關鍵的世界觀設定、角色、地點、物品和事件信息。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。');

    // 嘗試多種方式解析 AI 返回的 JSON
    let match = response.content.match(/```json\s*([\s\S]*?)\s*```/);
    if(!match) {
      // 嘗試匹配不帶 json 標記的代碼塊
      match = response.content.match(/```\s*([\s\S]*?)\s*```/);
    }
    if(!match) {
      // 嘗試直接匹配 JSON 對象
      match = response.content.match(/\{[\s\S]*"entries"[\s\S]*\}/);
    }
    if(!match) {
      // 嘗試匹配任何 JSON 對象
      match = response.content.match(/\{[\s\S]*\}/);
    }

    if(!match) {
      console.log('[AutoLorebook] AI返回格式錯誤，原始內容:', response.content.slice(0, 200));
      return;
    }

    let result;
    try {
      const jsonStr = match[1] || match[0];
      result = JSON.parse(jsonStr);
    } catch(parseErr) {
      console.log('[AutoLorebook] JSON 解析失敗:', parseErr.message);
      // 嘗試修復常見的 JSON 錯誤
      try {
        let fixedJson = (match[1] || match[0])
          .replace(/,\s*}/g, '}')  // 移除尾部逗號
          .replace(/,\s*]/g, ']')  // 移除數組尾部逗號
          .replace(/'/g, '"');     // 單引號改雙引號
        result = JSON.parse(fixedJson);
      } catch(e) {
        console.log('[AutoLorebook] JSON 修復失敗');
        return;
      }
    }

    if(!result.entries || result.entries.length === 0) {
      console.log('[AutoLorebook] 沒有新的信息需要提取');
      return;
    }

    console.log(`[AutoLorebook] AI提取了 ${result.entries.length} 個條目，正在檢查重複...`);

    // 去重檢測（已經在開頭獲取過existingLorebook）
    const existingLorebookNames = new Set(existingLorebook.map(l => (l.name || '').trim().toLowerCase()));

    let addedCount = 0;
    let skippedCount = 0;

    for(const e of result.entries){
      const name = e.name || '未命名';

      // 跳過重複項
      if(existingLorebookNames.has(name.trim().toLowerCase())) {
        console.log(`[AutoLorebook] 跳過重複條目: ${name}`);
        skippedCount++;
        continue;
      }

      // 添加新條目
      await db.lorebook.put({
        id: crypto.randomUUID(),
        storyId: story.id,
        name,
        keywords: e.keywords || [name],
        content: e.content || '',
        depth: 2,
        priority: 100,
        cooldown: 0,
        maxTriggers: 0,
        oneTime: false,
        conditions: [],
        conditionLogic: 'AND',
        isEnabled: true,
        triggerCount: 0,
        lastTriggered: null,
        createdAt: Date.now(),
        updatedAt: Date.now()
      });

      console.log(`[AutoLorebook] 新增條目: ${name}`);
      addedCount++;
      existingLorebookNames.add(name.trim().toLowerCase());
    }

    if(addedCount > 0){
      console.log(`[AutoLorebook] 自動提取完成：新增 ${addedCount} 個Lorebook條目${skippedCount > 0 ? `，跳過 ${skippedCount} 個重複條目` : ''}`);
      // 顯示提示toast
      toast(`🤖 AI自動提取了 ${addedCount} 個新的Lorebook條目${skippedCount > 0 ? `（跳過${skippedCount}個重複）` : ''}`, 'success');
    } else if(skippedCount > 0){
      console.log(`[AutoLorebook] 所有條目都已存在，跳過 ${skippedCount} 個重複條目`);
    }

  } catch(e) {
    console.error('[AutoLorebook] 自動提取執行失敗:', e);
  }
}

// AI自動一致性檢查
async function checkAutoConsistencyCheck(){
  if(!settings.autoConsistencyCheck || !story || !msgs || msgs.length === 0) return;

  try {
    // 計算距離上次檢查後的消息數
    const lastCheckMsg = settings.lastConsistencyCheckMsg || 0;
    const currentMsgCount = msgs.length;
    const newMsgCount = currentMsgCount - lastCheckMsg;

    // 檢查是否達到自動檢查頻率
    if(newMsgCount < settings.consistencyCheckFrequency) return;

    console.log(`[AutoConsistency] 檢測到 ${newMsgCount} 條新消息，觸發自動檢查...`);

    // 更新最後檢查消息計數
    settings.lastConsistencyCheckMsg = currentMsgCount;
    await saveSetting('lastConsistencyCheckMsg', currentMsgCount);

    // 異步執行檢查，不阻塞用戶
    setTimeout(async () => {
      try {
        await autoConsistencyCheck();
      } catch(e) {
        console.warn('[AutoConsistency] 自動檢查失敗:', e);
      }
    }, 2000); // 延遲2秒執行

  } catch(e) {
    console.error('[AutoConsistency] 檢查失敗:', e);
  }
}

// 自動一致性檢查（後台靜默執行）
async function autoConsistencyCheck(){
  if(!story || !msgs || msgs.length < 10) return; // 至少需要10條消息

  const checkRange = Math.min(30, msgs.length);
  const recentMsgs = msgs.slice(-checkRange);

  console.log(`[AutoConsistency] 開始分析最近 ${checkRange} 條消息...`);

  try {
    const prompt = `你是一個故事一致性檢查助手。請分析以下故事內容，檢查是否存在：
1. 設定矛盾（角色性格、能力、背景不一致）
2. 時間線錯誤（事件順序不合理）
3. 角色行為不一致（與之前建立的性格不符）
4. 邏輯漏洞（情節不合理）

請列出發現的問題。如果沒有明顯問題，請簡單回覆「未發現明顯問題」。

故事內容：
${recentMsgs.map(m=>(m.role==='user'?'【玩家】':'【AI】')+m.content).join('\n\n')}`;

    const resp = await callApi(prompt);
    const result = resp.content;

    // 如果發現問題，顯示通知
    if(!result.includes('未發現') && !result.includes('沒有發現') && !result.includes('沒有明顯') && !result.includes('一致性良好')){
      console.log(`[AutoConsistency] 發現問題：`, result.slice(0, 200));

      // 顯示通知toast
      toast('🔍 AI檢測到一致性問題，點擊查看詳情', 'warning');

      // 自動保存到資料庫
      const note={
        id:crypto.randomUUID(),
        storyId:story.id,
        category:'setting',
        name:'自動一致性檢查 - '+new Date().toLocaleDateString(),
        description:'AI 自動檢測到的問題',
        content:result,
        isSelected:false,
        createdAt:Date.now()
      };
      await db.loreEntries.add(note);

      console.log(`[AutoConsistency] 已保存到資料庫`);
    } else {
      console.log(`[AutoConsistency] 未發現明顯問題`);
    }

  } catch(e) {
    console.error('[AutoConsistency] 自動檢查執行失敗:', e);
  }
}

// 查找替換
function showFindReplace(){
  closeAll();
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  document.getElementById('find-text').value='';
  document.getElementById('replace-text').value='';
  document.getElementById('find-result').textContent='';
  showModal('find-replace-modal');
}
function findNext(){
  const find=document.getElementById('find-text').value;
  if(!find){toast(T('請輸入查找內容'),'warning');return;}
  const caseSensitive=document.getElementById('find-case-sensitive').checked;
  let count=0;
  msgs.forEach(m=>{
    const content=caseSensitive?m.content:m.content.toLowerCase();
    const search=caseSensitive?find:find.toLowerCase();
    const matches=(content.match(new RegExp(search.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'g'))||[]).length;
    count+=matches;
  });
  document.getElementById('find-result').textContent=`找到 ${count} 處匹配`;
}
async function replaceAll(){
  const find=document.getElementById('find-text').value;
  const replace=document.getElementById('replace-text').value;
  if(!find){toast(T('請輸入查找內容'),'warning');return;}
  
  const caseSensitive=document.getElementById('find-case-sensitive').checked;
  const regex=new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),caseSensitive?'g':'gi');
  let count=0;
  
  for(const m of msgs){
    const newContent=m.content.replace(regex,(match)=>{count++;return replace;});
    if(newContent!==m.content){
      m.content=newContent;
      await db.messages.update(m.id,{content:newContent});
    }
  }
  
  if(count>0){
    renderMsgs();
    document.getElementById('find-result').textContent=`已替換 ${count} 處`;
    toast(`已替換 ${count} 處`,'success');
  }else{
    document.getElementById('find-result').textContent='未找到匹配內容';
  }
}

// 統計面板
function showStats(){
  closeAll();
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  
  let totalChars=0,userChars=0,aiChars=0,totalTokens=0;
  msgs.forEach(m=>{
    totalChars+=m.content.length;
    if(m.role==='user')userChars+=m.content.length;
    else aiChars+=m.content.length;
    totalTokens+=(m.tokens||0);
  });
  
  document.getElementById('stats-chars').textContent=fmtNum(totalChars);
  document.getElementById('stats-msgs').textContent=msgs.length;
  document.getElementById('stats-tokens').textContent=fmtNum(totalTokens);
  document.getElementById('stats-time').textContent=Math.round((story.statistics?.playTimeMinutes||0)/60)+'h';
  document.getElementById('stats-user-chars').textContent=fmtNum(userChars);
  document.getElementById('stats-ai-chars').textContent=fmtNum(aiChars);
  
  showModal('stats-modal');
}

// 導出故事
function exportStory(){
  closeAll();
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  
  let content='# '+story.title+'\n\n';
  if(story.description)content+='> '+story.description+'\n\n';
  content+='---\n\n';
  
  msgs.forEach(m=>{
    if(m.role==='user')content+='**【玩家】** '+m.content+'\n\n';
    else content+=m.content+'\n\n---\n\n';
  });
  
  const blob=new Blob([content],{type:'text/markdown'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=story.title+'.md';
  a.click();
  URL.revokeObjectURL(url);
  toast(T('故事已導出'),'success');
}

// 導出單個故事的完整 JSON 數據包
async function exportStoryJSON(){
  closeAll();
  if(!story){toast(T('請先選擇故事'),'warning');return;}

  showLoading('正在打包故事數據...');
  try {
    const storyId = story.id;

    // 收集所有相關數據
    const data = {
      version: '6.1',
      exportType: 'single-story',
      exportedAt: Date.now(),

      // 核心故事數據
      story: story,
      messages: await db.messages.where('storyId').equals(storyId).toArray(),
      branches: await db.branches.where('storyId').equals(storyId).toArray(),

      // 指令系統
      storyInstructions: await db.storyInstructions.where('storyId').equals(storyId).toArray(),
      instructions: await (async () => {
        const bindings = await db.storyInstructions.where('storyId').equals(storyId).toArray();
        const instIds = bindings.map(b => b.instructionId);
        return instIds.length > 0 ? await db.instructions.where('id').anyOf(instIds).toArray() : [];
      })(),

      // 角色系統
      characters: await db.characters.where('storyId').equals(storyId).toArray(),
      characterSnapshots: await db.characterSnapshots.where('storyId').equals(storyId).toArray(),
      characterHistory: await db.characterHistory.where('storyId').equals(storyId).toArray(),
      characterStates: await db.characterStates.where('storyId').equals(storyId).toArray(),

      // Lorebook 系統
      lorebook: await db.lorebook.where('storyId').equals(storyId).toArray(),
      lorebookTriggerLog: await db.lorebookTriggerLog.where('storyId').equals(storyId).toArray(),

      // 舊版資料庫（向後兼容）
      loreEntries: await db.loreEntries.where('storyId').equals(storyId).toArray(),

      // 劇情管理
      foreshadowing: await db.foreshadowing.where('storyId').equals(storyId).toArray(),
      events: await db.events.where('storyId').equals(storyId).toArray(),
      timeline: await db.timeline.where('storyId').equals(storyId).toArray(),
      chapters: await db.chapters.where('storyId').equals(storyId).toArray(),
      bookmarks: await db.bookmarks.where('storyId').equals(storyId).toArray(),
      plotTags: await db.plotTags.where('storyId').equals(storyId).toArray(),

      // 場景和面板
      scenes: await db.scenes.where('storyId').equals(storyId).toArray(),
      playerPanels: await db.playerPanels.where('storyId').equals(storyId).toArray(),

      // 存檔
      saves: await db.saves.where('storyId').equals(storyId).toArray()
    };

    // 統計信息
    const stats = {
      messages: data.messages.length,
      characters: data.characters.length,
      lorebook: data.lorebook.length,
      chapters: data.chapters.length,
      bookmarks: data.bookmarks.length
    };

    data.stats = stats;

    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${story.title}_完整數據包_${new Date().toISOString().slice(0, 10)}.json`;
    a.click();
    URL.revokeObjectURL(url);

    hideLoading();
    toast(`✅ 故事已導出！包含 ${stats.messages} 條消息、${stats.characters} 個角色`, 'success');
  } catch(e) {
    hideLoading();
    toast('導出失敗: ' + e.message, 'error');
    console.error('[ExportStory] 錯誤:', e);
  }
}

// 導入單個故事 JSON 數據包
async function importStoryJSON(){
  closeAll();

  const input = document.getElementById('import-story-input');
  if(!input) {
    // 創建隱藏的文件輸入元素
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = 'import-story-input';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);
  }

  const fileInput = document.getElementById('import-story-input');
  fileInput.onchange = async (e) => {
    const file = e.target.files[0];
    if(!file) return;

    showLoading('正在導入故事...');
    try {
      const text = await file.text();
      const data = safeJSONParse(text);

      if(!data || !data.version || !data.story) {
        throw new Error('無效的故事數據包');
      }

      if(data.exportType !== 'single-story') {
        throw new Error('這不是單個故事數據包。請使用「導入數據」功能導入完整備份。');
      }

      // 生成新的 ID 以避免衝突
      const oldStoryId = data.story.id;
      const newStoryId = crypto.randomUUID();
      const idMap = new Map(); // 用於映射舊 ID 到新 ID

      console.log('[ImportStory] 開始導入故事');
      console.log('[ImportStory] 原始故事 ID:', oldStoryId);
      console.log('[ImportStory] 新故事 ID:', newStoryId);
      console.log('[ImportStory] 原始標題:', data.story.title);

      // 更新故事 ID 和标题（添加时间戳确保唯一）
      data.story.id = newStoryId;
      const timestamp = new Date().toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }).replace(/\//g, '-');
      data.story.title = data.story.title.replace(/ \(導入.*?\)$/, '') + ` (導入 ${timestamp})`;
      data.story.createdAt = Date.now();
      data.story.updatedAt = Date.now();

      console.log('[ImportStory] 新標題:', data.story.title);

      // 導入故事
      await db.stories.add(data.story);
      console.log('[ImportStory] 故事已添加到數據庫');

      // 導入消息（更新 storyId 和 ID）
      if(data.messages && data.messages.length > 0) {
        console.log('[ImportStory] 導入消息數量:', data.messages.length);
        const messages = data.messages.map(m => {
          const oldId = m.id;
          const newId = crypto.randomUUID();
          idMap.set(oldId, newId);
          return {...m, id: newId, storyId: newStoryId};
        });
        await db.messages.bulkAdd(messages);
        console.log('[ImportStory] 消息已導入');
      }

      // 導入分支
      if(data.branches && data.branches.length > 0) {
        console.log('[ImportStory] 導入分支數量:', data.branches.length);
        const branches = data.branches.map(b => ({...b, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.branches.bulkAdd(branches);
      }

      // 導入指令並建立 ID 映射
      const instructionIdMap = new Map(); // 用於映射舊指令 ID 到新指令 ID
      if(data.instructions && data.instructions.length > 0) {
        console.log('[ImportStory] 導入指令數量:', data.instructions.length);
        const instructions = data.instructions.map(inst => {
          const oldId = inst.id;
          const newId = crypto.randomUUID();
          instructionIdMap.set(oldId, newId);
          return {...inst, id: newId};
        });
        await db.instructions.bulkAdd(instructions);
      }

      // 導入故事指令綁定（使用新的指令 ID）
      if(data.storyInstructions && data.storyInstructions.length > 0) {
        console.log('[ImportStory] 導入故事指令綁定數量:', data.storyInstructions.length);
        const storyInsts = data.storyInstructions.map(si => ({
          ...si,
          storyId: newStoryId,
          instructionId: instructionIdMap.get(si.instructionId) || si.instructionId
        }));
        await db.storyInstructions.bulkAdd(storyInsts);
      }

      // 導入角色（兼容舊數據：如果沒有initialStats，自動設置）
      if(data.characters && data.characters.length > 0) {
        console.log('[ImportStory] 導入角色數量:', data.characters.length);
        const characters = data.characters.map(c => {
          const newChar = {...c, id: crypto.randomUUID(), storyId: newStoryId};
          // 如果沒有 initialStats 但有 stats，自動設置 initialStats
          if(!newChar.initialStats && newChar.stats && Object.keys(newChar.stats).length > 0) {
            newChar.initialStats = { ...newChar.stats };
          }
          return newChar;
        });
        await db.characters.bulkAdd(characters);
        console.log('[ImportStory] 角色已導入');
      }

      // 導入角色快照
      if(data.characterSnapshots && data.characterSnapshots.length > 0) {
        const snapshots = data.characterSnapshots.map(s => ({...s, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.characterSnapshots.bulkAdd(snapshots);
      }

      // 導入角色歷史
      if(data.characterHistory && data.characterHistory.length > 0) {
        const history = data.characterHistory.map(h => ({...h, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.characterHistory.bulkAdd(history);
      }

      // 導入角色狀態
      if(data.characterStates && data.characterStates.length > 0) {
        const states = data.characterStates.map(s => ({...s, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.characterStates.bulkAdd(states);
      }

      // 導入 Lorebook
      if(data.lorebook && data.lorebook.length > 0) {
        console.log('[ImportStory] 導入 Lorebook 數量:', data.lorebook.length);
        const lorebook = data.lorebook.map(l => ({...l, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.lorebook.bulkAdd(lorebook);
        console.log('[ImportStory] Lorebook 已導入');
      }

      // 導入 Lorebook 觸發日誌
      if(data.lorebookTriggerLog && data.lorebookTriggerLog.length > 0) {
        const logs = data.lorebookTriggerLog.map(l => ({...l, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.lorebookTriggerLog.bulkAdd(logs);
      }

      // 導入舊版資料庫
      if(data.loreEntries && data.loreEntries.length > 0) {
        console.log('[ImportStory] 導入世界觀設定數量:', data.loreEntries.length);
        const entries = data.loreEntries.map(e => ({...e, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.loreEntries.bulkAdd(entries);
        console.log('[ImportStory] 世界觀設定已導入');
      }

      // 導入伏筆
      if(data.foreshadowing && data.foreshadowing.length > 0) {
        console.log('[ImportStory] 導入伏筆數量:', data.foreshadowing.length);
        const foreshadowing = data.foreshadowing.map(f => {
          const newMsgId = idMap.get(f.messageId) || f.messageId;
          return {...f, id: crypto.randomUUID(), storyId: newStoryId, messageId: newMsgId};
        });
        await db.foreshadowing.bulkAdd(foreshadowing);
        console.log('[ImportStory] 伏筆已導入');
      }

      // 導入事件
      if(data.events && data.events.length > 0) {
        const events = data.events.map(e => {
          const newMsgId = idMap.get(e.messageId) || e.messageId;
          return {...e, id: crypto.randomUUID(), storyId: newStoryId, messageId: newMsgId};
        });
        await db.events.bulkAdd(events);
      }

      // 導入時間軸
      if(data.timeline && data.timeline.length > 0) {
        const timeline = data.timeline.map(t => {
          const newMsgId = idMap.get(t.messageId) || t.messageId;
          return {...t, id: crypto.randomUUID(), storyId: newStoryId, messageId: newMsgId};
        });
        await db.timeline.bulkAdd(timeline);
      }

      // 導入章節
      if(data.chapters && data.chapters.length > 0) {
        const chapters = data.chapters.map(c => {
          const newMsgId = idMap.get(c.messageId) || c.messageId;
          return {...c, id: crypto.randomUUID(), storyId: newStoryId, messageId: newMsgId};
        });
        await db.chapters.bulkAdd(chapters);
      }

      // 導入書籤
      if(data.bookmarks && data.bookmarks.length > 0) {
        const bookmarks = data.bookmarks.map(b => {
          const newMsgId = idMap.get(b.messageId) || b.messageId;
          return {...b, id: crypto.randomUUID(), storyId: newStoryId, messageId: newMsgId};
        });
        await db.bookmarks.bulkAdd(bookmarks);
      }

      // 導入劇情標籤
      if(data.plotTags && data.plotTags.length > 0) {
        const tags = data.plotTags.map(t => {
          const newMsgId = idMap.get(t.messageId) || t.messageId;
          return {...t, id: crypto.randomUUID(), storyId: newStoryId, messageId: newMsgId};
        });
        await db.plotTags.bulkAdd(tags);
      }

      // 導入場景
      if(data.scenes && data.scenes.length > 0) {
        const scenes = data.scenes.map(s => ({...s, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.scenes.bulkAdd(scenes);
      }

      // 導入玩家面板
      if(data.playerPanels && data.playerPanels.length > 0) {
        const panels = data.playerPanels.map(p => ({...p, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.playerPanels.bulkAdd(panels);
      }

      // 導入存檔
      if(data.saves && data.saves.length > 0) {
        const saves = data.saves.map(s => ({...s, id: crypto.randomUUID(), storyId: newStoryId}));
        await db.saves.bulkAdd(saves);
      }

      // 刷新故事列表和指令列表
      await renderStories();
      await renderInst();

      hideLoading();
      toast(`✅ 故事「${data.story.title}」導入成功！`, 'success');

      // 顯示統計信息
      if(data.stats) {
        setTimeout(() => {
          toast(`包含 ${data.stats.messages} 條消息、${data.stats.characters} 個角色`, 'info');
        }, 1500);
      }

    } catch(e) {
      hideLoading();
      toast('導入失敗: ' + e.message, 'error');
      console.error('[ImportStory] 錯誤:', e);
    }

    fileInput.value = ''; // 清空以允許重複導入
  };

  fileInput.click();
}

// ============ 章節管理 ============
async function renderChapters(){
  if(!story)return;
  const c=document.getElementById('chapter-list');
  const chapters=await db.chapters.where('storyId').equals(story.id).sortBy('order');
  if(!chapters.length){
    c.innerHTML='<div class="empty"><div class="empty-icon">📑</div><div class="empty-title">暫無章節</div><div class="empty-desc">點擊右上角添加章節標記</div></div>';
    return;
  }
  c.innerHTML=chapters.map((ch,i)=>{
    const msg=msgs.find(m=>m.id===ch.messageId);
    const preview=msg?.content?.slice(0,50)||'';
    return `<div class="card" onclick="jumpToChapter('${ch.id}')">
      <div class="card-cover" style="background:linear-gradient(135deg,var(--primary),var(--info))">📑</div>
      <div class="card-info">
        <div class="card-header"><div class="card-title">${esc(ch.title)}</div><div class="card-time">${fmtDate(ch.createdAt)}</div></div>
        <div class="card-preview">${esc(preview)}...</div>
        <div class="card-meta"><span class="card-stats">第 ${i+1} 章</span></div>
      </div>
    </div>`;
  }).join('')+'<button class="action-btn secondary" style="width:100%;margin-top:12px" onclick="addChapter()">➕ 添加章節</button>';
}
function addChapter(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(!selMsgId&&msgs.length>0)selMsgId=msgs[msgs.length-1].id;
  document.getElementById('chapter-title').value='';
  showModal('chapter-modal');
}
async function saveChapter(){
  const title=document.getElementById('chapter-title').value.trim();
  if(!title){toast(T('請輸入章節標題'),'warning');return;}
  const chapters=await db.chapters.where('storyId').equals(story.id).toArray();
  const ch={id:crypto.randomUUID(),storyId:story.id,messageId:selMsgId||msgs[msgs.length-1]?.id,title,order:chapters.length,createdAt:Date.now()};
  await db.chapters.add(ch);
  closeModal('chapter-modal');
  toast(T('章節已添加'),'success');
  renderChapters();
}
async function jumpToChapter(chId){
  const ch=await db.chapters.get(chId);
  if(!ch)return;
  goBack();
  setTimeout(()=>{
    const el=document.querySelector(`.msg[data-id="${ch.messageId}"]`);
    if(el)el.scrollIntoView({behavior:'smooth',block:'center'});
  },300);
}

// ============ 書籤管理 ============
async function renderBookmarks(){
  if(!story)return;
  const c=document.getElementById('bookmark-list');
  const bookmarks=await db.bookmarks.where('storyId').equals(story.id).reverse().sortBy('createdAt');
  if(!bookmarks.length){
    c.innerHTML='<div class="empty"><div class="empty-icon">🔖</div><div class="empty-title">暫無書籤</div><div class="empty-desc">長按消息可添加書籤</div></div>';
    return;
  }
  c.innerHTML=bookmarks.map(bm=>{
    const msg=msgs.find(m=>m.id===bm.messageId);
    const preview=msg?.content?.slice(0,80)||'';
    return `<div class="card" onclick="jumpToBookmark('${bm.id}')">
      <div class="card-cover" style="background:linear-gradient(135deg,var(--warning),var(--primary))">🔖</div>
      <div class="card-info">
        <div class="card-header"><div class="card-title">${esc(bm.name)}</div><div class="card-time">${fmtDate(bm.createdAt)}</div></div>
        <div class="card-preview">${esc(preview)}...</div>
      </div>
      <div style="position:absolute;right:12px;top:50%;transform:translateY(-50%)" onclick="event.stopPropagation();deleteBookmark('${bm.id}')">🗑️</div>
    </div>`;
  }).join('');
}
function addBookmark(){
  hideMenu();
  if(!selMsgId){toast(T('請先選擇消息'),'warning');return;}
  document.getElementById('bookmark-name').value='';
  showModal('bookmark-modal');
}
async function saveBookmark(){
  const name=document.getElementById('bookmark-name').value.trim()||'書籤 '+(await db.bookmarks.where('storyId').equals(story.id).count()+1);
  const bm={id:crypto.randomUUID(),storyId:story.id,messageId:selMsgId,name,createdAt:Date.now()};
  await db.bookmarks.add(bm);
  closeModal('bookmark-modal');
  toast(T('書籤已添加'),'success');
}
async function jumpToBookmark(bmId){
  const bm=await db.bookmarks.get(bmId);
  if(!bm)return;
  goBack();
  setTimeout(()=>{
    const el=document.querySelector(`.msg[data-id="${bm.messageId}"]`);
    if(el){el.scrollIntoView({behavior:'smooth',block:'center'});el.style.animation='highlight 1s';}
  },300);
}
async function deleteBookmark(id){await db.bookmarks.delete(id);toast(T('書籤已刪除'),'success');renderBookmarks();}

// ============ 劇情標籤 ============
function addPlotTag(){
  hideMenu();
  if(!selMsgId){toast(T('請先選擇消息'),'warning');return;}
  document.getElementById('tag-note').value='';
  showModal('tag-modal');
}
async function savePlotTag(){
  const type=document.getElementById('tag-type').value;
  const note=document.getElementById('tag-note').value.trim();
  const tag={id:crypto.randomUUID(),storyId:story.id,messageId:selMsgId,type,note,createdAt:Date.now()};
  await db.plotTags.add(tag);
  closeModal('tag-modal');
  toast(T('標籤已添加'),'success');
  // 在消息上顯示標籤
  const el=document.querySelector(`.msg[data-id="${selMsgId}"]`);
  if(el){
    const labels={key:'🔑關鍵',scene:'🎬名場面',clue:'🔍線索',turning:'🔄轉折',emotion:'💕情感'};
    let tagEl=el.querySelector('.plot-tags');
    if(!tagEl){tagEl=document.createElement('div');tagEl.className='plot-tags';tagEl.style.cssText='margin-top:8px;display:flex;gap:4px;flex-wrap:wrap';el.appendChild(tagEl);}
    tagEl.innerHTML+=`<span style="font-size:10px;padding:2px 6px;background:var(--bg-tertiary);border-radius:4px;color:var(--primary)">${labels[type]||type}</span>`;
  }
}

// ============ 分支管理 ============
async function renderBranches(){
  if(!story)return;
  const c=document.getElementById('branch-list');
  const branches=await db.branches.where('storyId').equals(story.id).toArray();
  if(!branches.length){
    // 創建默認主分支
    const main={id:'branch_main',storyId:story.id,name:'主線',description:'',parentBranchId:null,createdAt:Date.now()};
    await db.branches.add(main);
    branches.push(main);
  }
  c.innerHTML=branches.map(br=>{
    const isActive=br.id===story.currentBranchId;
    return `<div class="card ${isActive?'selected':''}" onclick="switchBranch('${br.id}')">
      <div class="card-cover" style="background:linear-gradient(135deg,${isActive?'var(--success)':'var(--bg-tertiary)'},var(--primary))">🔀</div>
      <div class="card-info">
        <div class="card-header"><div class="card-title">${esc(T(br.name))}</div>${isActive?`<span class="api-badge">${T('當前')}</span>`:''}</div>
        <div class="card-preview">${esc(br.description||T('無描述'))}</div>
        <div class="card-meta"><span class="card-stats">${fmtDate(br.createdAt)}</span></div>
      </div>
    </div>`;
  }).join('')+`<button class="action-btn primary" style="width:100%;margin-top:12px" onclick="createBranch()">➕ ${T('創建新分支')}</button>`;
}
function createBranch(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  document.getElementById('branch-name').value='';
  document.getElementById('branch-desc').value='';
  showModal('branch-modal');
}
async function saveBranch(){
  const name=document.getElementById('branch-name').value.trim();
  if(!name){toast(T('請輸入分支名稱'),'warning');return;}
  const desc=document.getElementById('branch-desc').value.trim();
  const br={id:crypto.randomUUID(),storyId:story.id,name,description:desc,parentBranchId:story.currentBranchId,forkMessageId:msgs[msgs.length-1]?.id,createdAt:Date.now()};
  await db.branches.add(br);
  // 複製當前分支的消息到新分支
  const currentMsgs=await db.messages.where('[storyId+branchId]').equals([story.id,story.currentBranchId]).toArray();
  const newMsgs=currentMsgs.map(m=>({...m,id:crypto.randomUUID(),branchId:br.id}));
  await db.messages.bulkAdd(newMsgs);
  closeModal('branch-modal');
  toast(T('分支已創建'),'success');
  renderBranches();
}
async function switchBranch(brId){
  if(brId===story.currentBranchId)return;
  story.currentBranchId=brId;
  await db.stories.update(story.id,{currentBranchId:brId});
  msgs=await db.messages.where('[storyId+branchId]').equals([story.id,brId]).sortBy('createdAt');
  renderMsgs();
  toast(T('已切換分支'),'success');
  renderBranches();
}

// ============ AI 功能 ============
let lastAiCheckResult = null; // 保存最後一次 AI 檢查結果
let _aiCheckRange = 30;

function aiConsistencyCheck(){
  if(!story||!msgs.length){toast(T('請先選擇有內容的故事'),'warning');return;}
  showAiRangeSelector('🤖 AI 一致性檢查', (range) => {
    _aiCheckRange = range;
    document.getElementById('ai-check-result').textContent='點擊「開始檢查」進行分析...';
    document.getElementById('ai-fix-btn').style.display='none';
    showModal('ai-check-modal');
  }, 30);
}
async function doAiConsistencyCheck(){
  const resultEl=document.getElementById('ai-check-result');
  resultEl.textContent='分析中，請稍候...';
  const range = _aiCheckRange || 30;

  const prompt=`你是一個故事一致性檢查助手。請分析以下故事內容，檢查是否存在：
1. 設定矛盾（角色性格、能力、背景不一致）
2. 時間線錯誤（事件順序不合理）
3. 角色行為不一致（與之前建立的性格不符）
4. 邏輯漏洞（情節不合理）

請列出發現的問題，並給出具體位置和修改建議。如果沒有問題，請說明故事整體一致性良好。

故事內容：
${msgs.slice(-range).map(m=>(m.role==='user'?'【玩家】':'【AI】')+m.content).join('\n\n')}`;

  try{
    const resp=await callApi(prompt);
    resultEl.textContent=resp.content;
    lastAiCheckResult=resp.content;
    // 如果發現問題，顯示修復按鈕
    if(!resp.content.includes('一致性良好') && !resp.content.includes('沒有發現問題') && !resp.content.includes('沒有明顯')){
      document.getElementById('ai-fix-btn').style.display='block';
    }
  }catch(e){
    resultEl.textContent='檢查失敗: '+e.message;
  }
}

function showAiFix(){
  closeModal('ai-check-modal');
  showModal('ai-fix-modal');
}

async function applyAiFix(method){
  closeModal('ai-fix-modal');

  if(method==='auto'){
    // 將一致性問題添加到下次 AI 回覆的提示中
    story.consistencyNote=`請注意以下一致性問題並在回覆中自然地糾正：\n${lastAiCheckResult.slice(0,500)}`;
    story.consistencyFixCount = 0; // 初始化修復計數器
    story.consistencyFixMax = 3; // 保持3次對話
    await db.stories.update(story.id,{
      consistencyNote:story.consistencyNote,
      consistencyFixCount: 0,
      consistencyFixMax: 3
    });
    toast(T('已設置自動修復，AI 將在接下來3次回覆中持續糾正'),'success');
    // 顯示提示條
    updateConsistencyFixBanner();
  }else if(method==='note'){
    // 添加到世界觀設定
    const note={
      id:crypto.randomUUID(),
      storyId:story.id,
      category:'setting',
      name:'一致性筆記 - '+new Date().toLocaleDateString(),
      description:'AI 檢測到的問題',
      content:lastAiCheckResult,
      isSelected:false,
      createdAt:Date.now()
    };
    await db.loreEntries.add(note);
    toast(T('已添加到世界觀設定'),'success');
  }else{
    toast(T('已忽略'),'info');
  }
}

// 更新一致性修復提示條
function updateConsistencyFixBanner(){
  if(!story) return;

  const banner = document.getElementById('consistency-fix-banner');
  const info = document.getElementById('consistency-fix-info');

  if(story.consistencyNote && story.consistencyFixMax){
    const remaining = story.consistencyFixMax - (story.consistencyFixCount || 0);
    if(remaining > 0){
      banner.style.display = 'flex';
      info.textContent = `剩餘 ${remaining} 次對話`;
    } else {
      banner.style.display = 'none';
    }
  } else {
    banner.style.display = 'none';
  }
}

// 取消一致性修復
async function cancelConsistencyFix(){
  if(!story) return;

  await db.stories.update(story.id,{
    consistencyNote:null,
    consistencyFixCount:0,
    consistencyFixMax:null
  });
  story.consistencyNote=null;
  story.consistencyFixCount=0;
  story.consistencyFixMax=null;

  updateConsistencyFixBanner();
  toast('已取消一致性修復','info');
}

let _aiSummaryRange = 50;

function aiChapterSummary(){
  if(!story||!msgs.length){toast(T('請先選擇有內容的故事'),'warning');return;}
  showAiRangeSelector('🤖 AI 章節總結', (range) => {
    _aiSummaryRange = range;
    document.getElementById('ai-summary-result').textContent='點擊「生成總結」開始...';
    showModal('ai-summary-modal');
  }, 50);
}
async function doAiChapterSummary(){
  const resultEl=document.getElementById('ai-summary-result');
  resultEl.textContent='生成中，請稍候...';
  const range = _aiSummaryRange || 50;

  const prompt=`請為以下故事內容生成一個簡潔的章節總結，包括：
1. 主要事件概述（3-5句話）
2. 重要角色狀態變化
3. 關鍵決策點
4. 未解決的伏筆/懸念

故事內容：
${msgs.slice(-range).map(m=>(m.role==='user'?'【玩家】':'【AI】')+m.content).join('\n\n')}`;

  try{
    const resp=await callApi(prompt);
    resultEl.textContent=resp.content;
  }catch(e){
    resultEl.textContent='生成失敗: '+e.message;
  }
}
function copySummary(){
  const text=document.getElementById('ai-summary-result').textContent;
  navigator.clipboard.writeText(text);
  toast(T('已複製到剪貼板'),'success');
}

// ============ v7: 角色卡片系統 ============
let currentCharacterId = null; // 當前選中的角色ID
let charBatchMode = false; // 批量操作模式
let selectedCharIds = new Set(); // 已選中的角色ID

// v25: 渲染角色列表（支持分組、搜索、篩選）
async function renderCharacters(){
  if(!story){
    document.getElementById('character-list').innerHTML='<div class="char-empty"><div class="char-empty-icon">📚</div><div class="char-empty-text">請先選擇故事</div></div>';
    return;
  }
  
  let chars = await db.characters.where('storyId').equals(story.id).toArray();
  const c = document.getElementById('character-list');
  
  // 應用搜索篩選
  const searchText = document.getElementById('char-search-input')?.value?.toLowerCase() || '';
  const categoryFilter = document.getElementById('char-filter-category')?.value || 'all';
  
  if(searchText){
    chars = chars.filter(char => 
      char.name?.toLowerCase().includes(searchText) ||
      char.title?.toLowerCase().includes(searchText) ||
      char.description?.toLowerCase().includes(searchText) ||
      (char.tags || []).some(t => t.toLowerCase().includes(searchText))
    );
  }
  
  if(categoryFilter !== 'all'){
    chars = chars.filter(char => char.category === categoryFilter);
  }
  
  // 更新計數
  const totalCount = await db.characters.where('storyId').equals(story.id).count();
  document.getElementById('char-count').textContent = chars.length === totalCount 
    ? `${totalCount} 位角色` 
    : `${chars.length} / ${totalCount} 位角色`;
  
  if(!chars.length){
    c.innerHTML = searchText || categoryFilter !== 'all'
      ? `<div class="char-empty"><div class="char-empty-icon">🔍</div><div class="char-empty-text">沒有找到匹配的角色</div></div>`
      : `<div class="char-empty"><div class="char-empty-icon">👥</div><div class="char-empty-text">尚未識別角色</div><div style="font-size:12px;color:var(--text-tertiary);margin-top:8px">點擊「AI 更新狀態」自動識別<br>或手動添加角色</div></div>`;
    return;
  }
  
  // 按分類分組
  const groups = {
    protagonist: { label: '⭐ 主角', chars: [] },
    supporting: { label: '👤 配角', chars: [] },
    npc: { label: '👥 NPC', chars: [] }
  };
  
  chars.forEach(char => {
    const cat = char.category || 'supporting';
    if(groups[cat]){
      groups[cat].chars.push(char);
    } else {
      groups.supporting.chars.push(char);
    }
  });
  
  // 渲染分組
  let html = '';
  const batchClass = charBatchMode ? 'batch-mode' : '';
  
  for(const [catKey, group] of Object.entries(groups)){
    if(group.chars.length === 0) continue;
    
    html += `
      <div class="char-group" data-category="${catKey}">
        <div class="char-group-header" onclick="toggleCharGroup('${catKey}')">
          <span class="char-group-arrow">▼</span>
          <span>${group.label}</span>
          <span class="char-group-count">(${group.chars.length})</span>
        </div>
        <div class="char-group-list ${batchClass}">
          ${group.chars.map(char => renderCharCardSimple(char)).join('')}
        </div>
      </div>
    `;
  }
  
  c.innerHTML = html;
  
  // 更新批量選擇狀態
  updateBatchCount();
}

// v25: 簡化的角色卡片（用於列表）
function renderCharCardSimple(char){
  const isSelected = selectedCharIds.has(char.id);
  const categoryLabels = {
    protagonist: { label: '主角', cls: 'protagonist' },
    supporting: { label: '配角', cls: 'supporting' },
    npc: { label: 'NPC', cls: 'npc' }
  };
  const catInfo = categoryLabels[char.category] || categoryLabels.supporting;
  
  // 主要屬性摘要
  const stats = char.stats || {};
  const statKeys = Object.keys(stats).slice(0, 2);
  const statHtml = statKeys.map(k => `<span>${k}: ${stats[k]}</span>`).join(' · ');
  
  // V2特性徽章
  const badges = [];
  if(char.first_mes) badges.push('💬');
  if(char.expressions?.length) badges.push('🎨');
  if(char.relationships?.length) badges.push('👥');
  if(char.character_book?.entries?.length) badges.push('📚');
  
  return `
    <div class="char-card ${isSelected ? 'selected' : ''}" 
         data-char-id="${char.id}"
         onclick="handleCharCardClick('${char.id}', event)">
      <div class="char-card-checkbox ${isSelected ? 'checked' : ''}" onclick="event.stopPropagation();toggleCharSelect('${char.id}')">
        ${isSelected ? '✓' : ''}
      </div>
      <div class="char-card-avatar">
        ${char.avatarImage ? `<img src="${char.avatarImage}" alt="">` : (char.avatar || '👤')}
      </div>
      <div class="char-card-info">
        <div class="char-card-name">
          ${esc(char.name)}
          ${badges.length ? `<span style="font-size:12px">${badges.join('')}</span>` : ''}
        </div>
        ${char.title ? `<div class="char-card-title">${esc(char.title)}</div>` : ''}
        ${char.tags?.length ? `<div class="char-card-tags">${char.tags.slice(0,3).map(t => `<span class="char-card-tag">${esc(t)}</span>`).join('')}</div>` : ''}
      </div>
      <div class="char-card-stats">
        <span class="char-card-category ${catInfo.cls}">${catInfo.label}</span>
        ${statHtml ? `<div class="char-card-stat">${statHtml}</div>` : ''}
      </div>
    </div>
  `;
}

// v25: 處理卡片點擊
function handleCharCardClick(charId, event){
  if(charBatchMode){
    toggleCharSelect(charId);
  } else {
    showCharDetail(charId);
  }
}

// v25: 切換分組展開/收起
function toggleCharGroup(category){
  const group = document.querySelector(`.char-group[data-category="${category}"]`);
  if(group) group.classList.toggle('collapsed');
}

// v25: 篩選角色
function filterCharacters(){
  renderCharacters();
}

// v25: 批量操作模式
function toggleCharBatchMode(){
  charBatchMode = !charBatchMode;
  const btn = document.getElementById('char-batch-btn');
  const bar = document.getElementById('char-batch-bar');
  
  if(charBatchMode){
    btn.style.color = 'var(--primary)';
    bar.style.display = 'flex';
    document.querySelectorAll('.char-group-list').forEach(el => el.classList.add('batch-mode'));
  } else {
    btn.style.color = '';
    bar.style.display = 'none';
    selectedCharIds.clear();
    document.querySelectorAll('.char-group-list').forEach(el => el.classList.remove('batch-mode'));
    document.querySelectorAll('.char-card').forEach(el => el.classList.remove('selected'));
    document.querySelectorAll('.char-card-checkbox').forEach(el => {
      el.classList.remove('checked');
      el.textContent = '';
    });
  }
  
  updateBatchCount();
}

// v25: 切換角色選擇
function toggleCharSelect(charId){
  if(selectedCharIds.has(charId)){
    selectedCharIds.delete(charId);
  } else {
    selectedCharIds.add(charId);
  }
  
  const card = document.querySelector(`.char-card[data-char-id="${charId}"]`);
  if(card){
    const isSelected = selectedCharIds.has(charId);
    card.classList.toggle('selected', isSelected);
    const checkbox = card.querySelector('.char-card-checkbox');
    if(checkbox){
      checkbox.classList.toggle('checked', isSelected);
      checkbox.textContent = isSelected ? '✓' : '';
    }
  }
  
  updateBatchCount();
}

// v25: 全選/取消全選
async function toggleSelectAllChars(){
  const selectAll = document.getElementById('char-select-all');
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  
  if(selectAll.checked){
    chars.forEach(c => selectedCharIds.add(c.id));
  } else {
    selectedCharIds.clear();
  }
  
  document.querySelectorAll('.char-card').forEach(card => {
    const charId = card.dataset.charId;
    const isSelected = selectedCharIds.has(charId);
    card.classList.toggle('selected', isSelected);
    const checkbox = card.querySelector('.char-card-checkbox');
    if(checkbox){
      checkbox.classList.toggle('checked', isSelected);
      checkbox.textContent = isSelected ? '✓' : '';
    }
  });
  
  updateBatchCount();
}

// v25: 更新選中計數
function updateBatchCount(){
  const countEl = document.getElementById('char-batch-count');
  if(countEl){
    countEl.textContent = `已選 ${selectedCharIds.size} 個`;
  }
  
  // 更新全選狀態
  const selectAll = document.getElementById('char-select-all');
  if(selectAll){
    db.characters.where('storyId').equals(story?.id || 0).count().then(total => {
      selectAll.checked = selectedCharIds.size === total && total > 0;
      selectAll.indeterminate = selectedCharIds.size > 0 && selectedCharIds.size < total;
    }).catch(err => {
      console.error('[Characters] 獲取角色總數失敗:', err);
    });
  }
}

// v25: 批量刪除
async function batchDeleteChars(){
  if(selectedCharIds.size === 0){
    toast(T('請先選擇角色'), 'warning');
    return;
  }
  
  if(!confirm(`確定要刪除 ${selectedCharIds.size} 個角色嗎？此操作不可撤銷。`)) return;
  
  showLoading(T('正在刪除...'));
  
  try {
    for(const charId of selectedCharIds){
      await db.characters.delete(charId);
    }
    
    selectedCharIds.clear();
    updateBatchCount();
    renderCharacters();
    
    hideLoading();
    toast(T('角色已刪除'), 'success');
  } catch(err){
    hideLoading();
    console.error('Batch delete error:', err);
    toast(T('刪除失敗: ') + err.message, 'error');
  }
}

// v25: 批量導出
async function batchExportChars(){
  if(selectedCharIds.size === 0){
    toast(T('請先選擇角色'), 'warning');
    return;
  }
  
  showLoading(T('正在導出...'));
  
  try {
    const chars = [];
    for(const charId of selectedCharIds){
      const char = await db.characters.get(charId);
      if(char) chars.push(char);
    }
    
    const exportData = {
      format: 'zhimeng_characters_v2',
      exportedAt: new Date().toISOString(),
      storyTitle: story.title,
      characters: chars.map(c => ({
        // 基本信息
        name: c.name,
        title: c.title || '',
        avatar: c.avatar || '👤',
        avatarImage: c.avatarImage || '',
        category: c.category || 'supporting',
        description: c.description || '',
        personality: c.personality || '',
        tags: c.tags || [],
        
        // 對話設置
        first_mes: c.first_mes || '',
        alternate_greetings: c.alternate_greetings || [],
        scenario: c.scenario || '',
        mes_example: c.mes_example || '',
        
        // 高級設置
        system_prompt: c.system_prompt || '',
        post_history_instructions: c.post_history_instructions || '',
        creator_notes: c.creator_notes || '',
        creator: c.creator || '',
        character_version: c.character_version || '1.0',
        
        // 角色專屬 Lorebook
        character_book: c.character_book || null,
        
        // 屬性和狀態
        stats: c.stats || {},
        initialStats: c.initialStats || null,
        initialState: c.initialState || null,
        
        // 關係和表情
        relationships: c.relationships || [],
        expressions: c.expressions || [],
        expressionMode: c.expressionMode || 'manual',
        
        // 其他
        mood: c.mood || '',
        note: c.note || '',
        location: c.location || ''
      }))
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `角色導出_${selectedCharIds.size}個_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    hideLoading();
    toast(T(`已導出 ${selectedCharIds.size} 個角色`), 'success');
  } catch(err){
    hideLoading();
    console.error('Batch export error:', err);
    toast(T('導出失敗: ') + err.message, 'error');
  }
}

// 舊版渲染函數（保留兼容）
function renderCharacterCard(char){
  const stats = char.stats || {};
  const tags = char.tags || [];
  const relations = char.relations || [];
  
  // 獲取快速預覽的關鍵數值
  const quickStats = [];
  if(stats['好感'] !== undefined || stats['表面好感'] !== undefined){
    const favor = stats['表面好感'] || stats['好感'] || 0;
    quickStats.push(`<div class="char-quick-item"><span>💜</span><span class="char-quick-val">${favor}</span></div>`);
  }
  if(stats['真實好感'] !== undefined){
    const realFavor = stats['真實好感'];
    const color = realFavor > 50 ? 'var(--success)' : realFavor > 20 ? 'var(--warning)' : 'var(--error)';
    quickStats.push(`<div class="char-quick-item"><span>❤️</span><span class="char-quick-val" style="color:${color}">${realFavor}</span></div>`);
  }
  if(stats['忠誠'] !== undefined){
    const loyalty = stats['忠誠'];
    const color = loyalty > 50 ? 'var(--success)' : 'var(--error)';
    quickStats.push(`<div class="char-quick-item"><span>🤝</span><span class="char-quick-val" style="color:${color}">${loyalty}</span></div>`);
  }
  if(stats['野心'] !== undefined){
    quickStats.push(`<div class="char-quick-item"><span>🔥</span><span class="char-quick-val" style="color:var(--warning)">${stats['野心']}</span></div>`);
  }
  // 其他常見屬性
  const otherKeys = Object.keys(stats).filter(k => !['好感','表面好感','真實好感','忠誠','野心'].includes(k));
  otherKeys.slice(0,2).forEach(k => {
    quickStats.push(`<div class="char-quick-item"><span>📊</span><span class="char-quick-val">${stats[k]}</span></div>`);
  });
  
  // 構建屬性條
  const statBars = Object.entries(stats).map(([key, val]) => {
    const numVal = parseInt(val) || 0;
    let colorClass = 'purple';
    if(['野心','敵意','危險'].some(k => key.includes(k))) colorClass = 'red';
    else if(['忠誠','好感','信任'].some(k => key.includes(k))) colorClass = numVal > 50 ? 'green' : 'red';
    else if(['智謀','智力','魅力'].some(k => key.includes(k))) colorClass = 'blue';
    else if(['容貌','魅力'].some(k => key.includes(k))) colorClass = 'pink';
    else if(['家世','財富','地位'].some(k => key.includes(k))) colorClass = 'gold';
    return `<div class="char-stat-bar">
      <div class="char-stat-header">
        <span class="char-stat-label">${key}</span>
        <span class="char-stat-value">${val}</span>
      </div>
      <div class="char-stat-track"><div class="char-stat-fill ${colorClass}" style="width:${Math.min(100,numVal)}%"></div></div>
    </div>`;
  }).join('');
  
  // 標籤
  const tagHtml = tags.map(t => {
    let cls = '';
    if(['危險','野心','敵對','陰險'].some(k => t.includes(k))) cls = 'danger';
    else if(['警告','注意','小心'].some(k => t.includes(k))) cls = 'warning';
    else if(['友好','忠誠','可信'].some(k => t.includes(k))) cls = 'success';
    else cls = 'info';
    return `<span class="char-tag ${cls}">${esc(t)}</span>`;
  }).join('');
  
  // 關係
  const relationHtml = relations.map(r => `
    <div class="char-relation">
      <div class="char-relation-avatar" style="background:linear-gradient(135deg,${r.type==='敵對'?'#ef4444,#f87171':r.type==='友好'?'#22c55e,#4ade80':'#3b82f6,#60a5fa'})">
        ${r.avatar || '👤'}
      </div>
      <div class="char-relation-info">
        <div class="char-relation-name">${esc(r.name)}</div>
        <div class="char-relation-type">${esc(r.description || r.type || '')}</div>
      </div>
      <span class="char-relation-status ${r.type==='敵對'?'enemy':r.type==='友好'?'ally':'neutral'}">${esc(r.type || '中立')}</span>
    </div>
  `).join('');
  
  return `<div class="char-card" id="char-${char.id}" onclick="toggleCharCard('${char.id}')">
    <div class="char-header">
      <div class="char-avatar" style="background:linear-gradient(135deg,${char.color||'var(--primary)'},${char.colorLight||'var(--primary-light)'})" onclick="event.stopPropagation();uploadCharAvatar('${char.id}')">
        ${char.avatarImage ? `<img src="${char.avatarImage}" alt="${esc(char.name)}">` : (char.avatar || '👤')}
        ${char.rank ? `<span class="char-avatar-rank">${esc(char.rank)}</span>` : ''}
        <div class="upload-btn">📷</div>
      </div>
      <div class="char-info">
        <div class="char-name">
          ${esc(char.name)}
          ${char.title ? `<span class="char-title">${esc(char.title)}</span>` : ''}
        </div>
        <div class="char-brief">${esc(char.brief || char.description || '')}</div>
        <div class="char-quick">${quickStats.join('')}</div>
      </div>
      <div class="char-expand">▼</div>
    </div>
    <div class="char-content">
      <div class="char-inner">
        <div class="char-tabs">
          <div class="char-tab active" onclick="event.stopPropagation();switchCharTab('${char.id}','basic')">基本</div>
          <div class="char-tab" onclick="event.stopPropagation();switchCharTab('${char.id}','stats')">屬性</div>
          <div class="char-tab" onclick="event.stopPropagation();switchCharTab('${char.id}','relation')">關係</div>
        </div>
        <div class="char-tab-content active" id="char-${char.id}-basic">
          ${char.description ? `<div class="char-desc">${esc(char.description)}</div>` : ''}
          ${tagHtml ? `<div class="char-tags">${tagHtml}</div>` : ''}
          ${char.extraInfo ? `<div class="char-mini-stats">${Object.entries(char.extraInfo).map(([k,v])=>`<div class="char-mini-stat"><div class="char-mini-val">${esc(String(v))}</div><div class="char-mini-label">${esc(k)}</div></div>`).join('')}</div>` : ''}
        </div>
        <div class="char-tab-content" id="char-${char.id}-stats">
          <div class="char-section">
            <div class="char-section-title">屬性數值</div>
            ${statBars || '<div style="font-size:12px;color:var(--text-tertiary)">暫無屬性數據</div>'}
          </div>
        </div>
        <div class="char-tab-content" id="char-${char.id}-relation">
          <div class="char-section">
            <div class="char-section-title">人物關係</div>
            ${relationHtml || '<div style="font-size:12px;color:var(--text-tertiary)">暫無關係數據</div>'}
          </div>
        </div>
        <div class="char-actions">
          <button class="char-action-btn secondary" onclick="event.stopPropagation();showCharHistory('${char.id}')">📜 歷史</button>
          <button class="char-action-btn primary" onclick="event.stopPropagation();showCharDetail('${char.id}')">📝 詳情</button>
        </div>
      </div>
    </div>
  </div>`;
}

// 展開/收起角色卡
function toggleCharCard(charId){
  const card = document.getElementById('char-'+charId);
  if(card) card.classList.toggle('expanded');
}

// 切換角色Tab
function switchCharTab(charId, tabName){
  const card = document.getElementById('char-'+charId);
  if(!card) return;
  card.querySelectorAll('.char-tab').forEach((t,i) => {
    t.classList.toggle('active', t.textContent.includes(tabName==='basic'?'基本':tabName==='stats'?'屬性':'關係'));
  });
  card.querySelectorAll('.char-tab-content').forEach(c => c.classList.remove('active'));
  const target = document.getElementById(`char-${charId}-${tabName}`);
  if(target) target.classList.add('active');
}

// 刷新/更新角色狀態（AI解析）
let _aiCharUpdateRange = 30;

function showAICharacterUpdate(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(!msgs.length){toast(T('故事內容為空，請先開始故事'),'warning');return;}
  showAiRangeSelector('🤖 AI 角色分析', (range) => {
    _aiCharUpdateRange = range;
    document.getElementById('char-update-result').textContent='點擊「開始分析」讓 AI 識別角色...';
    document.getElementById('char-update-btn').textContent='開始分析';
    document.getElementById('char-update-btn').disabled=false;
    showModal('char-update-modal');
  }, 30);
}

async function doCharacterUpdate(){
  const resultEl = document.getElementById('char-update-result');
  const btn = document.getElementById('char-update-btn');
  btn.disabled = true;
  btn.textContent = '分析中...';
  resultEl.textContent = '正在分析故事內容，識別角色...';
  
  // 構建提示詞
  const prompt = `你是一個專業的角色狀態提取助手。請仔細分析以下故事內容，識別所有出現的重要角色，並提取他們的狀態信息。

**重要：你必須返回完整的 JSON 格式，不可中途停止。**

請以 JSON 格式返回，格式如下：
\`\`\`json
{
  "characters": [
    {
      "name": "角色名",
      "title": "頭銜/身份（如皇夫、選侍等）",
      "rank": "品級（如一品、六品等，沒有則留空）",
      "avatar": "一個代表角色的emoji（如👑🗡️💐🎭）",
      "brief": "一句話簡介（20字以內）",
      "description": "詳細描述（性格、背景、特點，100字以內）",
      "stats": {
        "屬性名": 數值（0-100）
      },
      "tags": ["標籤1", "標籤2"],
      "relationships": [
        {
          "targetName": "關係對象的角色名",
          "type": "關係類型代碼（見下方列表）",
          "description": "關係的詳細描述（可選）"
        }
      ],
      "extraInfo": {
        "年齡": "19歲",
        "其他信息": "值"
      }
    }
  ]
}
\`\`\`

關係類型代碼（type）必須使用以下之一：
- lover: 戀人
- ex: 前任
- crush: 暗戀
- spouse: 配偶
- family: 家人
- friend: 朋友
- bestfriend: 摯友
- enemy: 敵人
- rival: 對手
- boss: 上司
- subordinate: 下屬
- mentor: 師徒
- colleague: 同事
- stranger: 陌生人

根據故事類型自動判斷合適的屬性：
- 後宮/宮鬥：好感、表面好感、真實好感、忠誠、野心、寵愛度等
- 修仙/玄幻：境界、靈力、壽元、功法等級等
- 末日/生存：生命、飢餓、精神、感染度等
- 冒險/RPG：HP、MP、力量、敏捷、等級等

故事內容：
${msgs.slice(-_aiCharUpdateRange).map(m=>(m.role==='user'?'【玩家】':'【AI】')+m.content).join('\n\n')}

**重要提醒：**
1. 必須返回完整的 JSON 格式
2. 確保所有角色信息都完整
3. 你有 8000 tokens 的額度，足夠輸出完整內容
4. 不要中途停止，必須完成所有角色的信息

現在開始分析並返回完整的 JSON：`;

  try{
    const resp = await callApi(prompt);
    let content = resp.content;
    console.log('[AI Character Update] 原始返回:', content);
    resultEl.textContent = '解析AI回覆...';

    // 提取JSON
    const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/) || content.match(/\{[\s\S]*"characters"[\s\S]*\}/);
    if(!jsonMatch){
      console.error('[AI Character Update] 無法找到 JSON 格式，原始返回:', content);
      resultEl.textContent = '❌ AI 回覆格式錯誤，無法解析角色數據\n\n原始回覆：\n' + content.slice(0,500);
      btn.disabled = false;
      btn.textContent = '重試';
      return;
    }

    const jsonStr = jsonMatch[1] || jsonMatch[0];
    console.log('[AI Character Update] 提取的 JSON:', jsonStr);

    let data;
    try {
      data = JSON.parse(jsonStr);
      console.log('[AI Character Update] 解析成功:', data);
    } catch(e) {
      console.error('[AI Character Update] JSON 解析失敗:', e, '原始內容:', jsonStr);
      resultEl.textContent = '❌ JSON 解析失敗：' + e.message + '\n\n原始內容：\n' + jsonStr.slice(0,500);
      btn.disabled = false;
      btn.textContent = '重試';
      return;
    }

    if(!data.characters || !data.characters.length){
      console.warn('[AI Character Update] 未識別到角色');
      resultEl.textContent = '❌ 未識別到角色，請確保故事中有角色出現';
      btn.disabled = false;
      btn.textContent = '重試';
      return;
    }

    console.log('[AI Character Update] 識別到', data.characters.length, '個角色');
    resultEl.textContent = `✅ 識別到 ${data.characters.length} 個角色，正在保存...`;

    // 輔助函數：智能映射關係類型
    const mapRelationType = (type) => {
      if(!type) return 'friend';
      const typeStr = String(type).toLowerCase().trim();

      // 直接匹配標準類型
      const validTypes = ['lover', 'ex', 'crush', 'spouse', 'family', 'friend', 'bestfriend',
                          'enemy', 'rival', 'boss', 'subordinate', 'mentor', 'colleague', 'stranger'];
      if(validTypes.includes(typeStr)) return typeStr;

      // 智能映射中文或其他描述
      const mapping = {
        '戀人': 'lover', '情侶': 'lover', '男友': 'lover', '女友': 'lover',
        '前任': 'ex', '前男友': 'ex', '前女友': 'ex',
        '暗戀': 'crush', '單戀': 'crush', '喜歡': 'crush',
        '配偶': 'spouse', '夫妻': 'spouse', '老公': 'spouse', '老婆': 'spouse', '丈夫': 'spouse', '妻子': 'spouse',
        '家人': 'family', '親人': 'family', '父母': 'family', '兄弟': 'family', '姐妹': 'family', '親屬': 'family',
        '朋友': 'friend', '友好': 'friend', '好友': 'friend',
        '摯友': 'bestfriend', '閨蜜': 'bestfriend', '死黨': 'bestfriend',
        '敵人': 'enemy', '仇人': 'enemy', '敵對': 'enemy',
        '對手': 'rival', '競爭': 'rival', '情敵': 'rival',
        '上司': 'boss', '老闆': 'boss', '領導': 'boss',
        '下屬': 'subordinate', '部下': 'subordinate', '手下': 'subordinate',
        '師徒': 'mentor', '師父': 'mentor', '徒弟': 'mentor', '老師': 'mentor',
        '同事': 'colleague', '同僚': 'colleague',
        '陌生人': 'stranger', '不熟': 'stranger', '中立': 'stranger'
      };

      return mapping[typeStr] || 'friend'; // 默認為朋友
    };

    // 輔助函數：根據角色名查找角色ID
    const findCharacterIdByName = async (name, allChars) => {
      if(!name) return null;
      const nameStr = String(name).trim().toLowerCase();
      const found = allChars.find(c => c.name && c.name.trim().toLowerCase() === nameStr);
      return found ? found.id : null;
    };

    // 驗證和清理AI生成的角色數據
    const validateCharacter = (char) => {
      const validated = {
        name: (char.name || '未知角色').trim(),
        title: typeof char.title === 'string' ? char.title : '',
        rank: typeof char.rank === 'string' ? char.rank : '',
        avatar: typeof char.avatar === 'string' ? char.avatar : '👤',
        brief: typeof char.brief === 'string' ? char.brief : '',
        description: typeof char.description === 'string' ? char.description : '',
        tags: Array.isArray(char.tags) ? char.tags.filter(t => typeof t === 'string') : [],
        stats: {},
        relationships: [], // 暫時為空，稍後處理
        extraInfo: typeof char.extraInfo === 'object' && char.extraInfo !== null ? char.extraInfo : {}
      };

      // 驗證stats：確保是數字且在合理範圍
      if(typeof char.stats === 'object' && char.stats !== null){
        for(const [key, val] of Object.entries(char.stats)){
          const numVal = parseFloat(val);
          if(!isNaN(numVal)){
            validated.stats[key] = Math.max(0, Math.min(100, numVal)); // 限制在0-100
          }
        }
      }

      // 保存原始 relationships 數據，稍後統一處理
      validated._rawRelationships = Array.isArray(char.relationships) ? char.relationships : [];

      return validated;
    };

    // 獲取現有角色
    const existing = await db.characters.where('storyId').equals(story.id).toArray();
    const existingMap = {};
    existing.forEach(c => existingMap[c.name] = c);

    // 更新或新增角色（第一階段：保存基本信息）
    let successCount = 0;
    let errorCount = 0;
    const validatedChars = []; // 保存驗證後的角色數據

    for(const rawChar of data.characters){
      try {
        const char = validateCharacter(rawChar);
        validatedChars.push(char);

        const existingChar = existingMap[char.name];
        if(existingChar){
          // 記錄歷史變化
          const oldStats = existingChar.stats || {};
          const newStats = char.stats || {};
          const changes = [];
          for(const [key, newVal] of Object.entries(newStats)){
            const oldVal = oldStats[key];
            if(oldVal !== undefined && oldVal !== newVal){
              changes.push({attr: key, from: oldVal, to: newVal});
            }
          }
          if(changes.length){
            await db.characterHistory.add({
              id: crypto.randomUUID(),
              storyId: story.id,
              characterId: existingChar.id,
              changes,
              createdAt: Date.now()
            });
          }
          // 更新角色（暫不包含 relationships）
          await db.characters.update(existingChar.id, {
            ...char,
            id: existingChar.id,
            storyId: story.id,
            relationships: existingChar.relationships || [], // 保留現有關係
            updatedAt: Date.now()
          });
        }else{
          // 新增角色（暫不包含 relationships）
          await db.characters.add({
            ...char,
            id: crypto.randomUUID(),
            storyId: story.id,
            relationships: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
          });
        }
        successCount++;
      } catch(e) {
        console.error('角色數據無效:', rawChar, e);
        errorCount++;
      }
    }

    // 第二階段：處理關係（所有角色都已保存後）
    resultEl.textContent = `✅ 角色已保存，正在處理關係...`;

    // 重新獲取所有角色（包括剛保存的）
    const allChars = await db.characters.where('storyId').equals(story.id).toArray();

    for(const char of validatedChars){
      if(!char._rawRelationships || char._rawRelationships.length === 0) continue;

      // 找到對應的數據庫角色
      const dbChar = allChars.find(c => c.name === char.name);
      if(!dbChar) continue;

      // 轉換關係數據
      const relationships = [];
      for(const rel of char._rawRelationships){
        if(!rel.targetName) continue;

        const targetId = await findCharacterIdByName(rel.targetName, allChars);
        if(!targetId) continue; // 目標角色不存在，跳過

        const typeInfo = RELATIONSHIP_TYPES.find(t => t.code === mapRelationType(rel.type));
        relationships.push({
          targetId: targetId,
          targetName: rel.targetName,
          type: mapRelationType(rel.type),
          label: typeInfo ? typeInfo.label : rel.type,
          description: rel.description || ''
        });
      }

      // 更新角色的關係
      if(relationships.length > 0){
        await db.characters.update(dbChar.id, {
          relationships: relationships,
          updatedAt: Date.now()
        });
      }
    }

    // 顯示結果
    if(errorCount === 0){
      resultEl.textContent = `✅ 成功更新 ${successCount} 個角色及其關係！`;
      toast(`已更新 ${successCount} 個角色及關係`, 'success');
    } else {
      resultEl.textContent = `⚠️ 成功 ${successCount} 個，失敗 ${errorCount} 個`;
      toast(`成功 ${successCount} 個，失敗 ${errorCount} 個`, 'warning');
    }
    closeModal('char-update-modal');
    renderCharacters();

  }catch(e){
    console.error('Character update error:', e);
    resultEl.textContent = '❌ 更新失敗: ' + e.message;
    btn.disabled = false;
    btn.textContent = '重試';
  }
}

// 手動添加角色
let editingCharacterId = null; // 記錄正在編輯的角色ID
let charAltGreetings = []; // 替代開場白數組
let charLorebookEntries = []; // 角色Lorebook條目

function addCharacterManual(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  editingCharacterId = null;
  resetCharEditForm();
  document.getElementById('char-modal-title').textContent = '➕ 添加角色';
  showModal('char-add-modal');
}

// 重置表單
function resetCharEditForm(){
  // 安全設置值的輔助函數
  const setVal = (id, val) => {
    const el = document.getElementById(id);
    if(el) el.value = val;
  };
  
  setVal('char-add-name', '');
  setVal('char-add-title', '');
  setVal('char-add-avatar', '');
  setVal('char-add-category', 'supporting');
  setVal('char-add-desc', '');
  setVal('char-add-personality', '');
  setVal('char-add-tags', '');
  setVal('char-add-firstmes', '');
  setVal('char-add-scenario', '');
  setVal('char-add-example', '');
  setVal('char-add-sysprompt', '');
  setVal('char-add-posthistory', '');
  setVal('char-add-creatornotes', '');
  setVal('char-add-creator', '');
  setVal('char-add-version', '1.0');
  setVal('char-add-lore-trigger', 'scene');
  setVal('char-add-stats', '');
  
  // 重置替代開場白
  charAltGreetings = [];
  renderAltGreetings();
  
  // 重置頭像圖片
  tempCharAvatarImage = null;
  const avatarPreview = document.getElementById('char-avatar-preview');
  if(avatarPreview) avatarPreview.style.display = 'none';
  const avatarImg = document.getElementById('char-avatar-img');
  if(avatarImg) avatarImg.src = '';
  
  // 重置Lorebook條目
  charLorebookEntries = [];
  renderCharLorebookEntries();
  
  // v25: 重置關係數據
  charRelationships = [];
  renderCharRelationships();
  
  // v25: 重置表情數據
  charExpressions = [];
  renderCharExpressions();
  const exprModeEl = document.getElementById('char-add-expr-mode');
  if(exprModeEl) exprModeEl.value = 'manual';
  
  // 重置面板狀態（只展開基本信息）
  document.querySelectorAll('.char-panel').forEach(p => {
    const panel = p.dataset.panel;
    const content = p.querySelector('.char-panel-content');
    const arrow = p.querySelector('.char-panel-arrow');
    if(content && arrow){
      if(panel === 'basic'){
        content.style.display = 'block';
        arrow.textContent = '▼';
        p.classList.add('expanded');
      } else {
        content.style.display = 'none';
        arrow.textContent = '▶';
        p.classList.remove('expanded');
      }
    }
  });
  
  updateCharTokenCount();
}

// 關閉角色編輯模態框
function closeCharEditModal(){
  closeModal('char-add-modal');
  editingCharacterId = null;
}

// 切換面板展開/折疊
function toggleCharPanel(panelName){
  const panel = document.querySelector(`.char-panel[data-panel="${panelName}"]`);
  if(!panel) return;
  
  const content = panel.querySelector('.char-panel-content');
  const arrow = panel.querySelector('.char-panel-arrow');
  
  if(content.style.display === 'none'){
    content.style.display = 'block';
    arrow.textContent = '▼';
    panel.classList.add('expanded');
  } else {
    content.style.display = 'none';
    arrow.textContent = '▶';
    panel.classList.remove('expanded');
  }
}

// 添加替代開場白
function addAltGreeting(){
  charAltGreetings.push('');
  renderAltGreetings();
}

// 渲染替代開場白
function renderAltGreetings(){
  const container = document.getElementById('char-alt-greetings');
  if(!container) return;
  
  container.innerHTML = charAltGreetings.map((g, i) => `
    <div class="alt-greeting-item">
      <textarea class="form-textarea" placeholder="替代開場白 ${i + 1}..." oninput="charAltGreetings[${i}]=this.value">${esc(g)}</textarea>
      <button class="delete-btn" onclick="removeAltGreeting(${i})">✕</button>
    </div>
  `).join('');
}

// 移除替代開場白
function removeAltGreeting(index){
  charAltGreetings.splice(index, 1);
  renderAltGreetings();
}

// 添加角色Lorebook條目
function addCharLorebookEntry(){
  charLorebookEntries.push({
    id: crypto.randomUUID(),
    keys: [],
    content: '',
    enabled: true,
    priority: 10
  });
  renderCharLorebookEntries();
}

// 渲染角色Lorebook條目
function renderCharLorebookEntries(){
  const container = document.getElementById('char-lorebook-entries');
  if(!container) return;
  
  container.innerHTML = charLorebookEntries.map((entry, i) => `
    <div class="char-lore-entry">
      <button class="delete-btn" onclick="removeCharLorebookEntry(${i})">✕</button>
      <div class="form-group" style="margin-bottom:8px">
        <input type="text" class="form-input" placeholder="觸發詞（用逗號分隔）" 
               value="${esc(entry.keys?.join(', ') || '')}"
               oninput="charLorebookEntries[${i}].keys=this.value.split(',').map(s=>s.trim()).filter(s=>s)"
               style="font-size:13px;padding:8px 12px">
      </div>
      <textarea class="form-textarea" placeholder="內容..." rows="2"
                oninput="charLorebookEntries[${i}].content=this.value"
                style="font-size:13px;min-height:60px">${esc(entry.content || '')}</textarea>
    </div>
  `).join('');
}

// 移除角色Lorebook條目
function removeCharLorebookEntry(index){
  charLorebookEntries.splice(index, 1);
  renderCharLorebookEntries();
}

// Token 計數（簡易估算）
function updateCharTokenCount(){
  const desc = document.getElementById('char-add-desc')?.value || '';
  const firstmes = document.getElementById('char-add-firstmes')?.value || '';
  const example = document.getElementById('char-add-example')?.value || '';
  const sysprompt = document.getElementById('char-add-sysprompt')?.value || '';
  
  // 簡易估算：中文約1.5字符/token，英文約4字符/token
  const estimateTokens = (text) => {
    const chineseChars = (text.match(/[\u4e00-\u9fff]/g) || []).length;
    const otherChars = text.length - chineseChars;
    return Math.ceil(chineseChars / 1.5 + otherChars / 4);
  };
  
  const descTokens = estimateTokens(desc);
  const firstmesTokens = estimateTokens(firstmes);
  const exampleTokens = estimateTokens(example);
  const syspromptTokens = estimateTokens(sysprompt);
  const total = descTokens + firstmesTokens + exampleTokens + syspromptTokens;
  
  // 更新顯示
  const descHint = document.getElementById('desc-tokens');
  const firstmesHint = document.getElementById('firstmes-tokens');
  const exampleHint = document.getElementById('example-tokens');
  const syspromptHint = document.getElementById('sysprompt-tokens');
  const totalHint = document.getElementById('char-token-count');
  
  if(descHint) descHint.textContent = descTokens > 0 ? `(~${descTokens} tokens)` : '';
  if(firstmesHint) firstmesHint.textContent = firstmesTokens > 0 ? `(~${firstmesTokens} tokens)` : '';
  if(exampleHint) exampleHint.textContent = exampleTokens > 0 ? `(~${exampleTokens} tokens)` : '';
  if(syspromptHint) syspromptHint.textContent = syspromptTokens > 0 ? `(~${syspromptTokens} tokens)` : '';
  if(totalHint) totalHint.textContent = total > 0 ? `總計 ~${total} tokens` : '';
}

// 可視化對話示例編輯器（簡易版）
function openVisualExampleEditor(){
  const current = document.getElementById('char-add-example')?.value || '';
  toast(T('可視化編輯器開發中，請直接在文本框中編輯'), 'info');
}

// 獲取當前活動的API預設
async function getActivePreset(){
  const preset = await db.apiPresets.filter(p => p.isActive).first();
  return preset;
}

// AI 輔助填寫
async function aiGenerateCharFields(){
  const name = document.getElementById('char-add-name')?.value?.trim();
  const desc = document.getElementById('char-add-desc')?.value?.trim();
  
  if(!name && !desc){
    toast(T('請先填寫角色名稱或描述'), 'warning');
    return;
  }
  
  const preset = await getActivePreset();
  if(!preset){
    toast(T('請先設置 API'), 'warning');
    return;
  }
  
  if(!preset.apiKey){
    toast(T('請先設置 API Key'), 'warning');
    return;
  }
  
  showLoading(T('AI 正在生成角色設定...'));
  
  try {
    const prompt = `根據以下角色信息，幫我生成完整的角色設定：

角色名稱：${name || '(未填寫)'}
已有描述：${desc || '(未填寫)'}

請生成以下內容（JSON格式）：
{
  "personality": "性格摘要（一句話描述性格特點）",
  "first_mes": "開場白（角色的第一條消息，用*描述動作*，用「對話」）",
  "scenario": "場景描述（對話發生的背景）",
  "tags": ["標籤1", "標籤2", "標籤3"]
}

只輸出JSON，不要其他內容。`;

    const response = await callLLMForJSON(prompt, preset);
    
    if(response){
      if(response.personality && !document.getElementById('char-add-personality')?.value){
        document.getElementById('char-add-personality').value = response.personality;
      }
      if(response.first_mes && !document.getElementById('char-add-firstmes')?.value){
        document.getElementById('char-add-firstmes').value = response.first_mes;
      }
      if(response.scenario && !document.getElementById('char-add-scenario')?.value){
        document.getElementById('char-add-scenario').value = response.scenario;
      }
      if(response.tags && !document.getElementById('char-add-tags')?.value){
        document.getElementById('char-add-tags').value = response.tags.join(', ');
      }
      
      // 展開對話設置面板
      const dialoguePanel = document.querySelector('.char-panel[data-panel="dialogue"]');
      if(dialoguePanel){
        const content = dialoguePanel.querySelector('.char-panel-content');
        const arrow = dialoguePanel.querySelector('.char-panel-arrow');
        content.style.display = 'block';
        arrow.textContent = '▼';
        dialoguePanel.classList.add('expanded');
      }
      
      updateCharTokenCount();
      toast(T('AI 已生成角色設定'), 'success');
    }
    
    hideLoading();
  } catch(err){
    hideLoading();
    console.error('AI generate error:', err);
    toast(T('AI 生成失敗: ') + err.message, 'error');
  }
}

// 調用LLM獲取JSON響應
async function callLLMForJSON(prompt, preset){
  const messages = [{role: 'user', content: prompt}];
  
  let apiUrl, headers, body;
  
  if(preset.type === 'anthropic'){
    apiUrl = 'https://api.anthropic.com/v1/messages';
    headers = {
      'Content-Type': 'application/json',
      'x-api-key': preset.apiKey,
      'anthropic-version': '2023-06-01'
    };
    body = {
      model: preset.model || 'claude-3-haiku-20240307',
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages
    };
  } else if(preset.type === 'openai'){
    apiUrl = 'https://api.openai.com/v1/chat/completions';
    headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${preset.apiKey}`
    };
    body = {
      model: preset.model || 'gpt-3.5-turbo',
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages
    };
  } else if(preset.type === 'custom'){
    const autoComplete = preset.urlAutoComplete !== false;
    apiUrl = normalizeApiUrl(preset.url || preset.baseUrl, autoComplete, preset.model);
    headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${preset.apiKey}`
    };
    body = {
      model: preset.model,
      max_tokens: 8000,  // 調整為 8000（Claude 可用，Gemini 可能需要更低）
      messages
    };
  }
  
  const res = await fetch(apiUrl, {
    method: 'POST',
    headers,
    body: JSON.stringify(body)
  });
  
  if(!res.ok){
    throw new Error(`API 錯誤: ${res.status}`);
  }
  
  const data = await res.json();
  let content = '';
  
  if(preset.type === 'anthropic'){
    content = data.content?.[0]?.text || '';
  } else {
    content = data.choices?.[0]?.message?.content || '';
  }
  
  // 嘗試提取JSON
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if(jsonMatch){
    return JSON.parse(jsonMatch[0]);
  }
  
  return null;
}

// 設置當前狀態為初始狀態
async function setCurrentAsInitialStats(){
  if(!editingCharacterId){
    toast(T('請先保存角色後再設置初始狀態'), 'warning');
    return;
  }
  
  const statsText = document.getElementById('char-add-stats')?.value?.trim() || '';
  const stats = {};
  if(statsText){
    statsText.split('\n').forEach(line => {
      const [key, val] = line.split(':').map(s => s.trim());
      if(key && val) stats[key] = parseInt(val) || val;
    });
  }
  
  if(Object.keys(stats).length === 0){
    toast(T('請先填寫屬性'), 'warning');
    return;
  }
  
  await db.characters.update(editingCharacterId, { 
    initialStats: { ...stats },
    updatedAt: Date.now()
  });
  
  toast(T('已設為初始狀態'), 'success');
}

// 設置當前完整設定為初始設定（包含所有字段）
async function setCurrentAsInitialState(){
  console.log('setCurrentAsInitialState called, editingCharacterId:', editingCharacterId);
  
  if(!editingCharacterId){
    toast(T('請先保存角色後再設置初始設定'), 'warning');
    console.log('No editingCharacterId, showing warning toast');
    return;
  }
  
  const getVal = (id) => document.getElementById(id)?.value?.trim() || '';
  
  // 檢查必填字段
  const name = getVal('char-add-name');
  if(!name){
    toast(T('請先填寫角色名稱'), 'warning');
    return;
  }
  
  // 收集所有字段
  const initialState = {
    name: name,
    title: getVal('char-add-title'),
    avatar: getVal('char-add-avatar') || '👤',
    category: getVal('char-add-category') || 'supporting',
    description: getVal('char-add-desc'),
    personality: getVal('char-add-personality'),
    tags: getVal('char-add-tags') ? getVal('char-add-tags').split(',').map(s => s.trim()).filter(s => s) : [],
    
    // 對話設置
    first_mes: getVal('char-add-firstmes'),
    scenario: getVal('char-add-scenario'),
    mes_example: getVal('char-add-example'),
    alternate_greetings: charAltGreetings ? charAltGreetings.filter(g => g.trim()) : [],
    
    // 高級設置
    system_prompt: getVal('char-add-sysprompt'),
    post_history_instructions: getVal('char-add-posthistory'),
    creator_notes: getVal('char-add-creatornotes'),
    creator: getVal('char-add-creator'),
    character_version: getVal('char-add-version') || '1.0',
    
    // 屬性
    stats: {}
  };
  
  // 解析屬性
  const statsText = getVal('char-add-stats');
  if(statsText){
    statsText.split('\n').forEach(line => {
      const [key, val] = line.split(':').map(s => s.trim());
      if(key && val) initialState.stats[key] = parseInt(val) || val;
    });
  }
  
  // Lorebook
  if(charLorebookEntries && charLorebookEntries.length > 0){
    const triggerMode = getVal('char-add-lore-trigger') || 'scene';
    initialState.character_book = {
      entries: charLorebookEntries.filter(e => e.keys?.length > 0 || e.content),
      triggerMode
    };
  }
  
  // 關係數據
  if(charRelationships){
    initialState.relationships = charRelationships.filter(r => r.targetId);
  }
  
  // 表情數據
  if(charExpressions){
    initialState.expressions = charExpressions;
    initialState.expressionMode = document.getElementById('char-add-expr-mode')?.value || 'manual';
  }
  
  // 獲取當前角色的圖片（如果有）
  const existingChar = await db.characters.get(editingCharacterId);
  if(tempCharAvatarImage){
    initialState.avatarImage = tempCharAvatarImage;
  } else if(existingChar?.avatarImage){
    initialState.avatarImage = existingChar.avatarImage;
  }
  
  // 確認操作
  showConfirm(`確定要將當前設定保存為初始設定嗎？\n\n之後「重新開始」時，角色將恢復到此版本的設定。\n\n這會覆蓋之前保存的初始設定。`, async () => {
    await db.characters.update(editingCharacterId, { 
      initialState: initialState,
      initialStats: { ...initialState.stats }, // 同時更新 initialStats 保持兼容
      updatedAt: Date.now()
    });
    
    toast(T('已保存為初始設定！'), 'success');
  });
}

// 恢復到初始狀態
async function resetToInitialStats(){
  if(!editingCharacterId){
    toast(T('請先保存角色'), 'warning');
    return;
  }
  
  const char = await db.characters.get(editingCharacterId);
  if(!char?.initialStats || Object.keys(char.initialStats).length === 0){
    toast(T('此角色沒有初始狀態記錄'), 'warning');
    return;
  }
  
  // 更新輸入框
  const statsText = Object.entries(char.initialStats).map(([k,v]) => `${k}:${v}`).join('\n');
  document.getElementById('char-add-stats').value = statsText;
  
  toast(T('已恢復到初始狀態（記得點保存）'), 'info');
}

async function saveCharacterManual(){
  const getVal = (id) => document.getElementById(id)?.value?.trim() || '';
  
  const name = getVal('char-add-name');
  if(!name){toast(T('請輸入角色名稱'),'warning');return;}
  
  // 收集所有字段
  const title = getVal('char-add-title');
  const avatar = getVal('char-add-avatar') || '👤';
  const category = getVal('char-add-category') || 'supporting';
  const desc = getVal('char-add-desc');
  const personality = getVal('char-add-personality');
  const tagsText = getVal('char-add-tags');
  const tags = tagsText ? tagsText.split(',').map(s => s.trim()).filter(s => s) : [];
  
  // 對話設置
  const first_mes = getVal('char-add-firstmes');
  const scenario = getVal('char-add-scenario');
  const mes_example = getVal('char-add-example');
  const alternate_greetings = charAltGreetings.filter(g => g.trim());
  
  // 高級設置
  const system_prompt = getVal('char-add-sysprompt');
  const post_history_instructions = getVal('char-add-posthistory');
  const creator_notes = getVal('char-add-creatornotes');
  const creator = getVal('char-add-creator');
  const character_version = getVal('char-add-version') || '1.0';
  
  // Lorebook
  const triggerMode = getVal('char-add-lore-trigger') || 'scene';
  const character_book = charLorebookEntries.length > 0 ? {
    entries: charLorebookEntries.filter(e => e.keys?.length > 0 || e.content),
    triggerMode
  } : null;
  
  // v25: 關係數據
  const relationships = charRelationships.filter(r => r.targetId);
  
  // v25: 表情數據
  const expressions = charExpressions;
  const expressionMode = document.getElementById('char-add-expr-mode')?.value || 'manual';
  
  // 屬性
  const statsText = getVal('char-add-stats');
  const stats = {};
  if(statsText){
    statsText.split('\n').forEach(line => {
      const [key, val] = line.split(':').map(s => s.trim());
      if(key && val) stats[key] = parseInt(val) || val;
    });
  }
  
  const now = Date.now();
  
  // 處理圖片
  const avatarImage = tempCharAvatarImage || (editingCharacterId ? (await db.characters.get(editingCharacterId))?.avatarImage : null);
  
  if(editingCharacterId){
    // 更新現有角色
    const existingChar = await db.characters.get(editingCharacterId);
    const updateData = {
      name, title, avatar, category, description: desc, personality, tags,
      first_mes, alternate_greetings, scenario, mes_example,
      system_prompt, post_history_instructions, creator_notes, creator, character_version,
      character_book, stats, relationships, expressions, expressionMode,
      updatedAt: now
    };
    // 如果有新上傳的圖片，或者顯式清除了圖片
    if(tempCharAvatarImage !== null) {
      updateData.avatarImage = tempCharAvatarImage || '';
    }
    // 如果角色還沒有initialStats，則保存當前stats作為初始值
    if(!existingChar?.initialStats && Object.keys(stats).length > 0){
      updateData.initialStats = { ...stats };
    }
    await db.characters.update(editingCharacterId, updateData);
    toast(T('角色已更新'), 'success');
  } else {
    // 創建新角色
    const char = {
      id: crypto.randomUUID(),
      storyId: story.id,
      name, title, avatar, category, description: desc, personality, tags,
      first_mes, alternate_greetings, scenario, mes_example,
      system_prompt, post_history_instructions, creator_notes, creator, character_version,
      character_book, stats,
      initialStats: Object.keys(stats).length > 0 ? { ...stats } : null, // 保存初始狀態
      relationships, expressions, expressionMode,
      avatarImage: tempCharAvatarImage || '',
      createdAt: now,
      updatedAt: now
    };
    
    await db.characters.add(char);
    toast(T('角色已添加'), 'success');
  }
  
  // 清除臨時圖片
  tempCharAvatarImage = null;
  
  closeCharEditModal();
  renderCharacters();
}

// ============ 角色卡導入/導出系統 ============
function showCharacterMenu(){
  const menu = document.getElementById('char-menu');
  menu.style.top = '50px';
  menu.style.right = '16px';
  menu.style.left = 'auto';
  menu.classList.add('active');
}

async function exportAllCharacters(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  if(!chars.length){toast(T('沒有角色可導出'),'warning');return;}
  
  // 轉換為完整格式（包含所有字段）
  const exportData = {
    format: 'zhimeng_characters_v2',
    exportedAt: new Date().toISOString(),
    storyTitle: story.title,
    characters: chars.map(c => ({
      // 基本信息
      name: c.name,
      title: c.title || '',
      avatar: c.avatar || '👤',
      avatarImage: c.avatarImage || '',
      category: c.category || 'supporting',
      description: c.description || '',
      personality: c.personality || '',
      tags: c.tags || [],
      
      // 對話設置
      first_mes: c.first_mes || '',
      scenario: c.scenario || '',
      mes_example: c.mes_example || '',
      alternate_greetings: c.alternate_greetings || [],
      
      // 高級設置
      system_prompt: c.system_prompt || '',
      post_history_instructions: c.post_history_instructions || '',
      creator_notes: c.creator_notes || '',
      creator: c.creator || '',
      character_version: c.character_version || '1.0',
      
      // 角色專屬 Lorebook
      character_book: c.character_book || null,
      
      // 屬性和狀態
      stats: c.stats || {},
      initialStats: c.initialStats || null,
      initialState: c.initialState || null,
      
      // 關係和表情
      relationships: c.relationships || [],
      expressions: c.expressions || [],
      expressionMode: c.expressionMode || 'manual',
      
      // 其他
      mood: c.mood || '',
      note: c.note || '',
      location: c.location || ''
    }))
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `角色卡_${story.title}_${new Date().toLocaleDateString()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  toast(`已導出 ${chars.length} 位角色`,'success');
}

function importCharacterCard(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,.png'; // 支持 JSON 和 PNG（SillyTavern 格式）
  input.onchange = async e => {
    const file = e.target.files[0];
    if(!file) return;
    
    try {
      showLoading('正在導入...');
      
      if(file.name.endsWith('.png')){
        // SillyTavern PNG 格式（角色卡嵌入在 PNG 元數據中）
        await importSillyTavernPNG(file);
      } else {
        // JSON 格式
        const text = await file.text();
        const data = JSON.parse(text);
        await importCharacterJSON(data);
      }
      
      hideLoading();
      renderCharacters();
    } catch(err) {
      hideLoading();
      console.error('Import error:', err);
      toast('導入失敗: ' + err.message, 'error');
    }
  };
  input.click();
}

async function importCharacterJSON(data){
  let imported = 0;
  
  // 檢測格式
  if((data.format === 'zhimeng_characters_v1' || data.format === 'zhimeng_characters_v2') && data.characters){
    // 織夢格式（v1 和 v2）
    for(const c of data.characters){
      await addImportedCharacter(c);
      imported++;
    }
  } else if(data.spec === 'chara_card_v2' || data.data){
    // SillyTavern/Character Card V2 格式
    const charData = data.data || data;
    
    // 完整提取 V2 所有字段
    const charToImport = {
      name: charData.name || data.name || '未知角色',
      description: charData.description || data.description || '',
      personality: charData.personality || data.personality || '',
      tags: charData.tags || data.tags || [],
      avatar: '👤',
      
      // 🆕 V2 字段
      scenario: charData.scenario || '',
      first_mes: charData.first_mes || '',
      alternate_greetings: charData.alternate_greetings || [],
      mes_example: charData.mes_example || '',
      system_prompt: charData.system_prompt || '',
      post_history_instructions: charData.post_history_instructions || '',
      character_book: charData.character_book || null,
      creator_notes: charData.creator_notes || '',
      creator: charData.creator || '',
      character_version: charData.character_version || '1.0',
      
      // 織夢擴展字段（如果有）
      ...(charData.extensions?.zhimeng || {})
    };
    
    const result = await addImportedCharacter(charToImport);
    if(result) imported = 1;
  } else if(data.name){
    // 簡單格式（單個角色）
    const result = await addImportedCharacter(data);
    if(result) imported = 1;
  } else if(Array.isArray(data)){
    // 角色數組
    for(const c of data){
      if(c.name){
        const result = await addImportedCharacter(c);
        if(result) imported++;
      }
    }
  } else {
    throw new Error('無法識別的角色卡格式');
  }
  
  if(imported > 0){
    toast(T(`已導入 ${imported} 位角色`),'success');
  } else {
    toast(T('導入已取消'),'info');
  }
}

async function importSillyTavernPNG(file){
  // 讀取 PNG 中嵌入的角色數據
  // SillyTavern 將角色數據存在 PNG 的 tEXt chunk 中
  const arrayBuffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(arrayBuffer);
  
  // 查找 tEXt chunk（包含 "chara" 關鍵字）
  const textDecoder = new TextDecoder('utf-8');
  let charaData = null;
  
  // 簡化處理：搜索 "chara" 關鍵字後的 base64 數據
  const str = textDecoder.decode(uint8Array);
  const charaMatch = str.match(/chara\x00([A-Za-z0-9+/=]+)/);
  
  if(charaMatch){
    try {
      const base64 = charaMatch[1];
      const jsonStr = atob(base64);
      charaData = JSON.parse(jsonStr);
    } catch(e){
      console.error('Failed to parse embedded data:', e);
    }
  }
  
  if(!charaData){
    // 嘗試作為普通 JSON 導入（用戶可能選錯了文件）
    throw new Error('無法從 PNG 中讀取角色數據，請確認這是有效的角色卡圖片');
  }
  
  await importCharacterJSON(charaData);
}

async function addImportedCharacter(c, skipConflictCheck = false){
  // 檢查是否已存在同名角色（不區分大小寫，忽略前後空格）
  const normalizedName = (c.name || '').trim().toLowerCase();
  const existing = await db.characters.where('storyId').equals(story.id).filter(x =>
    (x.name || '').trim().toLowerCase() === normalizedName
  ).first();

  // 處理重名衝突
  let finalName = (c.name || '未知角色').trim();
  let useExistingId = false;

  if(existing && !skipConflictCheck){
    // 顯示衝突處理選項
    const action = await showImportConflictDialog(finalName);

    if(action === 'cancel'){
      return null; // 取消導入
    } else if(action === 'rename'){
      // 自動重命名
      let suffix = 1;
      let newName = `${finalName}(${suffix})`;
      while(await db.characters.where('storyId').equals(story.id).filter(x =>
        (x.name || '').trim().toLowerCase() === newName.toLowerCase()
      ).first()){
        suffix++;
        newName = `${finalName}(${suffix})`;
      }
      finalName = newName;
    } else if(action === 'overwrite'){
      // 覆蓋現有角色
      useExistingId = true;
    }
  }
  
  // Character Card V2 完整字段支持
  const char = {
    // 基本信息
    id: useExistingId ? existing.id : crypto.randomUUID(),
    storyId: story.id,
    name: finalName,
    title: c.title || '',
    avatar: c.avatar || '👤',
    avatarImage: c.avatarImage || c.avatar_image || '',
    description: c.description || '',
    personality: c.personality || '',
    tags: c.tags || [],
    
    // 🆕 分類系統
    category: c.category || 'supporting', // protagonist/supporting/npc/custom
    
    // 🆕 關係系統
    relationships: c.relationships || c.relations || [],
    
    // 🆕 對話設置（Character Card V2）
    scenario: c.scenario || '',
    first_mes: c.first_mes || c.firstMessage || '',
    alternate_greetings: c.alternate_greetings || [],
    mes_example: c.mes_example || c.messageExample || '',
    
    // 🆕 高級設置（Character Card V2）
    system_prompt: c.system_prompt || c.systemPrompt || '',
    post_history_instructions: c.post_history_instructions || c.postHistoryInstructions || '',
    
    // 🆕 角色專屬 Lorebook
    character_book: c.character_book || null,
    
    // 🆕 表情系統
    expressions: c.expressions || [],
    expressionMode: c.expressionMode || 'manual', // manual/auto
    currentExpression: c.currentExpression || null,
    
    // 🆕 創作者信息
    creator_notes: c.creator_notes || '',
    creator: c.creator || '',
    character_version: c.character_version || '1.0',
    
    // 現有字段
    stats: c.stats || {},
    initialStats: c.initialStats || null,
    initialState: c.initialState || null,
    mood: c.mood || '',
    note: c.note || '',
    location: c.location || '',
    
    // 時間戳
    createdAt: useExistingId ? existing.createdAt : Date.now(),
    updatedAt: Date.now()
  };
  
  await db.characters.put(char);
  return char;
}

// 顯示導入衝突對話框
function showImportConflictDialog(charName){
  return new Promise(resolve => {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:10000';
    modal.innerHTML = `
      <div class="modal" style="display:block;position:relative;transform:none;max-width:min(90%,360px)">
        <div class="modal-title">⚠️ 角色名稱衝突</div>
        <div style="padding:16px 0;text-align:center">
          <p style="margin-bottom:12px">角色「<strong>${esc(charName)}</strong>」已存在</p>
          <p style="color:var(--text-secondary);font-size:14px">請選擇處理方式：</p>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px;padding:0 0 16px">
          <button class="modal-btn" onclick="this.closest('.modal-overlay').dataset.action='overwrite';this.closest('.modal-overlay').remove()" style="padding:12px">
            🔄 覆蓋現有角色
          </button>
          <button class="modal-btn secondary" onclick="this.closest('.modal-overlay').dataset.action='rename';this.closest('.modal-overlay').remove()" style="padding:12px">
            📝 重命名為「${esc(charName)}(1)」
          </button>
          <button class="modal-btn cancel" onclick="this.closest('.modal-overlay').dataset.action='cancel';this.closest('.modal-overlay').remove()" style="padding:12px">
            ❌ 取消導入
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);

    // 監聽移除事件
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if(node === modal){
            clearTimeout(timeoutId);  // 清除超時定時器
            observer.disconnect();
            resolve(modal.dataset.action || 'cancel');
          }
        });
      });
    });
    observer.observe(document.body, {childList: true});

    // 添加超時保護（30秒後自動清理）
    const timeoutId = setTimeout(() => {
      observer.disconnect();
      if(modal.parentNode) {
        modal.remove();
      }
      console.warn('showImportConflictDialog: 超時自動清理');
      resolve('cancel');
    }, 30000);
  });
}

async function exportSingleCharacter(charId){
  const char = await db.characters.get(charId);
  if(!char){toast(T('角色不存在'),'error');return;}
  
  // 完整的 Character Card V2 格式導出
  const exportData = {
    spec: 'chara_card_v2',
    spec_version: '2.0',
    data: {
      // 基本信息
      name: char.name,
      description: char.description || '',
      personality: char.personality || '',
      tags: char.tags || [],
      
      // 🆕 對話設置（導出實際數據）
      scenario: char.scenario || '',
      first_mes: char.first_mes || '',
      alternate_greetings: char.alternate_greetings || [],
      mes_example: char.mes_example || '',
      
      // 🆕 高級設置（導出實際數據）
      system_prompt: char.system_prompt || '',
      post_history_instructions: char.post_history_instructions || '',
      
      // 🆕 角色專屬 Lorebook
      character_book: char.character_book || null,
      
      // 創作者信息
      creator_notes: char.creator_notes || `從織夢導出 - ${story?.title || ''}`,
      creator: char.creator || '織夢',
      character_version: char.character_version || '1.0',
      
      // 織夢擴展字段
      extensions: {
        zhimeng: {
          title: char.title || '',
          avatar: char.avatar || '👤',
          avatarImage: char.avatarImage || '',
          category: char.category || 'supporting',
          relationships: char.relationships || [],
          expressions: char.expressions || [],
          expressionMode: char.expressionMode || 'manual',
          stats: char.stats || {},
          initialStats: char.initialStats || null,
          initialState: char.initialState || null,
          mood: char.mood || '',
          note: char.note || '',
          location: char.location || ''
        }
      }
    }
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${char.name}_角色卡.json`;
  a.click();
  URL.revokeObjectURL(url);
  toast(`已導出角色「${char.name}」`,'success');
}

// 🆕 PNG 角色卡導出
async function exportCharacterAsPNG(charId){
  const char = await db.characters.get(charId);
  if(!char){toast(T('角色不存在'),'error');return;}
  
  showLoading(T('正在生成 PNG 角色卡...'));
  
  try {
    // 準備角色數據
    const charData = {
      spec: 'chara_card_v2',
      spec_version: '2.0',
      data: {
        name: char.name,
        description: char.description || '',
        personality: char.personality || '',
        tags: char.tags || [],
        scenario: char.scenario || '',
        first_mes: char.first_mes || '',
        alternate_greetings: char.alternate_greetings || [],
        mes_example: char.mes_example || '',
        system_prompt: char.system_prompt || '',
        post_history_instructions: char.post_history_instructions || '',
        character_book: char.character_book || null,
        creator_notes: char.creator_notes || `從織夢導出`,
        creator: char.creator || '織夢',
        character_version: char.character_version || '1.0',
        extensions: {
          zhimeng: {
            title: char.title,
            avatar: char.avatar,
            category: char.category,
            relationships: char.relationships,
            expressions: char.expressions,
            expressionMode: char.expressionMode,
            stats: char.stats,
            initialStats: char.initialStats || null,
            initialState: char.initialState || null
          }
        }
      }
    };
    
    // 將數據編碼為 base64
    const jsonStr = JSON.stringify(charData);
    const base64Data = btoa(unescape(encodeURIComponent(jsonStr)));
    
    // 創建 canvas
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // 如果有頭像圖片，使用它；否則生成默認圖片
    if(char.avatarImage && char.avatarImage.startsWith('data:image')){
      // 使用角色頭像
      const img = new Image();
      let handled = false; // 防止重複執行

      const imgTimeout = setTimeout(() => {
        if(!handled){
          handled = true;
          console.warn('[Character PNG] 頭像加載超時，使用默認圖片');
          generateDefaultCharacterPNG(canvas, ctx, char, base64Data);
        }
      }, 10000); // 10秒超时

      img.onload = () => {
        if(!handled){
          handled = true;
          clearTimeout(imgTimeout);
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          // 導出帶元數據的 PNG
          exportPNGWithMetadata(canvas, base64Data, char.name);
        }
      };
      img.onerror = () => {
        if(!handled){
          handled = true;
          clearTimeout(imgTimeout);
          // 頭像加載失敗，使用默認圖片
          generateDefaultCharacterPNG(canvas, ctx, char, base64Data);
        }
      };
      img.src = char.avatarImage;
    } else {
      // 生成默認角色卡圖片
      generateDefaultCharacterPNG(canvas, ctx, char, base64Data);
    }
  } catch(err) {
    hideLoading();
    console.error('PNG export error:', err);
    toast(T('PNG 導出失敗: ') + err.message, 'error');
  }
}

// 生成默認角色卡圖片
function generateDefaultCharacterPNG(canvas, ctx, char, base64Data){
  canvas.width = 400;
  canvas.height = 600;
  
  // 背景漸變
  const gradient = ctx.createLinearGradient(0, 0, 0, 600);
  gradient.addColorStop(0, '#1a1a2e');
  gradient.addColorStop(1, '#16213e');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 400, 600);
  
  // 裝飾邊框
  ctx.strokeStyle = '#8b7cf7';
  ctx.lineWidth = 4;
  ctx.strokeRect(10, 10, 380, 580);
  
  // 頭像區域（使用 emoji）
  ctx.fillStyle = '#252540';
  ctx.beginPath();
  ctx.arc(200, 150, 80, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.font = '72px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(char.avatar || '👤', 200, 150);
  
  // 角色名
  ctx.fillStyle = '#e5e7eb';
  ctx.font = 'bold 32px sans-serif';
  ctx.fillText(char.name, 200, 280);
  
  // 頭銜
  if(char.title){
    ctx.fillStyle = '#9ca3af';
    ctx.font = '18px sans-serif';
    ctx.fillText(char.title, 200, 320);
  }
  
  // 分隔線
  ctx.strokeStyle = '#8b7cf7';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(50, 360);
  ctx.lineTo(350, 360);
  ctx.stroke();
  
  // 描述（截取前100字）
  const desc = (char.description || '').slice(0, 100);
  if(desc){
    ctx.fillStyle = '#9ca3af';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    
    // 自動換行
    const words = desc.split('');
    let line = '';
    let y = 400;
    const maxWidth = 320;
    
    for(let i = 0; i < words.length && y < 560; i++){
      const testLine = line + words[i];
      const metrics = ctx.measureText(testLine);
      if(metrics.width > maxWidth){
        ctx.fillText(line, 40, y);
        line = words[i];
        y += 24;
      } else {
        line = testLine;
      }
    }
    if(line && y < 560){
      ctx.fillText(line + (desc.length > 100 ? '...' : ''), 40, y);
    }
  }
  
  // 底部標識
  ctx.fillStyle = '#6b7280';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('織夢 Character Card V2', 200, 580);
  
  // 導出
  exportPNGWithMetadata(canvas, base64Data, char.name);
}

// 將元數據嵌入 PNG 並導出
function exportPNGWithMetadata(canvas, base64Data, charName){
  // 獲取 PNG 數據
  canvas.toBlob(async blob => {
    try {
      const arrayBuffer = await blob.arrayBuffer();
      const uint8Array = new Uint8Array(arrayBuffer);
      
      // 創建 tEXt chunk
      // tEXt chunk 格式：長度(4字節) + "tEXt"(4字節) + 關鍵字 + null + 數據 + CRC(4字節)
      const keyword = 'chara';
      const keywordBytes = new TextEncoder().encode(keyword);
      const dataBytes = new TextEncoder().encode(base64Data);
      
      // chunk 內容 = 關鍵字 + null分隔符 + 數據
      const chunkContent = new Uint8Array(keywordBytes.length + 1 + dataBytes.length);
      chunkContent.set(keywordBytes, 0);
      chunkContent[keywordBytes.length] = 0; // null 分隔符
      chunkContent.set(dataBytes, keywordBytes.length + 1);
      
      // 計算 CRC32
      const typeAndData = new Uint8Array(4 + chunkContent.length);
      typeAndData.set(new TextEncoder().encode('tEXt'), 0);
      typeAndData.set(chunkContent, 4);
      const crc = crc32(typeAndData);
      
      // 構建完整的 tEXt chunk
      const chunkLength = chunkContent.length;
      const textChunk = new Uint8Array(4 + 4 + chunkContent.length + 4);
      // 長度（大端序）
      textChunk[0] = (chunkLength >> 24) & 0xff;
      textChunk[1] = (chunkLength >> 16) & 0xff;
      textChunk[2] = (chunkLength >> 8) & 0xff;
      textChunk[3] = chunkLength & 0xff;
      // 類型
      textChunk.set(new TextEncoder().encode('tEXt'), 4);
      // 內容
      textChunk.set(chunkContent, 8);
      // CRC
      textChunk[textChunk.length - 4] = (crc >> 24) & 0xff;
      textChunk[textChunk.length - 3] = (crc >> 16) & 0xff;
      textChunk[textChunk.length - 2] = (crc >> 8) & 0xff;
      textChunk[textChunk.length - 1] = crc & 0xff;
      
      // 找到 IEND chunk 的位置（PNG 結尾）
      // IEND 標識是 "IEND" 前面4字節是長度(0)
      let iendPos = uint8Array.length - 12;
      for(let i = uint8Array.length - 12; i >= 8; i--){
        if(uint8Array[i] === 0x49 && uint8Array[i+1] === 0x45 && 
           uint8Array[i+2] === 0x4E && uint8Array[i+3] === 0x44){
          iendPos = i - 4; // IEND chunk 開始位置（含長度字節）
          break;
        }
      }
      
      // 構建新的 PNG 文件
      const newPng = new Uint8Array(uint8Array.length + textChunk.length);
      newPng.set(uint8Array.slice(0, iendPos), 0);
      newPng.set(textChunk, iendPos);
      newPng.set(uint8Array.slice(iendPos), iendPos + textChunk.length);
      
      // 下載
      const finalBlob = new Blob([newPng], {type: 'image/png'});
      const url = URL.createObjectURL(finalBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${charName}_角色卡.png`;
      a.click();
      URL.revokeObjectURL(url);
      
      hideLoading();
      toast(T(`已導出 PNG 角色卡「${charName}」`), 'success');
    } catch(err){
      hideLoading();
      console.error('PNG metadata error:', err);
      toast(T('PNG 元數據寫入失敗'), 'error');
    }
  }, 'image/png');
}

// CRC32 計算（用於 PNG chunk）
function crc32(data){
  let crc = 0xffffffff;
  const table = crc32Table();
  for(let i = 0; i < data.length; i++){
    crc = (crc >>> 8) ^ table[(crc ^ data[i]) & 0xff];
  }
  return (crc ^ 0xffffffff) >>> 0;
}

function crc32Table(){
  const table = new Uint32Array(256);
  for(let i = 0; i < 256; i++){
    let c = i;
    for(let j = 0; j < 8; j++){
      c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[i] = c;
  }
  return table;
}

// 🆕 從 URL 導入角色卡
async function importCharacterFromURL(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  
  // 清空输入框
  const input = document.getElementById('char-url-input');
  if(input) input.value = '';
  
  showModal('char-url-import-modal');
}

// 执行URL导入
async function doImportFromURL(){
  const input = document.getElementById('char-url-input');
  const url = input?.value?.trim();
  
  if(!url){
    toast(T('請輸入 URL'),'warning');
    return;
  }
  
  closeModal('char-url-import-modal');
  showLoading(T('正在從 URL 導入...'));
  
  try {
    let charData = null;
    
    // 檢測 URL 類型
    if(url.includes('chub.ai') || url.includes('characterhub.org')){
      // Chub.ai / CharacterHub 平台
      charData = await importFromChub(url);
    } else if(url.endsWith('.json')){
      // 直接 JSON 文件
      const response = await fetch(url);
      if(!response.ok) throw new Error('無法獲取文件');
      charData = await response.json();
    } else if(url.endsWith('.png')){
      // 直接 PNG 文件
      const response = await fetch(url);
      if(!response.ok) throw new Error('無法獲取文件');
      const blob = await response.blob();
      const file = new File([blob], 'character.png', {type: 'image/png'});
      await importSillyTavernPNG(file);
      hideLoading();
      renderCharacters();
      return;
    } else {
      // 嘗試作為 JSON 獲取
      const response = await fetch(url);
      if(!response.ok) throw new Error('無法獲取文件');
      const text = await response.text();
      try {
        charData = JSON.parse(text);
      } catch(e){
        throw new Error('無法解析為 JSON 格式');
      }
    }
    
    if(charData){
      await importCharacterJSON(charData);
    }
    
    hideLoading();
    renderCharacters();
  } catch(err){
    hideLoading();
    console.error('URL import error:', err);
    toast(T('從 URL 導入失敗: ') + err.message, 'error');
  }
}

// 從 Chub.ai / CharacterHub 導入
async function importFromChub(url){
  // 提取角色 ID
  // Chub.ai URL 格式: https://chub.ai/characters/username/character-name
  // CharacterHub URL 格式: https://www.characterhub.org/characters/username/character-name
  
  let apiUrl = '';
  
  if(url.includes('chub.ai')){
    // Chub.ai API
    const match = url.match(/chub\.ai\/characters\/([^\/]+\/[^\/\?]+)/);
    if(!match) throw new Error('無法解析 Chub.ai URL');
    const charPath = match[1];
    apiUrl = `https://api.chub.ai/api/characters/${charPath}?full=true`;
  } else if(url.includes('characterhub.org')){
    // CharacterHub - 嘗試獲取 JSON
    const match = url.match(/characterhub\.org\/characters\/([^\/]+\/[^\/\?]+)/);
    if(!match) throw new Error('無法解析 CharacterHub URL');
    const charPath = match[1];
    // CharacterHub 可能有不同的 API 結構，這裡嘗試常見格式
    apiUrl = `https://www.characterhub.org/api/v1/characters/${charPath}`;
  }
  
  if(!apiUrl){
    throw new Error('不支持的平台 URL');
  }
  
  try {
    const response = await fetch(apiUrl, {
      headers: {
        'Accept': 'application/json'
      }
    });
    
    if(!response.ok){
      // 如果 API 失敗，嘗試直接獲取頁面並提取數據
      throw new Error('API 請求失敗，可能需要登錄或該平台不支持公開 API');
    }
    
    const data = await response.json();
    
    // 轉換為 Character Card V2 格式
    if(data.node || data.fullPath){
      // Chub.ai 格式
      const node = data.node || data;
      return {
        spec: 'chara_card_v2',
        data: {
          name: node.name || data.name,
          description: node.description || data.description || '',
          personality: node.personality || '',
          scenario: node.scenario || '',
          first_mes: node.first_mes || node.greeting || '',
          mes_example: node.mes_example || node.example_dialogs || '',
          system_prompt: node.system_prompt || '',
          post_history_instructions: node.post_history_instructions || '',
          alternate_greetings: node.alternate_greetings || [],
          tags: node.topics || node.tags || [],
          creator: node.creator?.username || node.fullPath?.split('/')[0] || '',
          character_version: node.version || '1.0'
        }
      };
    }
    
    // 如果已經是標準格式，直接返回
    return data;
  } catch(err){
    console.error('Chub import error:', err);
    throw new Error('從平台導入失敗: ' + err.message + '\n\n提示：某些平台可能需要登錄才能訪問角色數據。您可以嘗試：\n1. 在平台上下載角色卡文件\n2. 使用「導入角色卡（文件）」功能導入');
  }
}

async function clearAllCharacters(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(!confirm('確定要清空所有角色嗎？此操作不可恢復！')) return;

  // 刪除所有角色
  await db.characters.where('storyId').equals(story.id).delete();
  // 刪除所有角色歷史記錄
  await db.characterHistory.where('storyId').equals(story.id).delete();
  // 刪除所有角色快照
  await db.characterSnapshots.where('storyId').equals(story.id).delete();
  // 刪除所有角色狀態
  await db.characterStates.where('storyId').equals(story.id).delete();
  renderCharacters();
  toast(T('已清空所有角色'),'success');
}

function exportCurrentCharacter(){
  showCharExportOptions();
}

function showCharExportOptions(){
  if(!currentCharacterId){
    toast(T('請先選擇角色'),'warning');
    return;
  }
  showModal('char-export-modal');
}

function exportCurrentCharacterJSON(){
  closeModal('char-export-modal');
  if(currentCharacterId){
    exportSingleCharacter(currentCharacterId);
  }
}

function exportCurrentCharacterPNG(){
  closeModal('char-export-modal');
  if(currentCharacterId){
    exportCharacterAsPNG(currentCharacterId);
  }
}

// ============ 財產系統 ============
let editInventoryItemId = null;
let selectedInventoryIcon = '💰';

// 渲染財產列表
async function renderInventory(){
  if(!story) return;
  const container = document.getElementById('inventory-list');
  const inventory = story.inventory || [];

  if(!inventory.length){
    container.innerHTML = `<div class="empty" style="padding:40px 20px">
      <div class="empty-icon">💰</div>
      <div class="empty-title">財產清單是空的</div>
      <div class="empty-desc">點擊右上角 ➕ 手動添加資產，或點擊 🤖 讓 AI 從對話中智能識別</div>
    </div>`;
    return;
  }

  const searchTerm = (document.getElementById('inventory-search')?.value || '').toLowerCase();
  const categoryFilter = document.getElementById('inventory-filter')?.value || 'all';

  const filtered = inventory.filter(item => {
    const matchSearch = !searchTerm ||
      item.name.toLowerCase().includes(searchTerm) ||
      (item.description || '').toLowerCase().includes(searchTerm);
    const matchCategory = categoryFilter === 'all' || item.category === categoryFilter;
    return matchSearch && matchCategory;
  });

  if(!filtered.length){
    container.innerHTML = `<div class="empty" style="padding:40px 20px">
      <div class="empty-icon">🔍</div>
      <div class="empty-title">沒有匹配的資產</div>
    </div>`;
    return;
  }

  const categoryNames = {
    money: '💰 金錢', property: '🏠 房產', vehicle: '🚗 載具',
    valuable: '💎 貴重物品', other: '📋 其他'
  };

  const locationNames = {
    on_person: '👤 身上', home: '🏠 家中', bank: '🏦 銀行',
    warehouse: '📦 倉庫', other_location: '📍 其他地點'
  };

  container.innerHTML = filtered.map(item => {
    const hasLorebook = item.lorebookId ? 'has-lorebook' : '';
    const locationText = item.location ? ` · ${locationNames[item.location] || '📍 其他'}` : '';
    return `<div class="inventory-item ${hasLorebook}" data-id="${item.id}">
      <div class="inventory-item-icon">${esc(item.icon || '💰')}</div>
      <div class="inventory-item-info">
        <div class="inventory-item-name">
          ${esc(item.name)}
          ${item.quantity > 1 ? `<span class="quantity">×${item.quantity}</span>` : ''}
        </div>
        <div class="inventory-item-category">${categoryNames[item.category] || '📋 其他'}${locationText}${item.lorebookId ? ' · 🔮 已連結Lorebook' : ''}</div>
        ${item.description ? `<div class="inventory-item-desc">${esc(item.description)}</div>` : ''}
      </div>
      <div class="inventory-item-actions">
        <button class="inventory-item-btn" onclick="editInventoryItem('${item.id}')">✏️</button>
        <button class="inventory-item-btn danger" onclick="deleteInventoryItem('${item.id}')">🗑️</button>
      </div>
    </div>`;
  }).join('');
}

// 过滤財產
function filterInventory(){
  renderInventory();
}

// 选择图标
function selectInventoryIcon(icon){
  selectedInventoryIcon = icon;
  document.getElementById('inventory-item-icon').value = icon;
  document.querySelectorAll('#inventory-icon-picker .icon-option').forEach(el => {
    el.classList.toggle('selected', el.textContent === icon);
  });
}

// 添加資產
function addInventoryItem(){
  editInventoryItemId = null;
  selectedInventoryIcon = '💰';
  document.getElementById('inventory-modal-title').textContent = '➕ 添加資產';
  document.getElementById('inventory-item-icon').value = '';
  document.getElementById('inventory-item-name').value = '';
  document.getElementById('inventory-item-quantity').value = '1';
  document.getElementById('inventory-item-category').value = 'other';
  document.getElementById('inventory-item-location').value = 'on_person';
  document.getElementById('inventory-item-desc').value = '';
  document.getElementById('inventory-item-lorebook').checked = true;
  document.querySelectorAll('#inventory-icon-picker .icon-option').forEach(el => el.classList.remove('selected'));
  showModal('inventory-item-modal');
}

// 编辑資產
function editInventoryItem(id){
  const inventory = story.inventory || [];
  const item = inventory.find(i => i.id === id);
  if(!item) return;

  editInventoryItemId = id;
  selectedInventoryIcon = item.icon || '💰';
  document.getElementById('inventory-modal-title').textContent = '✏️ 編輯資產';
  document.getElementById('inventory-item-icon').value = item.icon || '';
  document.getElementById('inventory-item-name').value = item.name;
  document.getElementById('inventory-item-quantity').value = item.quantity || 1;
  document.getElementById('inventory-item-category').value = item.category || 'other';
  document.getElementById('inventory-item-location').value = item.location || 'on_person';
  document.getElementById('inventory-item-desc').value = item.description || '';
  document.getElementById('inventory-item-lorebook').checked = !!item.lorebookId;

  document.querySelectorAll('#inventory-icon-picker .icon-option').forEach(el => {
    el.classList.toggle('selected', el.textContent === selectedInventoryIcon);
  });
  showModal('inventory-item-modal');
}

// 保存資產
async function saveInventoryItem(){
  const name = document.getElementById('inventory-item-name').value.trim();
  if(!name){
    toast(T('請輸入資產名稱'),'warning');
    return;
  }

  const icon = document.getElementById('inventory-item-icon').value.trim() || selectedInventoryIcon || '💰';
  const quantity = parseInt(document.getElementById('inventory-item-quantity').value) || 1;
  const category = document.getElementById('inventory-item-category').value;
  const location = document.getElementById('inventory-item-location').value;
  const description = document.getElementById('inventory-item-desc').value.trim();
  const syncLorebook = document.getElementById('inventory-item-lorebook').checked;

  let inventory = story.inventory || [];
  let item;

  if(editInventoryItemId){
    // 编辑现有資產
    const idx = inventory.findIndex(i => i.id === editInventoryItemId);
    if(idx >= 0){
      item = inventory[idx];
      item.name = name;
      item.icon = icon;
      item.quantity = quantity;
      item.category = category;
      item.location = location;
      item.description = description;
      item.updatedAt = Date.now();
    }
  } else {
    // 添加新資產
    item = {
      id: crypto.randomUUID(),
      name,
      icon,
      quantity,
      category,
      location,
      description,
      createdAt: Date.now()
    };
    inventory.push(item);
  }
  
  // 同步到Lorebook
  if(syncLorebook && item){
    await syncInventoryToLorebook(item);
  } else if(!syncLorebook && item && item.lorebookId){
    // 取消同步，删除Lorebook条目
    await db.lorebook.delete(item.lorebookId);
    item.lorebookId = null;
  }
  
  story.inventory = inventory;
  await db.stories.update(story.id, { inventory });
  
  closeModal('inventory-item-modal');
  renderInventory();
  toast(editInventoryItemId ? '資產已更新' : '資產已添加', 'success');
}

// 同步到Lorebook
async function syncInventoryToLorebook(item){
  const categoryNames = {
    money: '金錢', property: '房產', vehicle: '載具',
    valuable: '貴重物品', other: '資產'
  };

  const locationNames = {
    on_person: '身上', home: '家中', bank: '銀行',
    warehouse: '倉庫', other_location: '其他地點'
  };

  const locationText = item.location ? `，存放於${locationNames[item.location] || '其他地點'}` : '';
  const content = `【${categoryNames[item.category] || '資產'}】${item.name}${locationText}
${item.description || '玩家的財產。'}`;

  if(item.lorebookId){
    // 更新现有Lorebook
    await db.lorebook.update(item.lorebookId, {
      name: `💰 ${item.name}`,
      keywords: [item.name],
      content,
      updatedAt: Date.now()
    });
  } else {
    // 创建新Lorebook
    const lorebookId = crypto.randomUUID();
    await db.lorebook.put({
      id: lorebookId,
      storyId: story.id,
      name: `💰 ${item.name}`,
      keywords: [item.name],
      content,
      isEnabled: true,
      priority: 5,
      insertPosition: 'before',
      createdAt: Date.now()
    });
    item.lorebookId = lorebookId;
  }
}

// 删除資產
async function deleteInventoryItem(id){
  showConfirm('確定要刪除這個資產嗎？', async () => {
    let inventory = story.inventory || [];
    const item = inventory.find(i => i.id === id);

    // 删除关联的Lorebook
    if(item && item.lorebookId){
      await db.lorebook.delete(item.lorebookId);
    }

    inventory = inventory.filter(i => i.id !== id);
    story.inventory = inventory;
    await db.stories.update(story.id, { inventory });

    renderInventory();
    toast(T('資產已刪除'), 'success');
  });
}

// AI智能同步財產
async function aiSyncInventory(){
  if(!story) return;

  const preset = await db.apiPresets.filter(p => p.isActive).first();
  if(!preset || !preset.apiKey){
    toast(T('請先配置 API'), 'warning');
    return;
  }

  if(msgs.length < 2){
    toast(T('對話記錄太少，無法分析'), 'info');
    return;
  }

  showAiRangeSelector('🤖 AI 財產同步', (range) => doAiSyncInventory(range), 20);
}

async function doAiSyncInventory(range){
  showLoading('AI 正在分析對話中的財產變化...');

  try {
    const recentMsgs = msgs.slice(-range);
    const dialogContent = recentMsgs.map(m => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      return `${role} ${m.content}`;
    }).join('\n\n');

    console.log('[AI Inventory] 分析範圍:', range, '條消息');
    console.log('[AI Inventory] 對話內容長度:', dialogContent.length);

    const existingItems = (story.inventory || []).map(i => i.name).join('、') || '無';

    const prompt = `請仔細分析以下角色扮演對話內容，識別玩家角色擁有、獲得、使用或失去的任何物品和資產，包括：
- 金錢、貨幣
- 物品、道具、裝備
- 房產、車輛
- 貴重物品、珠寶
- 任何被提及的財物

現有財產：${existingItems}

對話內容：
${dialogContent}

請以 JSON 格式返回財產變化。

格式要求：
{
  "items": [
    {
      "action": "add" 或 "remove" 或 "update",
      "name": "資產名稱",
      "icon": "適合的emoji（如：💰💵🏠🏢🚗🏎️💎👑💍📱🎒🗡️）",
      "quantity": 數量或金額（數字，默認1）,
      "category": "money/property/vehicle/valuable/item/other",
      "location": "on_person/home/bank/warehouse/other_location",
      "description": "簡短描述（20字以內）"
    }
  ]
}

分類說明：
- money: 金錢、貨幣、現金
- property: 房產、土地、建築
- vehicle: 載具、車輛、交通工具
- valuable: 貴重物品、珠寶、藝術品
- item: 一般物品、道具、裝備
- other: 其他資產

存放位置說明：
- on_person: 身上攜帶
- home: 家中存放
- bank: 銀行保管
- warehouse: 倉庫存放
- other_location: 其他地點

重要規則：
1. 積極識別對話中提到的任何物品或財產，寧可多提取讓用戶篩選
2. 即使只是提及擁有某物也應該記錄
3. 不要重複添加已有財產（除非數量變化）
4. 只有在對話中完全沒有任何財產相關內容時，才返回 {"items":[]}`;

    const resp = await callAIForAnalysis(prompt, '你是一個專業的故事財產識別助手。你的任務是從角色扮演對話中提取所有物品、資產和財產變化。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式，不要添加任何額外文字。');
    const result = resp.content || '';

    console.log('[AI Inventory] 原始返回:', result);

    const jsonMatch = result.match(/\{[\s\S]*\}/);
    if(!jsonMatch){
      hideLoading();
      console.error('[AI Inventory] 無法找到 JSON 格式，原始返回:', result);
      toast(T('AI 未能識別到財產變化（返回格式錯誤）'), 'warning');
      return;
    }

    let parsed;
    try {
      parsed = JSON.parse(jsonMatch[0]);
      console.log('[AI Inventory] 解析成功:', parsed);
    } catch(e) {
      hideLoading();
      console.error('[AI Inventory] JSON 解析失敗:', e, '原始內容:', jsonMatch[0]);
      toast(T('AI 返回的數據格式錯誤'), 'error');
      return;
    }

    const items = parsed.items || [];

    if(!items.length){
      hideLoading();
      console.log('[AI Inventory] 沒有檢測到財產變化');
      toast(T('未發現新的財產變化'), 'info');
      return;
    }

    console.log('[AI Inventory] 檢測到', items.length, '個財產變化');

    // 檢測重複並標記
    let inventory = story.inventory || [];
    const existingNames = new Set(inventory.map(i => i.name.toLowerCase()));

    let totalNew = 0, totalDup = 0;
    items.forEach((item, i) => {
      item._id = 'inv_' + i;
      if(item.action === 'add'){
        item._isDuplicate = existingNames.has((item.name || '').toLowerCase());
        item._selected = !item._isDuplicate; // 默認選中非重複的新增項
        if(item._isDuplicate) totalDup++; else totalNew++;
      } else {
        // update 和 remove 操作默認選中
        item._selected = true;
        item._isDuplicate = false;
      }
    });

    // 保存結果供後續使用
    window._aiInventoryResult = { items, inventory: [...inventory] };
    
    hideLoading();
    
    // 構建預覽HTML
    let previewHtml = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding:8px;background:var(--bg-tertiary);border-radius:8px">
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:13px">
          <input type="checkbox" id="ai-inv-select-all" onchange="toggleAiInventorySelectAll(this.checked)" checked>
          全選非重複項
        </label>
        <div style="font-size:12px;color:var(--text-tertiary)">
          🆕 ${totalNew} 新增 · ⚠️ ${totalDup} 重複
        </div>
      </div>
    `;
    
    items.forEach(item => {
      let actionLabel, actionColor;
      if(item.action === 'add'){
        actionLabel = item._isDuplicate ? '⚠️ 已存在（將增加數量）' : '🆕 新增';
        actionColor = item._isDuplicate ? 'var(--warning)' : 'var(--success)';
      } else if(item.action === 'remove'){
        actionLabel = '🗑️ 移除';
        actionColor = 'var(--error)';
      } else {
        actionLabel = '✏️ 更新';
        actionColor = 'var(--info)';
      }
      
      previewHtml += `
        <div style="display:flex;align-items:flex-start;gap:8px;padding:10px;border:1px solid var(--divider);border-radius:8px;margin-bottom:6px;background:${item._isDuplicate ? 'rgba(245,158,11,0.05)' : 'var(--bg-secondary)'}">
          <input type="checkbox" data-id="${item._id}" ${item._selected ? 'checked' : ''} onchange="updateAiInventorySelection()" style="margin-top:4px">
          <span style="font-size:20px">${item.icon || '📦'}</span>
          <div style="flex:1;min-width:0">
            <div style="display:flex;align-items:center;gap:6px">
              <span style="font-size:13px;font-weight:500">${esc(item.name)}</span>
              <span style="font-size:11px;color:${actionColor}">${actionLabel}</span>
            </div>
            <div style="font-size:12px;color:var(--text-tertiary);margin-top:2px">
              數量: ${item.quantity || 1} · ${esc(item.description || '')}
            </div>
          </div>
        </div>
      `;
    });
    
    // 使用 ai-preview-modal 顯示
    document.getElementById('ai-preview-content').innerHTML = previewHtml;
    document.getElementById('ai-preview-title').textContent = '💰 財產變化預覽';
    document.getElementById('ai-preview-confirm-btn').onclick = applyInventoryChanges;
    showModal('ai-preview-modal');
    
  } catch(e) {
    hideLoading();
    console.error('AI sync inventory error:', e);
    toast('同步失敗: ' + e.message, 'error');
  }
}

// 全選/取消全選財產
function toggleAiInventorySelectAll(checked){
  const result = window._aiInventoryResult;
  if(!result) return;
  
  document.querySelectorAll('#ai-preview-content input[type="checkbox"][data-id]').forEach(cb => {
    const id = cb.dataset.id;
    const item = result.items.find(i => i._id === id);
    if(item){
      if(checked){
        cb.checked = !item._isDuplicate;
        item._selected = !item._isDuplicate;
      } else {
        cb.checked = false;
        item._selected = false;
      }
    }
  });
}

// 更新財產選擇狀態
function updateAiInventorySelection(){
  const result = window._aiInventoryResult;
  if(!result) return;
  
  document.querySelectorAll('#ai-preview-content input[type="checkbox"][data-id]').forEach(cb => {
    const id = cb.dataset.id;
    const item = result.items.find(i => i._id === id);
    if(item) item._selected = cb.checked;
  });
}

// 應用財產變化
async function applyInventoryChanges(){
  const result = window._aiInventoryResult;
  if(!result) return;
  
  let inventory = result.inventory;
  let addCount = 0, updateCount = 0, removeCount = 0;
  
  const selectedItems = result.items.filter(i => i._selected);
  
  for(const item of selectedItems){
    if(item.action === 'add'){
      const existing = inventory.find(i => i.name === item.name);
      if(existing){
        existing.quantity = (existing.quantity || 1) + (item.quantity || 1);
        existing.updatedAt = Date.now();
        updateCount++;
      } else {
        const newItem = {
          id: crypto.randomUUID(),
          name: item.name,
          icon: item.icon || '📦',
          quantity: item.quantity || 1,
          category: item.category || 'other',
          description: item.description || '',
          createdAt: Date.now()
        };
        await syncInventoryToLorebook(newItem);
        inventory.push(newItem);
        addCount++;
      }
    } else if(item.action === 'remove'){
      const idx = inventory.findIndex(i => i.name === item.name);
      if(idx >= 0){
        const existing = inventory[idx];
        if(item.quantity && existing.quantity > item.quantity){
          existing.quantity -= item.quantity;
          updateCount++;
        } else {
          if(existing.lorebookId){
            await db.lorebook.delete(existing.lorebookId);
          }
          inventory.splice(idx, 1);
          removeCount++;
        }
      }
    } else if(item.action === 'update'){
      const existing = inventory.find(i => i.name === item.name);
      if(existing){
        if(item.quantity) existing.quantity = item.quantity;
        if(item.description) existing.description = item.description;
        existing.updatedAt = Date.now();
        updateCount++;
      }
    }
  }
  
  story.inventory = inventory;
  await db.stories.update(story.id, { inventory });
  
  closeModal('ai-preview-modal');
  delete window._aiInventoryResult;
  
  renderInventory();
  
  const changes = [];
  if(addCount) changes.push(`新增 ${addCount} 個`);
  if(updateCount) changes.push(`更新 ${updateCount} 個`);
  if(removeCount) changes.push(`移除 ${removeCount} 個`);
  
  toast(`財產已同步：${changes.join('，') || '無變化'}`, 'success');
}

// ============ AI 分析範圍選擇器 ============
let _aiRangeCallback = null;
let _aiRangeTitle = '';

function showAiRangeSelector(title, callback, defaultValue = 20){
  _aiRangeCallback = callback;
  _aiRangeTitle = title;
  document.getElementById('ai-range-modal-title').textContent = title;
  document.getElementById('ai-range-slider').value = defaultValue;
  updateAiRangeLabel();
  showModal('ai-range-modal');
}

function updateAiRangeLabel(){
  const value = document.getElementById('ai-range-slider').value;
  document.getElementById('ai-range-label').textContent = value + ' 條';
}

function confirmAiRange(){
  const range = parseInt(document.getElementById('ai-range-slider').value) || 20;
  closeModal('ai-range-modal');
  if(_aiRangeCallback){
    _aiRangeCallback(range);
    _aiRangeCallback = null;
  }
}

// ============ 行程系統 ============
let editScheduleItemId = null;

// 計算兩個字串的相似度（Dice coefficient）
function stringSimilarity(s1, s2) {
  if(!s1 || !s2) return 0;
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();
  if(s1 === s2) return 1;
  if(s1.length < 2 || s2.length < 2) return 0;

  const getBigrams = str => {
    const bigrams = new Set();
    for(let i = 0; i < str.length - 1; i++) {
      bigrams.add(str.slice(i, i + 2));
    }
    return bigrams;
  };

  const bigrams1 = getBigrams(s1);
  const bigrams2 = getBigrams(s2);
  let intersection = 0;

  bigrams1.forEach(b => { if(bigrams2.has(b)) intersection++; });

  return (2 * intersection) / (bigrams1.size + bigrams2.size);
}

// 多條件匹配行程（返回最佳匹配項）
function findBestScheduleMatch(schedule, item, threshold = 1.5) {
  let best = null, bestScore = 0;

  for(const s of schedule) {
    let score = 0;

    // 事件名稱相似度（權重最高）
    const eventSim = stringSimilarity(s.event, item.event);
    score += eventSim * 3;

    // 時間匹配
    if(s.datetime && item.datetime) {
      if(s.datetime === item.datetime) {
        score += 1.5;
      } else if(s.datetime.includes(item.datetime) || item.datetime.includes(s.datetime)) {
        score += 0.8;
      }
    }

    // 地點匹配
    if(s.location && item.location) {
      const locSim = stringSimilarity(s.location, item.location);
      score += locSim * 1;
    }

    // 參與者匹配
    if(s.participants && item.participants) {
      const p1 = s.participants.split(/[,，、]/).map(p => p.trim().toLowerCase());
      const p2 = item.participants.split(/[,，、]/).map(p => p.trim().toLowerCase());
      const overlap = p1.filter(p => p2.some(p2i => p2i.includes(p) || p.includes(p2i))).length;
      const maxLen = Math.max(p1.length, p2.length);
      if(maxLen > 0) score += (overlap / maxLen) * 1;
    }

    if(score > bestScore) {
      bestScore = score;
      best = s;
    }
  }

  console.log('[Schedule Match] 最佳匹配分數:', bestScore, '閾值:', threshold, '匹配項:', best?.event);
  return bestScore >= threshold ? best : null;
}

// 渲染行程列表
async function renderSchedule(){
  if(!story) return;
  const container = document.getElementById('schedule-list');
  const schedule = story.schedule || [];

  if(!schedule.length){
    container.innerHTML = `<div class="empty" style="padding:40px 20px">
      <div class="empty-icon">📋</div>
      <div class="empty-title">行程清單是空的</div>
      <div class="empty-desc">點擊右上角 ➕ 手動添加行程，或點擊 🤖 讓 AI 從對話中智能識別</div>
    </div>`;
    return;
  }

  const searchTerm = (document.getElementById('schedule-search')?.value || '').toLowerCase();
  const statusFilter = document.getElementById('schedule-filter')?.value || 'all';

  let filtered = schedule.filter(item => {
    const matchSearch = !searchTerm ||
      item.event.toLowerCase().includes(searchTerm) ||
      (item.datetime || '').toLowerCase().includes(searchTerm) ||
      (item.location || '').toLowerCase().includes(searchTerm) ||
      (item.participants || '').toLowerCase().includes(searchTerm);
    const matchStatus = statusFilter === 'all' || item.status === statusFilter;
    return matchSearch && matchStatus;
  });

  // 按 timestamp 排序，没有 timestamp 的用 createdAt，都没有的排最后
  filtered.sort((a, b) => {
    const timeA = a.timestamp || a.createdAt || Infinity;
    const timeB = b.timestamp || b.createdAt || Infinity;
    return timeA - timeB;
  });

  if(!filtered.length){
    container.innerHTML = `<div class="empty" style="padding:40px 20px">
      <div class="empty-icon">🔍</div>
      <div class="empty-title">沒有匹配的行程</div>
    </div>`;
    return;
  }

  const statusIcons = { pending: '⏳', in_progress: '🔄', completed: '✅' };

  container.innerHTML = filtered.map(item => {
    const hasLorebook = item.lorebookId ? 'has-lorebook' : '';
    return `<div class="schedule-item ${item.status || 'pending'} ${hasLorebook}" data-id="${item.id}">
      <div class="schedule-item-actions">
        <button class="schedule-item-btn" onclick="editScheduleItem('${item.id}')">✏️</button>
        <button class="schedule-item-btn danger" onclick="deleteScheduleItem('${item.id}')">🗑️</button>
      </div>
      <div class="schedule-item-header">
        <span class="schedule-item-status">${statusIcons[item.status] || '⏳'}</span>
        <span class="schedule-item-datetime">${esc(item.datetime)}</span>
      </div>
      <div class="schedule-item-event">${esc(item.event)}</div>
      <div class="schedule-item-details">
        ${item.location ? `<span class="schedule-item-detail">📍 ${esc(item.location)}</span>` : ''}
        ${item.participants ? `<span class="schedule-item-detail">👥 ${esc(item.participants)}</span>` : ''}
      </div>
      ${item.notes ? `<div class="schedule-item-notes">${esc(item.notes)}</div>` : ''}
    </div>`;
  }).join('');
}

// 过滤行程
function filterSchedule(){
  renderSchedule();
}

// 添加行程
function addScheduleItem(){
  editScheduleItemId = null;
  document.getElementById('schedule-modal-title').textContent = '➕ 添加行程';
  document.getElementById('schedule-item-timestamp').value = '';
  document.getElementById('schedule-item-datetime').value = '';
  document.getElementById('schedule-item-event').value = '';
  document.getElementById('schedule-item-location').value = '';
  document.getElementById('schedule-item-participants').value = '';
  document.getElementById('schedule-item-status').value = 'pending';
  document.getElementById('schedule-item-notes').value = '';
  document.getElementById('schedule-item-lorebook').checked = true;
  showModal('schedule-item-modal');
}

// 编辑行程
function editScheduleItem(id){
  const schedule = story.schedule || [];
  const item = schedule.find(i => i.id === id);
  if(!item) return;

  editScheduleItemId = id;
  document.getElementById('schedule-modal-title').textContent = '✏️ 編輯行程';
  // 将 timestamp 转换为 datetime-local 格式（本地时间）
  if(item.timestamp){
    const d = new Date(item.timestamp);
    const local = new Date(d.getTime() - d.getTimezoneOffset() * 60000);
    document.getElementById('schedule-item-timestamp').value = local.toISOString().slice(0,16);
  } else {
    document.getElementById('schedule-item-timestamp').value = '';
  }
  document.getElementById('schedule-item-datetime').value = item.datetime || '';
  document.getElementById('schedule-item-event').value = item.event || '';
  document.getElementById('schedule-item-location').value = item.location || '';
  document.getElementById('schedule-item-participants').value = item.participants || '';
  document.getElementById('schedule-item-status').value = item.status || 'pending';
  document.getElementById('schedule-item-notes').value = item.notes || '';
  document.getElementById('schedule-item-lorebook').checked = !!item.lorebookId;
  showModal('schedule-item-modal');
}

// 保存行程
async function saveScheduleItem(){
  const datetime = document.getElementById('schedule-item-datetime').value.trim();
  const event = document.getElementById('schedule-item-event').value.trim();
  if(!datetime || !event){
    toast(T('請輸入日期時間和事件'),'warning');
    return;
  }

  const timestampInput = document.getElementById('schedule-item-timestamp').value;
  const timestamp = timestampInput ? new Date(timestampInput).getTime() : null;
  const location = document.getElementById('schedule-item-location').value.trim();
  const participants = document.getElementById('schedule-item-participants').value.trim();
  const status = document.getElementById('schedule-item-status').value;
  const notes = document.getElementById('schedule-item-notes').value.trim();
  const syncLorebook = document.getElementById('schedule-item-lorebook').checked;

  let schedule = story.schedule || [];
  let item;

  if(editScheduleItemId){
    const idx = schedule.findIndex(i => i.id === editScheduleItemId);
    if(idx >= 0){
      item = schedule[idx];
      item.timestamp = timestamp;
      item.datetime = datetime;
      item.event = event;
      item.location = location;
      item.participants = participants;
      item.status = status;
      item.notes = notes;
      item.updatedAt = Date.now();
    }
  } else {
    item = {
      id: crypto.randomUUID(),
      timestamp,
      datetime,
      event,
      location,
      participants,
      status,
      notes,
      createdAt: Date.now()
    };
    schedule.push(item);
  }

  if(syncLorebook && item){
    await syncScheduleToLorebook(item);
  } else if(!syncLorebook && item && item.lorebookId){
    await db.lorebook.delete(item.lorebookId);
    item.lorebookId = null;
  }

  story.schedule = schedule;
  await db.stories.update(story.id, { schedule });

  closeModal('schedule-item-modal');
  renderSchedule();
  toast(editScheduleItemId ? '行程已更新' : '行程已添加', 'success');
}

// 同步行程到Lorebook
async function syncScheduleToLorebook(item){
  const statusNames = { pending: '待辦', in_progress: '進行中', completed: '已完成' };
  const content = `【行程】${item.event}
時間：${item.datetime}
${item.location ? `地點：${item.location}\n` : ''}${item.participants ? `參與者：${item.participants}\n` : ''}狀態：${statusNames[item.status] || '待辦'}
${item.notes ? `備註：${item.notes}` : ''}`;

  if(item.lorebookId){
    await db.lorebook.update(item.lorebookId, {
      name: `📋 ${item.event}`,
      keywords: [item.event, item.datetime],
      content,
      updatedAt: Date.now()
    });
  } else {
    const lorebookId = crypto.randomUUID();
    await db.lorebook.put({
      id: lorebookId,
      storyId: story.id,
      name: `📋 ${item.event}`,
      keywords: [item.event, item.datetime],
      content,
      isEnabled: true,
      priority: 5,
      insertPosition: 'before',
      createdAt: Date.now()
    });
    item.lorebookId = lorebookId;
  }
}

// 删除行程
async function deleteScheduleItem(id){
  showConfirm('確定要刪除這個行程嗎？', async () => {
    let schedule = story.schedule || [];
    const item = schedule.find(i => i.id === id);

    if(item && item.lorebookId){
      await db.lorebook.delete(item.lorebookId);
    }

    schedule = schedule.filter(i => i.id !== id);
    story.schedule = schedule;
    await db.stories.update(story.id, { schedule });

    renderSchedule();
    toast(T('行程已刪除'), 'success');
  });
}

// AI智能同步行程
async function aiSyncSchedule(){
  if(!story) return;

  const preset = await db.apiPresets.filter(p => p.isActive).first();
  if(!preset || !preset.apiKey){
    toast(T('請先配置 API'), 'warning');
    return;
  }

  if(msgs.length < 2){
    toast(T('對話記錄太少，無法分析'), 'info');
    return;
  }

  showAiRangeSelector('🤖 AI 行程同步', (range) => doAiSyncSchedule(range), 20);
}

async function doAiSyncSchedule(range){
  showLoading('AI 正在分析對話中的行程安排...');

  try {
    const recentMsgs = msgs.slice(-range);
    const dialogContent = recentMsgs.map(m => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      return `${role} ${m.content}`;
    }).join('\n\n');

    console.log('[AI Schedule] 分析範圍:', range, '條消息');
    console.log('[AI Schedule] 對話內容長度:', dialogContent.length);

    const existingSchedule = (story.schedule || []).map(i => `${i.datetime}: ${i.event}`).join('、') || '無';

    const prompt = `請仔細分析以下角色扮演對話內容，識別任何提到的：
- 未來的計劃、約定、安排
- 需要做的事情、任務
- 約會、會面、聚會
- 工作、學習、活動安排
- 任何「之後要做」「打算」「計劃」「約好」的事

現有行程：${existingSchedule}

對話內容：
${dialogContent}

請以 JSON 格式返回發現的行程。你必須返回完整的 JSON 格式，不可中途停止。

格式要求：
{
  "items": [
    {
      "action": "add" 或 "update" 或 "complete",
      "datetime": "時間描述（如：之後、明天、下次見面時、故事中提到的任何時間點，若無明確時間可寫「待定」）",
      "event": "事件內容",
      "location": "地點（如有，無則留空）",
      "participants": "參與角色（用逗號分隔，如有）",
      "notes": "備註（如有）"
    }
  ]
}

action 說明：
- add: 新增行程
- update: 更新現有行程
- complete: 標記行程為已完成

重要規則：
1. 積極識別任何可能的計劃或安排，寧可多提取讓用戶篩選
2. 即使時間不明確，只要有「要做某事」的意圖就應該記錄
3. 不要重複添加已有行程（除非有更新）
4. 只有在對話中完全沒有任何計劃或安排時，才返回 {"items":[]}`;

    const resp = await callAIForAnalysis(prompt, '你是一個專業的故事行程識別助手。你的任務是從角色扮演對話中提取所有行程安排、計劃和約定。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式，不要添加任何額外文字。');
    const result = resp.content || '';

    console.log('[AI Schedule] 原始返回:', result);

    const jsonMatch = result.match(/\{[\s\S]*\}/);
    if(!jsonMatch){
      hideLoading();
      toast(T('AI 未能識別到行程變化（返回格式錯誤）'), 'warning');
      return;
    }

    let parsed;
    try {
      parsed = JSON.parse(jsonMatch[0]);
    } catch(e) {
      hideLoading();
      toast(T('AI 返回的數據格式錯誤'), 'error');
      return;
    }

    const items = parsed.items || [];

    if(!items.length){
      hideLoading();
      toast(T('未發現新的行程安排'), 'info');
      return;
    }

    console.log('[AI Schedule] 檢測到', items.length, '個行程變化');

    let schedule = story.schedule || [];
    let addCount = 0, updateCount = 0, completeCount = 0;

    for(const item of items){
      if(item.action === 'add'){
        // 檢查是否已存在相似行程，避免重複添加
        const duplicate = findBestScheduleMatch(schedule, item, 2.5);
        if(duplicate){
          console.log('[AI Schedule] 已存在相似行程，跳過添加:', item.event, '→', duplicate.event);
          continue;
        }
        const newItem = {
          id: crypto.randomUUID(),
          datetime: item.datetime,
          event: item.event,
          location: item.location || '',
          participants: item.participants || '',
          status: 'pending',
          notes: item.notes || '',
          createdAt: Date.now()
        };
        await syncScheduleToLorebook(newItem);
        schedule.push(newItem);
        addCount++;
      } else if(item.action === 'update'){
        const existing = findBestScheduleMatch(schedule, item);
        if(existing){
          if(item.datetime) existing.datetime = item.datetime;
          if(item.location) existing.location = item.location;
          if(item.participants) existing.participants = item.participants;
          if(item.notes) existing.notes = item.notes;
          existing.updatedAt = Date.now();
          await syncScheduleToLorebook(existing);
          updateCount++;
        } else {
          console.log('[AI Schedule] 未找到匹配項，跳過更新:', item.event);
        }
      } else if(item.action === 'complete'){
        const existing = findBestScheduleMatch(schedule, item);
        if(existing){
          existing.status = 'completed';
          existing.updatedAt = Date.now();
          await syncScheduleToLorebook(existing);
          completeCount++;
        } else {
          console.log('[AI Schedule] 未找到匹配項，跳過完成:', item.event);
        }
      }
    }

    story.schedule = schedule;
    await db.stories.update(story.id, { schedule });

    hideLoading();
    renderSchedule();

    const changes = [];
    if(addCount) changes.push(`新增 ${addCount} 個`);
    if(updateCount) changes.push(`更新 ${updateCount} 個`);
    if(completeCount) changes.push(`完成 ${completeCount} 個`);

    toast(`行程已同步：${changes.join('，') || '無變化'}`, 'success');

  } catch(e) {
    hideLoading();
    console.error('AI sync schedule error:', e);
    toast('同步失敗: ' + e.message, 'error');
  }
}

// ============ 場景管理系統 ============
let currentEditSceneId = null;

async function showSceneManager(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  closeAll();
  await renderSceneList();
  await updateCurrentSceneSelect();
  showModal('scene-modal');
}

async function renderSceneList(){
  const container = document.getElementById('scene-list');
  const scenes = await db.scenes.where('storyId').equals(story.id).toArray();
  
  if(!scenes.length){
    container.innerHTML = `<div style="text-align:center;padding:16px;color:var(--text-tertiary);font-size:13px">還沒有場景，點擊下方按鈕創建</div>`;
    document.getElementById('scene-detail-section').style.display = 'none';
    return;
  }
  
  let html = '';
  scenes.forEach(s => {
    const charCount = s.characterIds?.length || 0;
    html += `
      <div class="scene-item" style="display:flex;align-items:center;padding:10px;background:${s.isActive?'rgba(139,92,246,0.15)':'var(--bg-secondary)'};border-radius:8px;margin-bottom:6px;cursor:pointer" onclick="selectSceneForDetail('${s.id}')">
        <div style="flex:1;min-width:0">
          <div style="font-size:14px;font-weight:500;color:${s.isActive?'var(--primary)':'var(--text-primary)'}">${esc(s.name)} ${s.isActive?'✓':''}</div>
          <div style="font-size:11px;color:var(--text-tertiary)">${charCount} 位角色在場</div>
        </div>
        <div style="display:flex;gap:4px">
          <button class="icon-btn" style="padding:4px 8px;font-size:12px" onclick="event.stopPropagation();editScene('${s.id}')">✏️</button>
          <button class="icon-btn" style="padding:4px 8px;font-size:12px;color:var(--error)" onclick="event.stopPropagation();deleteScene('${s.id}')">🗑️</button>
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

async function updateCurrentSceneSelect(){
  const select = document.getElementById('current-scene');
  const scenes = await db.scenes.where('storyId').equals(story.id).toArray();
  
  let html = '<option value="">無場景（所有角色）</option>';
  scenes.forEach(s => {
    html += `<option value="${s.id}" ${s.isActive?'selected':''}>${esc(s.name)}</option>`;
  });
  select.innerHTML = html;
}

async function switchScene(sceneId){
  if(!story) return;
  
  // 清除所有場景的激活狀態
  const scenes = await db.scenes.where('storyId').equals(story.id).toArray();
  for(const s of scenes){
    if(s.isActive){
      s.isActive = false;
      await db.scenes.put(s);
    }
  }
  
  // 激活選中的場景
  if(sceneId){
    const scene = await db.scenes.get(sceneId);
    if(scene){
      scene.isActive = true;
      await db.scenes.put(scene);
      toast(`已切換到場景「${scene.name}」`,'success');
    }
  } else {
    toast(T('已切換為無場景模式'),'success');
  }
  
  await renderSceneList();
}

async function selectSceneForDetail(sceneId){
  const scene = await db.scenes.get(sceneId);
  if(!scene) return;
  
  const section = document.getElementById('scene-detail-section');
  section.style.display = 'block';
  
  const container = document.getElementById('scene-characters');
  const charIds = scene.characterIds || [];
  
  if(!charIds.length){
    container.innerHTML = `<div style="text-align:center;padding:12px;color:var(--text-tertiary);font-size:12px">此場景沒有角色</div>`;
    return;
  }
  
  let html = '';
  for(const cid of charIds){
    const char = await db.characters.get(cid);
    if(char){
      html += `
        <div style="display:flex;align-items:center;padding:8px;background:var(--bg-secondary);border-radius:6px;margin-bottom:4px">
          <span style="font-size:20px;margin-right:8px">${char.avatar||'👤'}</span>
          <span style="flex:1;font-size:13px">${esc(char.name)}</span>
          ${char.title?`<span style="font-size:11px;color:var(--text-tertiary)">${esc(char.title)}</span>`:''}
        </div>
      `;
    }
  }
  container.innerHTML = html;
}

async function createNewScene(){
  currentEditSceneId = null;
  document.getElementById('scene-edit-title').textContent = '創建場景';
  document.getElementById('scene-edit-id').value = '';
  document.getElementById('scene-edit-name').value = '';
  document.getElementById('scene-edit-desc').value = '';
  
  await renderSceneCharSelector([]);
  showModal('scene-edit-modal');
}

async function editScene(sceneId){
  const scene = await db.scenes.get(sceneId);
  if(!scene) return;
  
  currentEditSceneId = sceneId;
  document.getElementById('scene-edit-title').textContent = '編輯場景';
  document.getElementById('scene-edit-id').value = sceneId;
  document.getElementById('scene-edit-name').value = scene.name;
  document.getElementById('scene-edit-desc').value = scene.description || '';
  
  await renderSceneCharSelector(scene.characterIds || []);
  showModal('scene-edit-modal');
}

async function renderSceneCharSelector(selectedIds){
  const container = document.getElementById('scene-char-selector');
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  
  if(!chars.length){
    container.innerHTML = `<div style="text-align:center;padding:12px;color:var(--text-tertiary);font-size:12px">還沒有角色，請先添加角色</div>`;
    return;
  }
  
  let html = '';
  chars.forEach(c => {
    const checked = selectedIds.includes(c.id);
    html += `
      <label style="display:flex;align-items:center;padding:8px;cursor:pointer;border-radius:6px;margin-bottom:4px;background:${checked?'rgba(139,92,246,0.1)':'transparent'}">
        <input type="checkbox" class="scene-char-cb" value="${c.id}" ${checked?'checked':''} style="margin-right:10px;width:18px;height:18px">
        <span style="font-size:18px;margin-right:8px">${c.avatar||'👤'}</span>
        <span style="flex:1;font-size:13px">${esc(c.name)}</span>
        ${c.title?`<span style="font-size:11px;color:var(--text-tertiary)">${esc(c.title)}</span>`:''}
      </label>
    `;
  });
  container.innerHTML = html;
}

async function saveScene(){
  const name = document.getElementById('scene-edit-name').value.trim();
  if(!name){toast(T('請輸入場景名稱'),'warning');return;}
  
  const description = document.getElementById('scene-edit-desc').value.trim();
  const checkboxes = document.querySelectorAll('.scene-char-cb:checked');
  const characterIds = Array.from(checkboxes).map(cb => cb.value);
  
  const sceneId = document.getElementById('scene-edit-id').value || crypto.randomUUID();
  
  const scene = {
    id: sceneId,
    storyId: story.id,
    name,
    description,
    characterIds,
    isActive: false,
    createdAt: currentEditSceneId ? (await db.scenes.get(sceneId))?.createdAt || Date.now() : Date.now()
  };
  
  await db.scenes.put(scene);
  closeModal('scene-edit-modal');
  await renderSceneList();
  await updateCurrentSceneSelect();
  toast(currentEditSceneId ? '場景已更新' : '場景已創建', 'success');
}

async function deleteScene(sceneId){
  if(!confirm('確定刪除這個場景？')) return;
  await db.scenes.delete(sceneId);
  await renderSceneList();
  await updateCurrentSceneSelect();
  toast(T('場景已刪除'),'success');
}

// ============ 玩家面板系統 ============
let tempPlayerAttrs = [];

async function showPlayerPanel(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  closeAll();
  
  // 載入當前故事的面板配置
  currentPlayerPanel = await db.playerPanels.where('storyId').equals(story.id).first();
  
  renderPlayerPanelContent();
  showModal('player-panel-modal');
}

function renderPlayerPanelContent(){
  const container = document.getElementById('player-panel-content');
  const syncBtn = document.getElementById('player-sync-btn');
  
  if(!currentPlayerPanel || !currentPlayerPanel.attributes?.length){
    container.innerHTML = `
      <div style="text-align:center;padding:24px;color:var(--text-tertiary)">
        <div style="font-size:32px;margin-bottom:12px">📋</div>
        <div style="font-size:14px">還沒有設置狀態面板</div>
        <div style="font-size:12px;margin-top:4px">點擊下方「設置面板」創建</div>
      </div>
    `;
    if(syncBtn) syncBtn.style.display = 'none';
    return;
  }
  
  // 顯示AI同步按鈕
  if(syncBtn) syncBtn.style.display = 'flex';
  
  const p = currentPlayerPanel;
  
  // 按分組整理屬性
  const groupConfig = {
    'default': { icon: '📊', title: '屬性' },
    'stats': { icon: '💪', title: '基礎屬性' },
    'status': { icon: '❤️', title: '當前狀態' },
    'finance': { icon: '💰', title: '財務狀況' }
  };
  
  const groups = {};
  for(const attr of p.attributes){
    const groupKey = attr.group || 'default';
    if(!groups[groupKey]) groups[groupKey] = [];
    groups[groupKey].push(attr);
  }
  
  let html = `<div class="player-panel">`;
  html += `<div class="player-panel-header">`;
  html += `<div class="player-panel-title">📋 ${esc(p.name || '我的狀態')}</div>`;
  html += `</div>`;
  
  // 如果只有一個分組且為default，不顯示分組標題
  const groupKeys = Object.keys(groups);
  const showGroupHeaders = groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'default');
  
  for(const [groupKey, attrs] of Object.entries(groups)){
    const config = groupConfig[groupKey] || { icon: '✨', title: groupKey };
    
    html += `<div class="player-group">`;
    
    if(showGroupHeaders){
      html += `<div class="player-group-header">`;
      html += `<span class="player-group-icon">${config.icon}</span>`;
      html += `<span class="player-group-title">${esc(config.title)}</span>`;
      html += `<span class="player-group-toggle" onclick="togglePlayerGroup(this)">▼</span>`;
      html += `</div>`;
    }
    
    // 根據屬性數量決定網格列數
    const gridClass = attrs.length >= 6 ? 'grid-3' : '';
    html += `<div class="player-group-content"><div class="player-stat-grid ${gridClass}">`;
    
    for(const attr of attrs){
      const value = p.values?.[attr.name] ?? attr.defaultValue ?? 0;
      const colorClass = attr.color || 'default';
      
      html += `<div class="player-stat-item color-${colorClass}">`;
      html += `<div class="player-stat-label">${attr.icon || '📊'} ${esc(attr.name)}</div>`;
      
      if(attr.type === 'percent'){
        const max = attr.maxValue || 100;
        const percent = Math.min(100, Math.max(0, (value / max) * 100));
        const barColorClass = attr.name.includes('體力') || attr.name.includes('健康') || attr.name.includes('HP') ? 'health' : 
                             attr.name.includes('精神') || attr.name.includes('能量') || attr.name.includes('MP') ? 'energy' :
                             attr.name.includes('心情') || attr.name.includes('情緒') ? 'mood' : 'default';
        html += `<div class="player-stat-value">${value}<span class="unit">%</span></div>`;
        html += `<div class="player-stat-bar"><div class="player-stat-bar-fill ${barColorClass}" style="width:${percent}%"></div></div>`;
      } else if(attr.type === 'number'){
        const isNegative = typeof value === 'number' && value < 0;
        const isPositive = typeof value === 'number' && value > 0 && (attr.name.includes('現金') || attr.name.includes('金錢') || attr.name.includes('餘額'));
        const unit = attr.unit || '';
        html += `<div class="player-stat-value ${isNegative ? 'negative' : ''} ${isPositive ? 'positive' : ''}">${typeof value === 'number' ? value.toLocaleString() : value}${unit ? `<span class="unit">${esc(unit)}</span>` : ''}</div>`;
      } else {
        // 文字類型使用標籤樣式
        html += `<div class="player-stat-tag">${esc(String(value))}</div>`;
      }
      
      html += `</div>`;
    }
    
    html += `</div></div></div>`;
  }
  
  html += `</div>`;
  container.innerHTML = html;
}

// 切換分組展開/收起
function togglePlayerGroup(el){
  el.classList.toggle('collapsed');
  const content = el.closest('.player-group').querySelector('.player-group-content');
  if(content){
    if(content.classList.contains('collapsed')){
      content.style.maxHeight = content.scrollHeight + 'px';
      content.classList.remove('collapsed');
    } else {
      content.style.maxHeight = content.scrollHeight + 'px';
      requestAnimationFrame(() => {
        content.classList.add('collapsed');
      });
    }
  }
}

async function showPlayerPanelSetup(){
  closeModal('player-panel-modal');
  
  // 載入現有配置
  if(currentPlayerPanel){
    document.getElementById('player-panel-name').value = currentPlayerPanel.name || '';
    tempPlayerAttrs = [...(currentPlayerPanel.attributes || [])];
  } else {
    document.getElementById('player-panel-name').value = '';
    tempPlayerAttrs = [];
  }
  
  renderPlayerAttrList();
  showModal('player-panel-setup-modal');
}

function renderPlayerAttrList(){
  const container = document.getElementById('player-attr-list');
  
  if(!tempPlayerAttrs.length){
    container.innerHTML = `<div style="text-align:center;padding:16px;color:var(--text-tertiary);font-size:13px">還沒有屬性，點擊添加</div>`;
    return;
  }
  
  const groupConfig = {
    'default': { icon: '📊', title: '預設' },
    'stats': { icon: '💪', title: '基礎屬性' },
    'status': { icon: '❤️', title: '當前狀態' },
    'finance': { icon: '💰', title: '財務' }
  };
  
  let html = '';
  tempPlayerAttrs.forEach((attr, i) => {
    const typeLabel = attr.type === 'percent' ? '百分比' : attr.type === 'number' ? '數字' : '文字';
    const groupInfo = groupConfig[attr.group] || { icon: '✨', title: attr.group || '預設' };
    const colorStyle = attr.color && attr.color !== 'default' ? `border-left-color:${getColorHex(attr.color)}` : '';
    html += `
      <div class="player-attr-card" style="${colorStyle}">
        <div class="player-attr-icon">${attr.icon || '📊'}</div>
        <div class="player-attr-info">
          <div class="player-attr-name">${esc(attr.name)}</div>
          <div class="player-attr-type">${typeLabel} · 初始值: ${attr.defaultValue ?? 0}</div>
          <div class="player-attr-group">${groupInfo.icon} ${groupInfo.title}</div>
        </div>
        <button class="icon-btn" style="padding:4px 8px;font-size:12px" onclick="editPlayerAttribute(${i})">✏️</button>
        <button class="icon-btn" style="padding:4px 8px;font-size:12px;color:var(--error)" onclick="deletePlayerAttribute(${i})">🗑️</button>
      </div>
    `;
  });
  container.innerHTML = html;
}

function getColorHex(color){
  const colors = {
    'red': '#EF4444',
    'orange': '#F59E0B',
    'yellow': '#EAB308',
    'green': '#10B981',
    'blue': '#3B82F6',
    'purple': '#8B5CF6',
    'pink': '#EC4899'
  };
  return colors[color] || 'var(--primary)';
}

function selectAttrGroup(el){
  document.querySelectorAll('#player-attr-group-selector .group-chip').forEach(c => c.classList.remove('active'));
  el.classList.add('active');
  const group = el.dataset.group;
  document.getElementById('player-attr-group').value = group;
  document.getElementById('player-attr-custom-group').style.display = group === 'custom' ? 'block' : 'none';
}

function selectAttrColor(el){
  el.parentElement.querySelectorAll('.group-chip').forEach(c => c.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('player-attr-color').value = el.dataset.color;
}

function addPlayerAttribute(){
  document.getElementById('player-attr-modal-title').textContent = '➕ 添加屬性';
  document.getElementById('player-attr-edit-index').value = '-1';
  document.getElementById('player-attr-name').value = '';
  document.getElementById('player-attr-icon').value = '';
  document.getElementById('player-attr-type').value = 'number';
  document.getElementById('player-attr-default').value = '0';
  document.getElementById('player-attr-max').value = '100';
  document.getElementById('player-attr-keywords').value = '';
  // 重置分組選擇
  document.getElementById('player-attr-group').value = 'default';
  document.querySelectorAll('#player-attr-group-selector .group-chip').forEach(c => c.classList.remove('active'));
  document.querySelector('#player-attr-group-selector .group-chip[data-group="default"]')?.classList.add('active');
  document.getElementById('player-attr-custom-group').style.display = 'none';
  document.getElementById('player-attr-custom-group-name').value = '';
  // 重置顏色選擇
  document.getElementById('player-attr-color').value = 'default';
  document.querySelectorAll('#player-attr-modal .group-chip[data-color]').forEach(c => c.classList.remove('active'));
  document.querySelector('#player-attr-modal .group-chip[data-color="default"]')?.classList.add('active');
  updatePlayerAttrTypeUI();
  showModal('player-attr-modal');
}

function editPlayerAttribute(index){
  const attr = tempPlayerAttrs[index];
  if(!attr) return;
  
  document.getElementById('player-attr-modal-title').textContent = '✏️ 編輯屬性';
  document.getElementById('player-attr-edit-index').value = index;
  document.getElementById('player-attr-name').value = attr.name || '';
  document.getElementById('player-attr-icon').value = attr.icon || '';
  document.getElementById('player-attr-type').value = attr.type || 'number';
  document.getElementById('player-attr-default').value = attr.defaultValue ?? '0';
  document.getElementById('player-attr-max').value = attr.maxValue || 100;
  document.getElementById('player-attr-keywords').value = (attr.keywords || []).join(', ');
  // 設置分組
  const group = attr.group || 'default';
  document.getElementById('player-attr-group').value = group;
  document.querySelectorAll('#player-attr-group-selector .group-chip').forEach(c => c.classList.remove('active'));
  const groupChip = document.querySelector(`#player-attr-group-selector .group-chip[data-group="${group}"]`);
  if(groupChip){
    groupChip.classList.add('active');
    document.getElementById('player-attr-custom-group').style.display = 'none';
  } else {
    // 自定義分組
    document.querySelector('#player-attr-group-selector .group-chip[data-group="custom"]')?.classList.add('active');
    document.getElementById('player-attr-custom-group').style.display = 'block';
    document.getElementById('player-attr-custom-group-name').value = group;
  }
  // 設置顏色
  const color = attr.color || 'default';
  document.getElementById('player-attr-color').value = color;
  document.querySelectorAll('#player-attr-modal .group-chip[data-color]').forEach(c => c.classList.remove('active'));
  document.querySelector(`#player-attr-modal .group-chip[data-color="${color}"]`)?.classList.add('active');
  updatePlayerAttrTypeUI();
  showModal('player-attr-modal');
}

function deletePlayerAttribute(index){
  if(!confirm('確定刪除這個屬性？')) return;
  tempPlayerAttrs.splice(index, 1);
  renderPlayerAttrList();
}

function updatePlayerAttrTypeUI(){
  const type = document.getElementById('player-attr-type').value;
  const maxGroup = document.getElementById('player-attr-max-group');
  maxGroup.style.display = type === 'percent' ? 'block' : 'none';
}

function savePlayerAttribute(){
  const name = document.getElementById('player-attr-name').value.trim();
  if(!name){toast(T('請輸入屬性名稱'),'warning');return;}
  
  // 獲取分組
  let group = document.getElementById('player-attr-group').value;
  if(group === 'custom'){
    group = document.getElementById('player-attr-custom-group-name').value.trim() || 'default';
  }
  
  const attr = {
    name,
    icon: document.getElementById('player-attr-icon').value.trim() || '📊',
    type: document.getElementById('player-attr-type').value,
    defaultValue: document.getElementById('player-attr-type').value === 'text' 
      ? document.getElementById('player-attr-default').value 
      : parseFloat(document.getElementById('player-attr-default').value) || 0,
    maxValue: parseInt(document.getElementById('player-attr-max').value) || 100,
    keywords: document.getElementById('player-attr-keywords').value.split(',').map(k => k.trim()).filter(k => k),
    group: group,
    color: document.getElementById('player-attr-color').value || 'default'
  };
  
  const editIndex = parseInt(document.getElementById('player-attr-edit-index').value);
  if(editIndex >= 0){
    tempPlayerAttrs[editIndex] = attr;
  } else {
    tempPlayerAttrs.push(attr);
  }
  
  closeModal('player-attr-modal');
  renderPlayerAttrList();
}

async function savePlayerPanelSetup(){
  const name = document.getElementById('player-panel-name').value.trim() || '我的狀態';
  
  // 保留現有數值
  const existingValues = currentPlayerPanel?.values || {};
  const newValues = {};
  tempPlayerAttrs.forEach(attr => {
    newValues[attr.name] = existingValues[attr.name] ?? attr.defaultValue ?? 0;
  });
  
  const panel = {
    id: currentPlayerPanel?.id || crypto.randomUUID(),
    storyId: story.id,
    name,
    attributes: tempPlayerAttrs,
    values: newValues,
    createdAt: currentPlayerPanel?.createdAt || Date.now(),
    updatedAt: Date.now()
  };
  
  await db.playerPanels.put(panel);
  currentPlayerPanel = panel;
  
  closeModal('player-panel-setup-modal');
  toast(T('面板設置已保存'),'success');
  showPlayerPanel();
}

function manualUpdatePlayerPanel(){
  if(!currentPlayerPanel?.attributes?.length){
    toast(T('請先設置面板屬性'),'warning');
    return;
  }
  
  const container = document.getElementById('player-update-fields');
  let html = '';
  
  for(const attr of currentPlayerPanel.attributes){
    const value = currentPlayerPanel.values?.[attr.name] ?? attr.defaultValue ?? 0;
    html += `
      <div class="form-group">
        <label class="form-label">${attr.icon || '📊'} ${esc(attr.name)}</label>
        <input type="${attr.type === 'text' ? 'text' : 'number'}" class="form-input" 
          data-attr-name="${esc(attr.name)}" value="${esc(String(value))}"
          ${attr.type === 'percent' ? `min="0" max="${attr.maxValue || 100}"` : ''}>
      </div>
    `;
  }
  
  container.innerHTML = html;
  closeModal('player-panel-modal');
  showModal('player-update-modal');
}

async function savePlayerUpdate(){
  if(!currentPlayerPanel) return;
  
  const inputs = document.querySelectorAll('#player-update-fields input[data-attr-name]');
  const newValues = {...currentPlayerPanel.values};
  
  inputs.forEach(input => {
    const attrName = input.dataset.attrName;
    const attr = currentPlayerPanel.attributes.find(a => a.name === attrName);
    if(attr){
      newValues[attrName] = attr.type === 'text' ? input.value : parseFloat(input.value) || 0;
    }
  });
  
  currentPlayerPanel.values = newValues;
  currentPlayerPanel.updatedAt = Date.now();
  await db.playerPanels.put(currentPlayerPanel);
  
  closeModal('player-update-modal');
  toast(T('狀態已更新'),'success');
  showPlayerPanel();
}

async function aiGeneratePlayerPanel(){
  showLoading('🤖 AI 正在分析設定並生成屬性...\n這可能需要 30-120 秒');

  try {
    // 收集故事信息
    let context = '';
    if(story.systemPrompt){
      context += '【System Prompt】\n' + story.systemPrompt.slice(0, 3000) + '\n\n';
    }
    
    const lorebooks = await db.lorebook.where('storyId').equals(story.id).limit(5).toArray();
    if(lorebooks.length){
      context += '【Lorebook 條目】\n';
      lorebooks.forEach(l => {
        context += `- ${l.name}: ${l.content?.slice(0, 200)}...\n`;
      });
    }
    
    const response = await callAI(`你是一個文游屬性設計專家。根據以下設定，推薦適合追蹤的玩家屬性（5-10個），並按分組整理。

${context}

請用 JSON 格式返回，每個屬性包含：
- name: 屬性名稱
- icon: emoji 圖標
- type: "number"（數字）、"percent"（百分比 0-100）或 "text"（文字）
- defaultValue: 初始值
- keywords: 用於自動解析的關鍵詞數組
- group: 分組名稱（stats=基礎屬性, status=當前狀態, finance=財務, 或其他自定義分組名）
- color: 顏色（red/orange/green/blue/purple/pink/default）

範例：
\`\`\`json
[
  {"name": "魅力", "icon": "✨", "type": "number", "defaultValue": 50, "keywords": ["魅力"], "group": "stats", "color": "pink"},
  {"name": "體力", "icon": "❤️", "type": "percent", "defaultValue": 100, "keywords": ["體力", "HP"], "group": "status", "color": "red"},
  {"name": "現金", "icon": "💰", "type": "number", "defaultValue": 1000, "keywords": ["現金", "餘額"], "group": "finance", "color": "green"},
  {"name": "職位", "icon": "👔", "type": "text", "defaultValue": "新人", "keywords": ["職位", "職級"], "group": "status", "color": "blue"}
]
\`\`\`

只返回 JSON，不要其他內容。`);
    
    const match = response.content.match(/```json\s*([\s\S]*?)\s*```/) || response.content.match(/\[\s*\{[\s\S]*\}\s*\]/);
    if(match){
      const attrs = JSON.parse(match[1] || match[0]);
      if(Array.isArray(attrs) && attrs.length){
        const generatedAttrs = attrs.map(a => ({
          name: a.name || '未命名',
          icon: a.icon || '📊',
          type: ['number', 'percent', 'text'].includes(a.type) ? a.type : 'number',
          defaultValue: a.defaultValue ?? 0,
          maxValue: 100,
          keywords: Array.isArray(a.keywords) ? a.keywords : [],
          group: a.group || 'default',
          color: a.color || 'default'
        }));

        // 关闭玩家面板设置modal
        closeModal('player-panel-setup-modal');

        hideLoading();

        // 显示确认框
        showConfirm(
          `AI 已生成 ${generatedAttrs.length} 個屬性建議，是否應用？\n\n` +
          generatedAttrs.map(a => `${a.icon} ${a.name}`).join(', '),
          () => {
            // 确认：应用生成的属性
            tempPlayerAttrs = generatedAttrs;
            // 重新打开modal并渲染列表
            showModal('player-panel-setup-modal');
            renderPlayerAttrList();
            toast(`已應用 ${tempPlayerAttrs.length} 個屬性`,'success');
          },
          false,
          '🤖 AI 生成結果'
        );
      }
    } else {
      hideLoading();
      toast(T('AI 返回格式錯誤'),'error');
    }
  } catch(e){
    hideLoading();
    toast('生成失敗: ' + e.message,'error');
  }
}

// AI 智能同步 - 從對話中解析數值變化
async function aiSyncPlayerStatus(){
  if(!currentPlayerPanel?.attributes?.length){
    toast(T('請先設置面板屬性'),'warning');
    return;
  }

  showAiRangeSelector('🤖 AI 狀態同步', (range) => doAiSyncPlayerStatus(range), 20);
}

async function doAiSyncPlayerStatus(range){
  const btn = document.getElementById('player-sync-btn');
  btn.disabled = true;
  btn.innerHTML = '⏳ AI 正在分析對話...';

  // 顯示進度提示
  showLoading('🤖 AI 正在分析對話中的數值變化...\n這可能需要 30-300 秒');

  try {
    // 獲取最近的對話記錄
    const messages = await db.messages.where('storyId').equals(story.id).reverse().limit(range).toArray();
    if(!messages.length){
      hideLoading();
      toast(T('沒有對話記錄可分析'),'warning');
      btn.disabled = false;
      btn.innerHTML = '🤖 AI 智能同步（從對話中解析數值變化）';
      return;
    }

    const recentContent = messages.reverse().map(m => `[${m.role}]: ${m.content}`).join('\n\n');
    
    // 構建當前屬性信息
    const attrInfo = currentPlayerPanel.attributes.map(a => {
      const currentValue = currentPlayerPanel.values?.[a.name] ?? a.defaultValue;
      return `- ${a.icon} ${a.name} (${a.type}): 當前值=${currentValue}, 關鍵詞=[${[a.name, ...(a.keywords||[])].join(',')}]`;
    }).join('\n');
    
    const response = await callAIForAnalysis(`請根據以下對話內容，分析玩家屬性的變化。

【當前追蹤的屬性】
${attrInfo}

【最近的對話內容】
${recentContent.slice(-4000)}

請分析對話中提到的數值變化，返回 JSON 格式：
\`\`\`json
{
  "changes": [
    {"name": "屬性名稱", "newValue": 新數值或文字, "reason": "變化原因"}
  ],
  "summary": "簡短的變化摘要"
}
\`\`\`

注意：
1. 只返回有變化的屬性
2. 數字類型返回數字，百分比類型返回0-100的數字，文字類型返回字符串
3. 如果沒有發現任何變化，返回空的 changes 數組
4. 積極識別對話中隱含的數值變化，寧可多提取讓用戶篩選`, '你是一個專業的文字遊戲數值解析專家。你的任務是從角色扮演對話中精確識別玩家屬性的數值變化。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。');
    
    const match = response.content.match(/```json\s*([\s\S]*?)\s*```/) || response.content.match(/\{[\s\S]*\}/);
    if(match){
      const result = JSON.parse(match[1] || match[0]);
      
      if(result.changes?.length){
        // 標記每個變化項
        result.changes.forEach((change, i) => {
          change._id = 'change_' + i;
          change._selected = true; // 默認全選
        });
        
        // 構建帶選擇框的預覽HTML
        let changeHtml = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding:8px;background:var(--bg-tertiary);border-radius:8px">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:13px">
              <input type="checkbox" id="ai-player-select-all" onchange="toggleAiPlayerSelectAll(this.checked)" checked>
              全選
            </label>
            <div style="font-size:12px;color:var(--text-tertiary)">
              共 ${result.changes.length} 項變化
            </div>
          </div>
        `;
        changeHtml += `<div style="margin-bottom:12px;color:var(--text-tertiary);font-size:12px">${esc(result.summary || '')}</div>`;
        changeHtml += '<div style="max-height:280px;overflow-y:auto">';
        
        for(const change of result.changes){
          const attr = currentPlayerPanel.attributes.find(a => a.name === change.name);
          if(attr){
            const oldValue = currentPlayerPanel.values?.[change.name] ?? attr.defaultValue;
            const isIncrease = typeof change.newValue === 'number' && typeof oldValue === 'number' && change.newValue > oldValue;
            const isDecrease = typeof change.newValue === 'number' && typeof oldValue === 'number' && change.newValue < oldValue;
            changeHtml += `
              <div style="display:flex;align-items:flex-start;gap:8px;padding:10px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:8px">
                <input type="checkbox" data-id="${change._id}" checked onchange="updateAiPlayerSelection()" style="margin-top:4px">
                <div style="flex:1">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
                    <span>${attr.icon}</span>
                    <span style="font-weight:500">${esc(change.name)}</span>
                  </div>
                  <div style="display:flex;align-items:center;gap:8px;font-size:14px">
                    <span style="color:var(--text-tertiary)">${oldValue}</span>
                    <span style="color:${isIncrease ? 'var(--success)' : isDecrease ? 'var(--error)' : 'var(--text-primary)'}">→ ${change.newValue}</span>
                  </div>
                  <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px">${esc(change.reason || '')}</div>
                </div>
              </div>
            `;
          }
        }
        changeHtml += '</div>';
        
        // 使用臨時變量保存變化
        window._pendingPlayerChanges = result.changes;
        
        document.getElementById('ai-preview-content').innerHTML = changeHtml;
        document.getElementById('ai-preview-title').textContent = '📊 屬性變化預覽';
        document.getElementById('ai-preview-confirm-btn').onclick = applyPlayerChanges;
        hideLoading();
        showModal('ai-preview-modal');
      } else {
        hideLoading();
        toast(T('未發現屬性變化'),'info');
      }
    } else {
      hideLoading();
      toast(T('AI 返回格式錯誤'),'error');
    }
  } catch(e){
    hideLoading();
    toast('同步失敗: ' + e.message,'error');
  } finally {
    btn.disabled = false;
    btn.innerHTML = '🤖 AI 智能同步（從對話中解析數值變化）';
  }
}

// 全選/取消全選玩家屬性變化
function toggleAiPlayerSelectAll(checked){
  const changes = window._pendingPlayerChanges;
  if(!changes) return;
  
  document.querySelectorAll('#ai-preview-content input[type="checkbox"][data-id]').forEach(cb => {
    cb.checked = checked;
    const id = cb.dataset.id;
    const change = changes.find(c => c._id === id);
    if(change) change._selected = checked;
  });
}

// 更新玩家屬性選擇狀態
function updateAiPlayerSelection(){
  const changes = window._pendingPlayerChanges;
  if(!changes) return;
  
  document.querySelectorAll('#ai-preview-content input[type="checkbox"][data-id]').forEach(cb => {
    const id = cb.dataset.id;
    const change = changes.find(c => c._id === id);
    if(change) change._selected = cb.checked;
  });
}

// 應用屬性變化（只應用選中的）
async function applyPlayerChanges(){
  const changes = window._pendingPlayerChanges;
  if(!changes?.length || !currentPlayerPanel) return;
  
  const selectedChanges = changes.filter(c => c._selected);
  if(!selectedChanges.length){
    toast(T('請至少選擇一項變化'), 'warning');
    return;
  }
  
  const newValues = {...currentPlayerPanel.values};
  
  for(const change of selectedChanges){
    const attr = currentPlayerPanel.attributes.find(a => a.name === change.name);
    if(attr){
      newValues[change.name] = change.newValue;
    }
  }
  
  currentPlayerPanel.values = newValues;
  currentPlayerPanel.updatedAt = Date.now();
  await db.playerPanels.put(currentPlayerPanel);
  
  closeModal('ai-preview-modal');
  toast(`已更新 ${selectedChanges.length} 個屬性`,'success');
  renderPlayerPanelContent();
  
  delete window._pendingPlayerChanges;
}

// 自動解析 AI 回覆中的玩家狀態更新
async function parsePlayerStatusFromAI(content){
  if(!story) return;
  
  const panel = await db.playerPanels.where('storyId').equals(story.id).first();
  if(!panel?.attributes?.length) return;
  
  let updated = false;
  const newValues = {...panel.values};
  
  for(const attr of panel.attributes){
    // 構建關鍵詞正則
    const keywords = [attr.name, ...(attr.keywords || [])];
    for(const kw of keywords){
      // 匹配各種格式：「現金：1000」「現金: 1000」「💰 1000」「現金 → 1000」
      const patterns = [
        new RegExp(`${kw}[：:\\s→]+([\\d,.-]+)`, 'i'),
        new RegExp(`${attr.icon}\\s*[：:\\s→]*([\\d,.-]+)`, 'i'),
        new RegExp(`${kw}[：:\\s→]+([^\\d]*?)([\\d,.-]+)`, 'i')
      ];
      
      for(const pattern of patterns){
        const match = content.match(pattern);
        if(match){
          let value = match[1] || match[2];
          value = value.replace(/,/g, '');
          
          if(attr.type === 'text'){
            newValues[attr.name] = value;
          } else {
            const num = parseFloat(value);
            if(!isNaN(num)){
              newValues[attr.name] = num;
              updated = true;
              break;
            }
          }
        }
      }
    }
  }
  
  if(updated){
    panel.values = newValues;
    panel.updatedAt = Date.now();
    await db.playerPanels.put(panel);
  }
}

// ============ AI 生成 Lorebook ============
function showAiLorebookModal(){
  if(!story){toast(T('請先選擇故事'),'warning');return;}
  if(!msgs || msgs.length === 0){
    toast(T('當前故事還沒有對話記錄，無法提取Lorebook'),'warning');
    return;
  }
  document.getElementById('ai-lorebook-preview').style.display = 'none';
  document.getElementById('ai-lorebook-range').value = 20;
  updateLorebookRangeDisplay(20);
  showModal('ai-lorebook-modal');
}

function updateLorebookRangeDisplay(value){
  document.getElementById('ai-lorebook-range-display').textContent = `最近 ${value} 條對話消息`;
}

async function generateAiLorebook(){
  // 獲取分析範圍
  const rangeValue = parseInt(document.getElementById('ai-lorebook-range').value) || 20;

  // 從最近的對話中收集內容
  if(!msgs || msgs.length === 0){
    toast(T('當前故事還沒有對話記錄'),'warning');
    return;
  }

  // 收集最近N條消息
  const recentMsgs = msgs.slice(-rangeValue);
  const dialogueContent = recentMsgs.map((m, idx) => {
    const role = m.role === 'user' ? '【玩家】' : '【劇情】';
    return `${role} ${m.content}`;
  }).join('\n\n');

  if(dialogueContent.length < 50){
    toast(T('對話內容太少，無法提取有效信息'),'warning');
    return;
  }

  const extractChars = document.getElementById('ai-lorebook-chars').checked;
  const extractPlayer = document.getElementById('ai-lorebook-player').checked;

  const btn = document.getElementById('ai-lorebook-generate-btn');
  btn.textContent = '⏳ 提取中...';
  btn.disabled = true;

  // 顯示進度提示
  showLoading('🤖 AI 正在分析對話內容...\n這可能需要 30-120 秒，請耐心等待');

  try {
    const response = await callAIForAnalysis(`請從以下對話劇情中提取關鍵信息，生成結構化的 Lorebook 條目。

【最近 ${rangeValue} 條對話內容】
${dialogueContent}

【提取要求】
1. **關鍵詞設計**：為每個條目設定 2-5 個觸發關鍵詞，包括：
   - 名稱本身（角色名、地點名、物品名等）
   - 相關的別稱、稱呼
   - 特徵詞（如：銀髮少女、神秘組織、魔法劍等）

2. **提取類型**：
   - 角色：姓名、身份、性格特徵、外貌特徵、能力
   - 地點：名稱、位置、特徵、重要性
   - 物品：名稱、類型、用途、特殊屬性
   - 事件：重要的劇情轉折、衝突、秘密
   - 設定：世界觀、規則、組織、系統

3. **內容要求**：
   - 每個條目簡潔明確，50-200字
   - 聚焦核心信息，去除多餘描述
   - 只提取對話中明確提到的信息，不要腦補

4. ${extractChars ? '識別出所有角色，標記 isCharacter: true，包含完整的角色信息' : '不需要特別標記角色'}
5. ${extractPlayer ? '識別出玩家/主角需要追蹤的屬性（如：生命值、體力、好感度等），標記為 playerAttributes' : '不需要提取玩家屬性'}

請用 JSON 格式返回：
\`\`\`json
{
  "entries": [
    {
      "name": "條目名稱",
      "keywords": ["關鍵詞1", "關鍵詞2"],
      "content": "條目內容...",
      "isCharacter": false
    }
  ],
  "characters": [
    {
      "name": "角色名",
      "title": "頭銜/身份",
      "avatar": "emoji",
      "description": "角色描述",
      "personality": "性格"
    }
  ],
  "playerAttributes": [
    {
      "name": "屬性名",
      "icon": "emoji",
      "type": "number/percent/text",
      "defaultValue": 0,
      "keywords": ["關鍵詞"]
    }
  ]
}
\`\`\``, '你是一個專業的 Lorebook 提取專家。你的任務是從角色扮演對話中提取關鍵的世界觀設定、角色、地點、物品和事件信息。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。');
    
    const match = response.content.match(/```json\s*([\s\S]*?)\s*```/) || response.content.match(/\{[\s\S]*"entries"[\s\S]*\}/);
    if(!match) throw new Error('AI 返回格式錯誤');
    
    const result = JSON.parse(match[1] || match[0]);
    
    // 檢測重複 - 獲取現有數據
    const existingLorebook = await db.lorebook.where('storyId').equals(story.id).toArray();
    const existingChars = await db.characters.where('storyId').equals(story.id).toArray();
    let existingPanel = await db.playerPanels.where('storyId').equals(story.id).first();

    // 使用相似度匹配找到最相似的現有條目
    function findSimilarLorebook(name, threshold = 0.6) {
      if(!name) return null;
      let best = null, bestScore = threshold;
      for(const l of existingLorebook) {
        // 完全匹配
        if((l.name || '').trim().toLowerCase() === name.trim().toLowerCase()) {
          return { entry: l, score: 1, isExact: true };
        }
        // 相似度匹配
        const score = stringSimilarity(l.name || '', name);
        if(score > bestScore) {
          bestScore = score;
          best = l;
        }
      }
      return best ? { entry: best, score: bestScore, isExact: false } : null;
    }

    function findSimilarChar(name, threshold = 0.6) {
      if(!name) return null;
      let best = null, bestScore = threshold;
      for(const c of existingChars) {
        if((c.name || '').trim().toLowerCase() === name.trim().toLowerCase()) {
          return { entry: c, score: 1, isExact: true };
        }
        const score = stringSimilarity(c.name || '', name);
        if(score > bestScore) {
          bestScore = score;
          best = c;
        }
      }
      return best ? { entry: best, score: bestScore, isExact: false } : null;
    }

    const existingAttrNames = new Set((existingPanel?.attributes || []).map(a => (a.name || '').trim().toLowerCase()));

    // 標記重複項
    let totalNew = 0, totalDup = 0, totalSimilar = 0;

    if(result.entries?.length){
      result.entries.forEach((e, i) => {
        e._id = 'entry_' + i;
        const similar = findSimilarLorebook(e.name);
        if(similar) {
          e._isDuplicate = true;
          e._isExactMatch = similar.isExact;
          e._similarTo = similar.entry;
          e._similarScore = similar.score;
          e._action = 'merge'; // 默認改為合併
          if(similar.isExact) totalDup++; else totalSimilar++;
        } else {
          e._isDuplicate = false;
          e._action = 'add';
          totalNew++;
        }
        e._selected = true;
      });
    }

    if(result.characters?.length){
      result.characters.forEach((c, i) => {
        c._id = 'char_' + i;
        const similar = findSimilarChar(c.name);
        if(similar) {
          c._isDuplicate = true;
          c._isExactMatch = similar.isExact;
          c._similarTo = similar.entry;
          c._similarScore = similar.score;
          c._action = 'merge';
          if(similar.isExact) totalDup++; else totalSimilar++;
        } else {
          c._isDuplicate = false;
          c._action = 'add';
          totalNew++;
        }
        c._selected = true;
      });
    }

    if(result.playerAttributes?.length){
      result.playerAttributes.forEach((a, i) => {
        a._id = 'attr_' + i;
        a._isDuplicate = existingAttrNames.has((a.name || '').trim().toLowerCase());
        a._selected = true;
        a._action = a._isDuplicate ? 'skip' : 'add';
        if(a._isDuplicate) totalDup++; else totalNew++;
      });
    }

    // 保存結果供後續使用
    window._aiLorebookResult = result;

    // 構建預覽HTML（帶選擇框）
    let previewHtml = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding:8px;background:var(--bg-tertiary);border-radius:8px">
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:13px">
          <input type="checkbox" id="ai-lb-select-all" onchange="toggleAiLorebookSelectAll(this.checked)" checked>
          全選
        </label>
        <div style="font-size:12px;color:var(--text-tertiary)">
          🆕 ${totalNew} 新增 · 🔗 ${totalSimilar} 相似 · ⚠️ ${totalDup} 重複
        </div>
      </div>
    `;
    
    if(result.entries?.length){
      previewHtml += `<div style="margin-bottom:8px;font-weight:600;font-size:13px">📚 Lorebook 條目 (${result.entries.length})</div>`;
      result.entries.forEach(e => {
        let dupTag, actionSelect;
        if(e._isDuplicate) {
          const similarName = e._similarTo?.name || '';
          const scorePercent = Math.round((e._similarScore || 0) * 100);
          if(e._isExactMatch) {
            dupTag = `<span style="color:var(--warning);font-size:11px;margin-left:6px">⚠️ 完全相同</span>`;
          } else {
            dupTag = `<span style="color:var(--primary);font-size:11px;margin-left:6px">🔗 相似 ${scorePercent}%「${esc(similarName)}」</span>`;
          }
          actionSelect = `
            <select data-type="entry" data-id="${e._id}" onchange="updateAiLorebookAction(this, 'entry', '${e._id}')" style="padding:2px 6px;font-size:11px;border:1px solid var(--divider);border-radius:4px;background:var(--bg-primary)">
              <option value="merge" selected>合併</option>
              <option value="replace">覆蓋</option>
              <option value="rename">另存新增</option>
              <option value="skip">跳過</option>
            </select>
          `;
        } else {
          dupTag = '<span style="color:var(--success);font-size:11px;margin-left:6px">🆕 新增</span>';
          actionSelect = '';
        }
        previewHtml += `
          <div style="display:flex;align-items:flex-start;gap:8px;padding:8px;border:1px solid var(--divider);border-radius:6px;margin-bottom:6px;background:${e._isDuplicate ? 'rgba(139,124,247,0.05)' : 'var(--bg-secondary)'}">
            <input type="checkbox" data-type="entry" data-id="${e._id}" ${e._selected ? 'checked' : ''} onchange="updateAiLorebookSelection()" style="margin-top:2px">
            <div style="flex:1;min-width:0">
              <div style="display:flex;align-items:center;gap:8px;margin-bottom:2px;flex-wrap:wrap">
                <div style="font-size:13px;font-weight:500">${esc(e.name)}${dupTag}</div>
                ${actionSelect}
              </div>
              <div style="font-size:11px;color:var(--text-tertiary)">關鍵詞: ${(e.keywords || []).slice(0,3).join(', ')}${(e.keywords?.length > 3) ? '...' : ''}</div>
            </div>
          </div>`;
      });
    }

    if(result.characters?.length){
      previewHtml += `<div style="margin:12px 0 8px;font-weight:600;font-size:13px">👥 角色 (${result.characters.length})</div>`;
      result.characters.forEach(c => {
        let dupTag, actionSelect;
        if(c._isDuplicate) {
          const similarName = c._similarTo?.name || '';
          const scorePercent = Math.round((c._similarScore || 0) * 100);
          if(c._isExactMatch) {
            dupTag = `<span style="color:var(--warning);font-size:11px;margin-left:6px">⚠️ 完全相同</span>`;
          } else {
            dupTag = `<span style="color:var(--primary);font-size:11px;margin-left:6px">🔗 相似 ${scorePercent}%「${esc(similarName)}」</span>`;
          }
          actionSelect = `
            <select data-type="char" data-id="${c._id}" onchange="updateAiLorebookAction(this, 'char', '${c._id}')" style="padding:2px 6px;font-size:11px;border:1px solid var(--divider);border-radius:4px;background:var(--bg-primary);margin-left:auto">
              <option value="merge" selected>合併</option>
              <option value="replace">覆蓋</option>
              <option value="rename">另存新增</option>
              <option value="skip">跳過</option>
            </select>
          `;
        } else {
          dupTag = '<span style="color:var(--success);font-size:11px;margin-left:6px">🆕 新增</span>';
          actionSelect = '';
        }
        previewHtml += `
          <div style="display:flex;align-items:center;gap:8px;padding:8px;border:1px solid var(--divider);border-radius:6px;margin-bottom:6px;background:${c._isDuplicate ? 'rgba(139,124,247,0.05)' : 'var(--bg-secondary)'}">
            <input type="checkbox" data-type="char" data-id="${c._id}" ${c._selected ? 'checked' : ''} onchange="updateAiLorebookSelection()">
            <span style="font-size:18px">${c.avatar || '👤'}</span>
            <div style="flex:1">
              <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                <div style="font-size:13px;font-weight:500">${esc(c.name)}${dupTag}</div>
                ${actionSelect}
              </div>
              <div style="font-size:11px;color:var(--text-tertiary)">${esc(c.title || '')}</div>
            </div>
          </div>`;
      });
    }
    
    if(result.playerAttributes?.length){
      previewHtml += `<div style="margin:12px 0 8px;font-weight:600;font-size:13px">📋 玩家屬性 (${result.playerAttributes.length})</div>`;
      result.playerAttributes.forEach(a => {
        const dupTag = a._isDuplicate ? '<span style="color:var(--warning);font-size:11px;margin-left:6px">⚠️ 已存在</span>' : '<span style="color:var(--success);font-size:11px;margin-left:6px">🆕 新增</span>';
        const actionSelect = a._isDuplicate ? `
          <select data-type="attr" data-id="${a._id}" onchange="updateAiLorebookAction(this, 'attr', '${a._id}')" style="padding:2px 6px;font-size:11px;border:1px solid var(--divider);border-radius:4px;background:var(--bg-primary);margin-left:auto">
            <option value="rename" selected>重命名</option>
            <option value="replace">覆蓋</option>
            <option value="skip">跳過</option>
          </select>
        ` : '';
        previewHtml += `
          <div style="display:flex;align-items:center;gap:8px;padding:8px;border:1px solid var(--divider);border-radius:6px;margin-bottom:6px;background:${a._isDuplicate ? 'rgba(245,158,11,0.05)' : 'var(--bg-secondary)'}">
            ${a._isDuplicate ? '' : `<input type="checkbox" data-type="attr" data-id="${a._id}" ${a._selected ? 'checked' : ''} onchange="updateAiLorebookSelection()">`}
            <span style="font-size:16px">${a.icon || '📊'}</span>
            <div style="flex:1">
              <div style="display:flex;align-items:center;gap:8px">
                <div style="font-size:13px;font-weight:500">${esc(a.name)}${dupTag}</div>
                ${actionSelect}
              </div>
            </div>
          </div>`;
      });
    }
    
    document.getElementById('ai-lorebook-preview-content').innerHTML = previewHtml;
    document.getElementById('ai-lorebook-preview').style.display = 'block';

    // 隱藏進度提示
    hideLoading();

    // 更改按鈕為確認導入
    btn.textContent = '✅ 導入選中項';
    btn.onclick = async () => {
      await importAiLorebookResult();
    };
    btn.disabled = false;
    
  } catch(e){
    hideLoading();
    toast('提取失敗: ' + e.message,'error');
    btn.textContent = '🤖 開始提取';
    btn.disabled = false;
  }
}

// 更新操作選擇（重命名/覆蓋/跳過）
function updateAiLorebookAction(selectEl, type, id){
  const result = window._aiLorebookResult;
  if(!result) return;

  const action = selectEl.value;
  let item;

  if(type === 'entry') item = result.entries?.find(e => e._id === id);
  else if(type === 'char') item = result.characters?.find(c => c._id === id);
  else if(type === 'attr') item = result.playerAttributes?.find(a => a._id === id);

  if(item){
    item._action = action;
    // 如果選擇"跳過"，自動取消選中
    item._selected = action !== 'skip';
  }
}

// 全選/取消全選
function toggleAiLorebookSelectAll(checked){
  const result = window._aiLorebookResult;
  if(!result) return;

  document.querySelectorAll('#ai-lorebook-preview-content input[type="checkbox"][data-type]').forEach(cb => {
    const type = cb.dataset.type;
    const id = cb.dataset.id;
    let item;
    if(type === 'entry') item = result.entries?.find(e => e._id === id);
    else if(type === 'char') item = result.characters?.find(c => c._id === id);
    else if(type === 'attr') item = result.playerAttributes?.find(a => a._id === id);

    if(item){
      cb.checked = checked;
      item._selected = checked;
    }
  });
  updateAiLorebookSelection();
}

// 更新選擇狀態
function updateAiLorebookSelection(){
  const result = window._aiLorebookResult;
  if(!result) return;
  
  document.querySelectorAll('#ai-lorebook-preview-content input[type="checkbox"][data-type]').forEach(cb => {
    const type = cb.dataset.type;
    const id = cb.dataset.id;
    if(type === 'entry'){
      const item = result.entries?.find(e => e._id === id);
      if(item) item._selected = cb.checked;
    } else if(type === 'char'){
      const item = result.characters?.find(c => c._id === id);
      if(item) item._selected = cb.checked;
    } else if(type === 'attr'){
      const item = result.playerAttributes?.find(a => a._id === id);
      if(item) item._selected = cb.checked;
    }
  });
}

async function importAiLorebookResult(){
  const result = window._aiLorebookResult;
  if(!result) return;
  let counts = { entries: 0, characters: 0, attributes: 0, replaced: 0, renamed: 0, merged: 0 };

  // 獲取現有數據以支持覆蓋功能
  const existingLorebook = await db.lorebook.where('storyId').equals(story.id).toArray();
  const existingChars = await db.characters.where('storyId').equals(story.id).toArray();

  // 導入 Lorebook 條目
  const selectedEntries = result.entries?.filter(e => e._selected) || [];
  if(selectedEntries.length){
    for(const e of selectedEntries){
      let name = e.name || '未命名';

      if(e._action === 'merge'){
        // 合併：找到相似條目並追加內容
        const target = e._similarTo;
        if(target){
          // 合併關鍵詞（去重）
          const existingKeywords = target.keywords || [];
          const newKeywords = e.keywords || [];
          const mergedKeywords = [...new Set([...existingKeywords, ...newKeywords])];

          // 合併內容（追加新內容，避免重複）
          const existingContent = (target.content || '').trim();
          const newContent = (e.content || '').trim();
          let mergedContent = existingContent;
          if(newContent && !existingContent.includes(newContent)) {
            mergedContent = existingContent + '\n\n---\n\n' + newContent;
          }

          await db.lorebook.update(target.id, {
            keywords: mergedKeywords,
            content: mergedContent,
            updatedAt: Date.now()
          });
          counts.merged++;
        }
      } else if(e._action === 'replace'){
        // 覆蓋：找到相似條目並完全替換內容
        const target = e._similarTo || existingLorebook.find(l => l.name.toLowerCase() === name.toLowerCase());
        if(target){
          await db.lorebook.update(target.id, {
            keywords: e.keywords || [name],
            content: e.content || '',
            updatedAt: Date.now()
          });
          counts.replaced++;
        }
      } else if(e._action === 'rename'){
        // 重命名：添加數字後綴
        let counter = 2;
        let newName = name;
        while(existingLorebook.some(l => l.name.toLowerCase() === newName.toLowerCase())){
          newName = `${name} (${counter})`;
          counter++;
        }
        await db.lorebook.put({
          id: crypto.randomUUID(),
          storyId: story.id,
          name: newName,
          keywords: e.keywords || [name],
          content: e.content || '',
          depth: 2,
          priority: 100,
          cooldown: 0,
          maxTriggers: 0,
          oneTime: false,
          conditions: [],
          conditionLogic: 'AND',
          isEnabled: true,
          triggerCount: 0,
          lastTriggered: null,
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
        counts.renamed++;
      } else if(e._action === 'add'){
        // 新增
        await db.lorebook.put({
          id: crypto.randomUUID(),
          storyId: story.id,
          name,
          keywords: e.keywords || [name],
          content: e.content || '',
          depth: 2,
          priority: 100,
          cooldown: 0,
          maxTriggers: 0,
          oneTime: false,
          conditions: [],
          conditionLogic: 'AND',
          isEnabled: true,
          triggerCount: 0,
          lastTriggered: null,
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
        counts.entries++;
      }
      // skip: 不做任何事
    }
  }
  
  // 導入角色
  const selectedChars = result.characters?.filter(c => c._selected) || [];
  if(selectedChars.length){
    for(const c of selectedChars){
      let name = c.name || '未命名';

      if(c._action === 'merge'){
        // 合併：找到相似角色並追加描述
        const target = c._similarTo;
        if(target){
          // 合併描述（追加新內容）
          const existingDesc = (target.description || '').trim();
          const newDesc = (c.description || '').trim();
          let mergedDesc = existingDesc;
          if(newDesc && !existingDesc.includes(newDesc)) {
            mergedDesc = existingDesc + '\n\n' + newDesc;
          }

          // 合併性格
          const existingPersonality = (target.personality || '').trim();
          const newPersonality = (c.personality || '').trim();
          let mergedPersonality = existingPersonality;
          if(newPersonality && !existingPersonality.includes(newPersonality)) {
            mergedPersonality = existingPersonality + '；' + newPersonality;
          }

          await db.characters.update(target.id, {
            title: c.title || target.title,
            description: mergedDesc,
            personality: mergedPersonality,
            updatedAt: Date.now()
          });
          counts.merged++;
        }
      } else if(c._action === 'replace'){
        // 覆蓋：找到相似角色並完全替換
        const target = c._similarTo || existingChars.find(ch => ch.name.toLowerCase() === name.toLowerCase());
        if(target){
          await db.characters.update(target.id, {
            title: c.title || '',
            avatar: c.avatar || '👤',
            description: c.description || '',
            personality: c.personality || '',
            updatedAt: Date.now()
          });
          counts.replaced++;
        }
      } else if(c._action === 'rename'){
        // 重命名：添加數字後綴
        let counter = 2;
        let newName = name;
        while(existingChars.some(ch => ch.name.toLowerCase() === newName.toLowerCase())){
          newName = `${name} (${counter})`;
          counter++;
        }
        await db.characters.put({
          id: crypto.randomUUID(),
          storyId: story.id,
          name: newName,
          title: c.title || '',
          avatar: c.avatar || '👤',
          description: c.description || '',
          personality: c.personality || '',
          stats: {},
          tags: [],
          relations: [],
          mood: '',
          note: '',
          location: '',
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
        counts.renamed++;
      } else if(c._action === 'add'){
        // 新增
        await db.characters.put({
          id: crypto.randomUUID(),
          storyId: story.id,
          name,
          title: c.title || '',
          avatar: c.avatar || '👤',
          description: c.description || '',
          personality: c.personality || '',
          stats: {},
          tags: [],
          relations: [],
          mood: '',
          note: '',
          location: '',
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
        counts.characters++;
      }
      // skip: 不做任何事
    }
  }
  
  // 導入玩家屬性
  const selectedAttrs = result.playerAttributes?.filter(a => a._selected) || [];
  if(selectedAttrs.length){
    let panel = await db.playerPanels.where('storyId').equals(story.id).first();

    if(!panel){
      // 如果沒有面板，創建新面板
      const newAttrs = selectedAttrs.map(a => ({
        name: a.name || '未命名',
        icon: a.icon || '📊',
        type: ['number', 'percent', 'text'].includes(a.type) ? a.type : 'number',
        defaultValue: a.defaultValue ?? 0,
        maxValue: 100,
        keywords: a.keywords || [],
        group: a.group || 'default',
        color: a.color || 'default'
      }));
      const values = {};
      newAttrs.forEach(a => values[a.name] = a.defaultValue);
      panel = {
        id: crypto.randomUUID(),
        storyId: story.id,
        name: '我的狀態',
        attributes: newAttrs,
        values,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      await db.playerPanels.put(panel);
      counts.attributes = newAttrs.length;
    } else {
      // 有面板，根據操作處理每個屬性
      const existingAttrNames = (panel.attributes || []).map(a => a.name.toLowerCase());

      for(const a of selectedAttrs){
        let name = a.name || '未命名';

        if(a._action === 'replace'){
          // 覆蓋：找到同名屬性並更新
          const existing = panel.attributes.find(attr => attr.name.toLowerCase() === name.toLowerCase());
          if(existing){
            existing.icon = a.icon || '📊';
            existing.type = ['number', 'percent', 'text'].includes(a.type) ? a.type : 'number';
            existing.defaultValue = a.defaultValue ?? 0;
            existing.keywords = a.keywords || [];
            existing.group = a.group || 'default';
            existing.color = a.color || 'default';
            counts.replaced++;
          }
        } else if(a._action === 'rename'){
          // 重命名：添加數字後綴
          let counter = 2;
          let newName = name;
          while(panel.attributes.some(attr => attr.name.toLowerCase() === newName.toLowerCase())){
            newName = `${name} (${counter})`;
            counter++;
          }
          const newAttr = {
            name: newName,
            icon: a.icon || '📊',
            type: ['number', 'percent', 'text'].includes(a.type) ? a.type : 'number',
            defaultValue: a.defaultValue ?? 0,
            maxValue: 100,
            keywords: a.keywords || [],
            group: a.group || 'default',
            color: a.color || 'default'
          };
          panel.attributes.push(newAttr);
          panel.values[newName] = newAttr.defaultValue;
          counts.renamed++;
        } else if(a._action === 'add'){
          // 新增
          const newAttr = {
            name,
            icon: a.icon || '📊',
            type: ['number', 'percent', 'text'].includes(a.type) ? a.type : 'number',
            defaultValue: a.defaultValue ?? 0,
            maxValue: 100,
            keywords: a.keywords || [],
            group: a.group || 'default',
            color: a.color || 'default'
          };
          panel.attributes.push(newAttr);
          panel.values[name] = newAttr.defaultValue;
          counts.attributes++;
        }
        // skip: 不做任何事
      }

      panel.updatedAt = Date.now();
      await db.playerPanels.put(panel);
    }
  }
  
  // 清理臨時數據
  delete window._aiLorebookResult;
  
  closeModal('ai-lorebook-modal');
  
  // 重置按鈕狀態
  const btn = document.getElementById('ai-lorebook-generate-btn');
  btn.textContent = '🤖 開始提取';
  btn.onclick = generateAiLorebook;
  document.getElementById('ai-lorebook-preview').style.display = 'none';

  let msg = T('導入完成！');
  const totalNew = counts.entries + counts.characters + counts.attributes;
  if(totalNew > 0) msg += ` ${totalNew} 個新增`;
  if(counts.merged > 0) msg += ` ${counts.merged} 個合併`;
  if(counts.replaced > 0) msg += ` ${counts.replaced} 個覆蓋`;
  if(counts.renamed > 0) msg += ` ${counts.renamed} 個另存`;

  toast(msg, 'success');
  renderLorebook();
}

// 獲取當前場景的角色信息（用於 System Prompt）
async function getActiveScenePrompt(){
  if(!story) return '';
  
  const activeScene = await db.scenes.where('storyId').equals(story.id).filter(s => s.isActive).first();
  if(!activeScene || !activeScene.characterIds?.length) return '';
  
  let prompt = `\n\n### 當前場景：${activeScene.name}\n`;
  if(activeScene.description){
    prompt += `${activeScene.description}\n\n`;
  }
  prompt += `在場角色：\n`;
  
  for(const cid of activeScene.characterIds){
    const char = await db.characters.get(cid);
    if(char){
      prompt += `- **${char.name}**`;
      if(char.title) prompt += `（${char.title}）`;
      if(char.mood) prompt += ` [當前情緒：${char.mood}]`;
      prompt += '\n';
    }
  }
  
  prompt += `\n請讓這些在場的角色根據各自的性格和關係進行互動，可以有對話、動作、表情等。\n`;
  
  return prompt;
}

// 顯示角色詳情
async function showCharDetail(charId){
  currentCharacterId = charId;
  const char = await db.characters.get(charId);
  if(!char){toast(T('角色不存在'),'error');return;}
  
  document.getElementById('char-detail-title').textContent = char.name + ' 詳情';
  
  // 分類標籤
  const categoryLabels = {
    'protagonist': '⭐ 主角',
    'supporting': '👤 配角',
    'npc': '👥 NPC'
  };
  const categoryLabel = categoryLabels[char.category] || '👤 配角';
  
  let html = `
    <div style="text-align:center;margin-bottom:16px">
      <div style="width:64px;height:64px;border-radius:16px;background:linear-gradient(135deg,var(--primary),var(--primary-light));display:inline-flex;align-items:center;justify-content:center;font-size:32px;background-size:cover;background-position:center;overflow:hidden">${char.avatarImage ? `<img src="${char.avatarImage}" style="width:100%;height:100%;object-fit:cover">` : (char.avatar||'👤')}</div>
      <div style="font-size:18px;font-weight:600;margin-top:8px">${esc(char.name)}</div>
      ${char.title?`<div style="font-size:13px;color:var(--text-secondary)">${esc(char.title)}</div>`:''}
      <div style="font-size:11px;color:var(--primary);margin-top:4px">${categoryLabel}</div>
    </div>
  `;
  
  // 性格
  if(char.personality){
    html += `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:4px">🎭 性格</div>`;
    html += `<div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px;padding:10px;background:var(--bg-tertiary);border-radius:8px">${esc(char.personality)}</div>`;
  }
  
  // 描述
  if(char.description){
    html += `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:4px">📝 描述</div>`;
    html += `<div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px;padding:10px;background:var(--bg-tertiary);border-radius:8px;max-height:120px;overflow-y:auto">${esc(char.description)}</div>`;
  }
  
  // 屬性
  if(char.stats && Object.keys(char.stats).length){
    html += `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">📊 屬性</div>`;
    html += `<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">`;
    for(const [k,v] of Object.entries(char.stats)){
      html += `<div style="background:var(--bg-tertiary);padding:8px;border-radius:6px;font-size:13px"><span style="color:var(--text-secondary)">${esc(k)}:</span> <strong>${esc(String(v))}</strong></div>`;
    }
    html += `</div>`;
  }
  
  // 標籤
  if(char.tags && char.tags.length){
    html += `<div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px">${char.tags.map(t=>`<span style="font-size:11px;padding:4px 8px;background:var(--bg-tertiary);border-radius:8px">${esc(t)}</span>`).join('')}</div>`;
  }
  
  // v25: 關係信息
  if(char.relationships && char.relationships.length){
    html += `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">👥 關係</div>`;
    html += `<div style="display:flex;flex-direction:column;gap:6px;margin-bottom:12px">`;
    char.relationships.forEach(rel => {
      const typeInfo = RELATIONSHIP_TYPES.find(t => t.code === rel.type);
      const icon = typeInfo ? typeInfo.icon : '🔗';
      const color = typeInfo ? typeInfo.color : '#888';
      html += `
        <div style="background:var(--bg-tertiary);padding:8px 10px;border-radius:6px;font-size:13px;display:flex;align-items:center;gap:8px">
          <span style="font-size:14px">${icon}</span>
          <span style="color:var(--text-secondary)">${esc(rel.targetName || '未知角色')}</span>
          <span style="color:${color};font-weight:500">${esc(rel.label || rel.type)}</span>
          ${rel.mutual ? '<span style="font-size:10px;color:var(--text-tertiary)">↔️</span>' : ''}
        </div>
      `;
    });
    html += `</div>`;
  }
  
  // v25: 表情預覽
  if(char.expressions && char.expressions.length){
    html += `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px">🎨 表情（${char.expressionMode === 'auto' ? 'AI自動切換' : '手動切換'}）</div>`;
    html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px">`;
    char.expressions.forEach(expr => {
      const isDefault = expr.isDefault ? 'border:2px solid var(--success);' : '';
      html += `
        <div style="text-align:center">
          <img src="${expr.image}" style="width:50px;height:50px;border-radius:8px;object-fit:cover;${isDefault}">
          <div style="font-size:10px;color:var(--text-secondary);margin-top:2px">${esc(expr.name)}</div>
        </div>
      `;
    });
    html += `</div>`;
  }

  // v26: 見面記錄
  html += `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:8px;display:flex;justify-content:space-between;align-items:center">
    <span>📝 見面記錄</span>
    <div style="display:flex;gap:6px">
      <button onclick="aiExtractMeetings('${charId}')" style="font-size:11px;padding:2px 8px;border-radius:4px;background:var(--primary);color:white;border:none;cursor:pointer">🤖 AI提取</button>
      <button onclick="addMeeting('${charId}')" style="font-size:11px;padding:2px 8px;border-radius:4px;background:var(--bg-tertiary);border:1px solid var(--divider);cursor:pointer">➕</button>
    </div>
  </div>`;
  const meetings = char.meetings || [];
  if(meetings.length){
    html += `<div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px;max-height:200px;overflow-y:auto">`;
    meetings.slice().reverse().forEach((m, idx) => {
      const realIdx = meetings.length - 1 - idx;
      html += `
        <div style="background:var(--bg-tertiary);padding:10px;border-radius:8px;font-size:12px;position:relative">
          <div style="position:absolute;top:6px;right:6px;display:flex;gap:4px">
            <span onclick="editMeeting('${charId}',${realIdx})" style="cursor:pointer;opacity:0.6;font-size:11px">✏️</span>
            <span onclick="deleteMeeting('${charId}',${realIdx})" style="cursor:pointer;opacity:0.6;font-size:11px">🗑️</span>
          </div>
          <div style="color:var(--text-tertiary);font-size:11px;margin-bottom:4px">📅 ${esc(m.time || '未知時間')}</div>
          <div style="color:var(--text-primary);margin-bottom:4px">${esc(m.summary)}</div>
          ${m.location ? `<div style="color:var(--text-secondary);font-size:11px">📍 ${esc(m.location)}</div>` : ''}
        </div>
      `;
    });
    html += `</div>`;
  } else {
    html += `<div style="text-align:center;padding:16px;color:var(--text-tertiary);font-size:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:12px">暫無見面記錄<br><span style="font-size:11px">點擊 🤖 AI提取 或 ➕ 手動添加</span></div>`;
  }

  // V2 字段摘要（如果有）
  let v2Features = [];
  if(char.first_mes) v2Features.push('開場白');
  if(char.alternate_greetings?.length) v2Features.push(`${char.alternate_greetings.length}個替代開場白`);
  if(char.mes_example) v2Features.push('對話示例');
  if(char.system_prompt) v2Features.push('專屬系統提示');
  if(char.character_book?.entries?.length) v2Features.push(`${char.character_book.entries.length}個Lorebook條目`);
  if(char.relationships?.length) v2Features.push(`${char.relationships.length}個關係`);
  if(char.expressions?.length) v2Features.push(`${char.expressions.length}個表情`);
  
  if(v2Features.length){
    html += `<div style="font-size:11px;color:var(--primary);background:rgba(139,124,247,.1);padding:8px 10px;border-radius:6px;margin-bottom:12px">✨ 包含：${v2Features.join('、')}</div>`;
  }
  
  // 創作者信息
  if(char.creator || char.character_version){
    html += `<div style="font-size:11px;color:var(--text-tertiary);margin-bottom:4px">`;
    if(char.creator) html += `創作者: ${esc(char.creator)} `;
    if(char.character_version) html += `v${esc(char.character_version)}`;
    html += `</div>`;
  }
  
  html += `<div style="font-size:11px;color:var(--text-tertiary);text-align:right">更新於 ${fmtDate(char.updatedAt)}</div>`;
  
  document.getElementById('char-detail-content').innerHTML = html;
  showModal('char-detail-modal');
}

// 編輯角色（跳轉到添加頁面並填充數據）
async function editCharacter(){
  try {
    if(!currentCharacterId) {
      return;
    }
    const char = await db.characters.get(currentCharacterId);
    if(!char) {
      toast(T('找不到角色數據'), 'error');
      return;
    }
    
    // 只關閉詳情模態框，不移除overlay
    document.getElementById('char-detail-modal').classList.remove('active');
    
    // 設置編輯模式
    editingCharacterId = currentCharacterId;
    
    // 安全設置值的輔助函數
    const setVal = (id, val) => {
      const el = document.getElementById(id);
      if(el) el.value = val;
    };
    
    // 填充基本信息
    setVal('char-add-name', char.name || '');
    setVal('char-add-title', char.title || '');
    setVal('char-add-avatar', char.avatar || '');
    setVal('char-add-category', char.category || 'supporting');
    setVal('char-add-desc', char.description || '');
    setVal('char-add-personality', char.personality || '');
    setVal('char-add-tags', (char.tags || []).join(', '));
    
    // 處理頭像圖片
    tempCharAvatarImage = null; // 重置臨時圖片
    const avatarPreview = document.getElementById('char-avatar-preview');
    const avatarImg = document.getElementById('char-avatar-img');
    if(char.avatarImage && avatarPreview && avatarImg) {
      avatarPreview.style.display = 'block';
      avatarImg.src = char.avatarImage;
      tempCharAvatarImage = char.avatarImage; // 保留原圖片
    } else if(avatarPreview) {
      avatarPreview.style.display = 'none';
    };
    
    // 填充對話設置
    setVal('char-add-firstmes', char.first_mes || '');
    setVal('char-add-scenario', char.scenario || '');
    setVal('char-add-example', char.mes_example || '');
    
    // 替代開場白
    charAltGreetings = char.alternate_greetings || [];
    renderAltGreetings();
    
    // 填充高級設置
    setVal('char-add-sysprompt', char.system_prompt || '');
    setVal('char-add-posthistory', char.post_history_instructions || '');
    setVal('char-add-creatornotes', char.creator_notes || '');
    setVal('char-add-creator', char.creator || '');
    setVal('char-add-version', char.character_version || '1.0');
    
    // Lorebook
    if(char.character_book){
      setVal('char-add-lore-trigger', char.character_book.triggerMode || 'scene');
      charLorebookEntries = char.character_book.entries || [];
    } else {
      setVal('char-add-lore-trigger', 'scene');
      charLorebookEntries = [];
    }
    renderCharLorebookEntries();
    
    // v25: 關係數據
    charRelationships = char.relationships || [];
    renderCharRelationships();
    
    // v25: 表情數據
    charExpressions = char.expressions || [];
    setVal('char-add-expr-mode', char.expressionMode || 'manual');
    renderCharExpressions();
    
    // 屬性
    if(char.stats && Object.keys(char.stats).length > 0){
      setVal('char-add-stats', Object.entries(char.stats).map(([k,v])=>`${k}:${v}`).join('\n'));
    } else {
      setVal('char-add-stats', '');
    }
    
    // 更新標題
    const titleEl = document.getElementById('char-modal-title');
    if(titleEl) titleEl.textContent = '✏️ 編輯角色';
    
    // 重置面板狀態（只展開基本信息）
    document.querySelectorAll('.char-panel').forEach(p => {
      const panel = p.dataset.panel;
      const content = p.querySelector('.char-panel-content');
      const arrow = p.querySelector('.char-panel-arrow');
      if(content && arrow){
        if(panel === 'basic'){
          content.style.display = 'block';
          arrow.textContent = '▼';
          p.classList.add('expanded');
        } else {
          content.style.display = 'none';
          arrow.textContent = '▶';
          p.classList.remove('expanded');
        }
      }
    });
    
    updateCharTokenCount();
    
    // 確保overlay是active的，然後直接打開編輯模態框
    document.getElementById('overlay').classList.add('active');
    document.getElementById('char-add-modal').classList.add('active');
  } catch(err) {
    console.error('editCharacter error:', err);
    toast(T('編輯角色時出錯: ') + err.message, 'error');
  }
}

// 刪除角色
async function deleteCharacter(){
  if(!currentCharacterId) return;
  if(!confirm('確定要刪除這個角色嗎？')) return;

  // 刪除角色本身
  await db.characters.delete(currentCharacterId);
  // 刪除角色歷史記錄
  await db.characterHistory.where('characterId').equals(currentCharacterId).delete();
  // 刪除角色快照
  await db.characterSnapshots.where('characterId').equals(currentCharacterId).delete();
  // 刪除角色狀態
  await db.characterStates.where('characterId').equals(currentCharacterId).delete();
  closeModal('char-detail-modal');
  currentCharacterId = null;
  renderCharacters();
  toast(T('角色已刪除'),'success');
}

// 顯示角色歷史
async function showCharHistory(charId){
  const history = await db.characterHistory.where('characterId').equals(charId).reverse().toArray();
  const char = await db.characters.get(charId);
  
  let html = '';
  if(!history.length){
    html = '<div style="text-align:center;padding:20px;color:var(--text-secondary)">暫無屬性變化記錄</div>';
  }else{
    html = history.map(h => {
      const changeHtml = h.changes.map(c => {
        const diff = (parseInt(c.to)||0) - (parseInt(c.from)||0);
        const color = diff > 0 ? 'var(--success)' : diff < 0 ? 'var(--error)' : 'var(--text-secondary)';
        const arrow = diff > 0 ? '↑' : diff < 0 ? '↓' : '→';
        return `<span style="display:inline-block;margin:2px 4px;padding:2px 6px;background:var(--bg-tertiary);border-radius:4px;font-size:11px">${esc(c.attr)}: ${c.from} <span style="color:${color}">${arrow} ${c.to}</span></span>`;
      }).join('');
      return `<div style="padding:10px;border-bottom:1px solid var(--divider)">
        <div style="font-size:11px;color:var(--text-tertiary);margin-bottom:4px">${fmtDate(h.createdAt)}</div>
        <div>${changeHtml}</div>
      </div>`;
    }).join('');
  }
  
  document.getElementById('char-history-content').innerHTML = html;
  showModal('char-history-modal');
}

// ============ v26: 見面記錄系統 ============
let _meetingCharId = null;
let _meetingEditIdx = null;

// 添加見面記錄
function addMeeting(charId){
  _meetingCharId = charId;
  _meetingEditIdx = null;
  document.getElementById('meeting-edit-title').textContent = '📝 添加見面記錄';
  document.getElementById('meeting-time').value = story?.storyTime || '';
  document.getElementById('meeting-location').value = '';
  document.getElementById('meeting-summary').value = '';
  showModal('meeting-edit-modal');
}

// 編輯見面記錄
async function editMeeting(charId, idx){
  const char = await db.characters.get(charId);
  if(!char || !char.meetings || !char.meetings[idx]) return;

  _meetingCharId = charId;
  _meetingEditIdx = idx;
  const m = char.meetings[idx];

  document.getElementById('meeting-edit-title').textContent = '✏️ 編輯見面記錄';
  document.getElementById('meeting-time').value = m.time || '';
  document.getElementById('meeting-location').value = m.location || '';
  document.getElementById('meeting-summary').value = m.summary || '';
  showModal('meeting-edit-modal');
}

// 保存見面記錄
async function saveMeeting(){
  if(!_meetingCharId) return;

  const time = document.getElementById('meeting-time').value.trim();
  const location = document.getElementById('meeting-location').value.trim();
  const summary = document.getElementById('meeting-summary').value.trim();

  if(!summary){
    toast('請輸入內容摘要', 'warning');
    return;
  }

  const char = await db.characters.get(_meetingCharId);
  if(!char) return;

  const meetings = char.meetings || [];

  if(_meetingEditIdx !== null){
    // 編輯
    meetings[_meetingEditIdx] = { time, location, summary, updatedAt: Date.now() };
  } else {
    // 新增
    meetings.push({ time, location, summary, createdAt: Date.now() });
  }

  await db.characters.update(_meetingCharId, { meetings, updatedAt: Date.now() });

  closeModal('meeting-edit-modal');
  toast(_meetingEditIdx !== null ? '記錄已更新' : '記錄已添加', 'success');

  // 刷新角色詳情
  showCharDetail(_meetingCharId);
}

// 刪除見面記錄
async function deleteMeeting(charId, idx){
  showConfirm('確定要刪除這條見面記錄嗎？', async () => {
    const char = await db.characters.get(charId);
    if(!char || !char.meetings) return;

    char.meetings.splice(idx, 1);
    await db.characters.update(charId, { meetings: char.meetings, updatedAt: Date.now() });

    toast('記錄已刪除', 'success');
    showCharDetail(charId);
  });
}

// AI 智能提取見面記錄
async function aiExtractMeetings(charId){
  const char = await db.characters.get(charId);
  if(!char) return;

  const preset = await db.apiPresets.filter(p => p.isActive).first();
  if(!preset || !preset.apiKey){
    toast('請先配置 API', 'warning');
    return;
  }

  if(msgs.length < 3){
    toast('對話記錄太少，無法分析', 'info');
    return;
  }

  showAiRangeSelector('🤖 AI 提取見面記錄', (range) => doAiExtractMeetings(charId, char, range), 30);
}

async function doAiExtractMeetings(charId, char, range){
  showLoading(`AI 正在分析與「${char.name}」的互動記錄...`);

  try {
    const recentMsgs = msgs.slice(-range);
    const dialogContent = recentMsgs.map(m => {
      const role = m.role === 'user' ? '【玩家】' : '【劇情】';
      return `${role} ${m.content}`;
    }).join('\n\n');

    console.log('[AI Meetings] 分析範圍:', range, '條消息');
    console.log('[AI Meetings] 對話內容長度:', dialogContent.length);

    const existingMeetings = (char.meetings || []).map(m => `${m.time}: ${m.summary}`).join('\n') || '無';

    const prompt = `請仔細分析以下角色扮演對話內容，找出玩家與角色「${char.name}」的所有見面/互動記錄。

角色信息：
- 名字：${char.name}
- 身份：${char.title || '未知'}
- 描述：${char.description || '無'}

已有的見面記錄（避免重複）：
${existingMeetings}

對話內容：
${dialogContent}

請以 JSON 格式返回新發現的見面記錄（不要包含已有的）。

格式要求：
{
  "meetings": [
    {
      "time": "見面時間（如：第三天下午、故事開始時、某個場景中，若無明確時間可寫「故事中」）",
      "location": "地點（如有，無則留空）",
      "summary": "這次見面的主要內容、談話要點、重要事件（50-100字）"
    }
  ]
}

重要規則：
1. 積極識別與「${char.name}」相關的任何互動、對話、見面
2. 即使只是簡短的交流也應該記錄
3. 不要重複已有的記錄
4. 按時間順序排列
5. 只有在對話中完全沒有與該角色的互動時，才返回 {"meetings":[]}
6. 摘要要簡潔但包含關鍵信息`;

    const resp = await callAIForAnalysis(prompt, `你是一個專業的故事互動記錄分析助手。你的任務是從角色扮演對話中提取玩家與角色「${char.name}」的所有見面和互動記錄。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。`);
    const result = resp.content || '';

    console.log('[AI Meetings] 原始返回:', result);

    const jsonMatch = result.match(/\{[\s\S]*\}/);
    if(!jsonMatch){
      hideLoading();
      toast('AI 未能識別到見面記錄', 'info');
      return;
    }

    let parsed;
    try {
      parsed = JSON.parse(jsonMatch[0]);
    } catch(e) {
      hideLoading();
      toast('AI 返回的數據格式錯誤', 'error');
      return;
    }

    const newMeetings = parsed.meetings || [];

    if(!newMeetings.length){
      hideLoading();
      toast(`未發現與「${char.name}」的新見面記錄`, 'info');
      return;
    }

    // 合併到現有記錄
    const meetings = char.meetings || [];
    newMeetings.forEach(m => {
      meetings.push({
        time: m.time || '',
        location: m.location || '',
        summary: m.summary || '',
        createdAt: Date.now(),
        aiGenerated: true
      });
    });

    await db.characters.update(charId, { meetings, updatedAt: Date.now() });

    hideLoading();
    toast(`已添加 ${newMeetings.length} 條見面記錄`, 'success');

    // 刷新角色詳情
    showCharDetail(charId);

  } catch(e) {
    hideLoading();
    console.error('AI extract meetings error:', e);
    toast('提取失敗: ' + e.message, 'error');
  }
}

// 批量提取所有角色的見面記錄
async function aiExtractAllMeetings(){
  if(!story){
    toast('請先選擇故事', 'warning');
    return;
  }

  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  if(!chars.length){
    toast('沒有角色可以提取', 'info');
    return;
  }

  const preset = await db.apiPresets.filter(p => p.isActive).first();
  if(!preset || !preset.apiKey){
    toast('請先配置 API', 'warning');
    return;
  }

  if(msgs.length < 3){
    toast('對話記錄太少，無法分析', 'info');
    return;
  }

  showAiRangeSelector('🤖 批量提取所有角色見面記錄', (range) => doAiExtractAllMeetings(chars, range), 30);
}

async function doAiExtractAllMeetings(chars, range){
  const recentMsgs = msgs.slice(-range);
  const dialogContent = recentMsgs.map(m => {
    const role = m.role === 'user' ? '【玩家】' : '【劇情】';
    return `${role} ${m.content}`;
  }).join('\n\n');

  let totalAdded = 0;
  let processedCount = 0;

  for(const char of chars){
    processedCount++;
    showLoading(`正在分析 ${char.name}（${processedCount}/${chars.length}）...`);

    try {
      const existingMeetings = (char.meetings || []).map(m => `${m.time}: ${m.summary}`).join('\n') || '無';

      const prompt = `請仔細分析以下對話內容，找出玩家與角色「${char.name}」的所有見面/互動記錄。

角色信息：
- 名字：${char.name}
- 身份：${char.title || '未知'}
- 描述：${char.description || '無'}

已有的見面記錄（避免重複）：
${existingMeetings}

對話內容：
${dialogContent}

請以 JSON 格式返回新發現的見面記錄（不要包含已有的）。

格式要求：
{
  "meetings": [
    {
      "time": "見面時間（如：第三天下午、故事開始時）",
      "location": "地點（如有）",
      "summary": "這次見面的主要內容、談話要點、重要事件（50-100字）"
    }
  ]
}

重要規則：
1. 只提取與「${char.name}」直接相關的見面/互動
2. 不要重複已有的記錄
3. 按時間順序排列
4. 只有在對話中完全沒有與該角色的互動時，才返回 {"meetings":[]}
5. 摘要要簡潔但包含關鍵信息`;

      const resp = await callAIForAnalysis(prompt, `你是一個專業的故事互動記錄分析助手。你的任務是從角色扮演對話中提取玩家與角色「${char.name}」的所有見面和互動記錄。請積極識別，寧可多提取也不要遺漏。務必返回有效的 JSON 格式。`);
      const result = resp.content || '';

      console.log(`[AI Meetings] ${char.name} 原始返回:`, result);

      const jsonMatch = result.match(/\{[\s\S]*\}/);
      if(!jsonMatch) continue;

      let parsed;
      try {
        parsed = JSON.parse(jsonMatch[0]);
      } catch(e) {
        console.error(`[AI Meetings] ${char.name} JSON 解析失敗:`, e);
        continue;
      }

      const newMeetings = parsed.meetings || [];
      if(!newMeetings.length) continue;

      // 合併到現有記錄
      const meetings = char.meetings || [];
      newMeetings.forEach(m => {
        meetings.push({
          time: m.time || '',
          location: m.location || '',
          summary: m.summary || '',
          createdAt: Date.now(),
          aiGenerated: true
        });
      });

      await db.characters.update(char.id, { meetings, updatedAt: Date.now() });
      totalAdded += newMeetings.length;
      console.log(`[AI Meetings] ${char.name} 添加了 ${newMeetings.length} 條記錄`);

    } catch(e) {
      console.error(`[AI Meetings] ${char.name} 提取失敗:`, e);
    }
  }

  hideLoading();

  if(totalAdded > 0){
    toast(`已為 ${chars.length} 位角色提取了 ${totalAdded} 條見面記錄`, 'success');
  } else {
    toast('未發現新的見面記錄', 'info');
  }

  // 刷新當前角色詳情（如果有打開的話）
  if(currentCharacterId){
    showCharDetail(currentCharacterId);
  }
}

// 在壓縮記憶前保存角色快照
async function saveCharacterSnapshot(){
  if(!story) return;
  const chars = await db.characters.where('storyId').equals(story.id).toArray();
  if(!chars.length) return;
  
  await db.characterSnapshots.add({
    id: crypto.randomUUID(),
    storyId: story.id,
    characters: chars,
    messageCount: msgs.length,
    createdAt: Date.now()
  });
}

// 顯示數值變化動畫
function showValueChange(element, value, isUp){
  const rect = element.getBoundingClientRect();
  const change = document.createElement('div');
  change.className = 'char-value-change ' + (isUp ? 'up' : 'down');
  change.textContent = (isUp ? '+' : '') + value + (isUp ? ' ↑' : ' ↓');
  change.style.left = rect.left + 'px';
  change.style.top = rect.top + 'px';
  document.body.appendChild(change);
  setTimeout(() => change.remove(), 1500);
}

// 在goTo函數中添加角色視圖的渲染
const originalGoTo = typeof goTo === 'function' ? goTo : null;

// 數據導入導出
async function exportAll(){
  showLoading('導出中...');
  try{
    const data={
      version:'6.1',
      exportedAt:Date.now(),
      stories:await db.stories.toArray(),
      messages:await db.messages.toArray(),
      branches:await db.branches.toArray(),
      instructions:await db.instructions.toArray(),
      storyInstructions:await db.storyInstructions.toArray(),
      loreEntries:await db.loreEntries.toArray(),
      foreshadowing:await db.foreshadowing.toArray(),
      events:await db.events.toArray(),
      saves:await db.saves.toArray(),
      apiPresets:await db.apiPresets.toArray(),
      settings:await db.settings.toArray(),
      timeline:await db.timeline.toArray(),
      chapters:await db.chapters.toArray(),
      bookmarks:await db.bookmarks.toArray(),
      plotTags:await db.plotTags.toArray(),
      characters:await db.characters.toArray(),
      characterSnapshots:await db.characterSnapshots.toArray(),
      characterHistory:await db.characterHistory.toArray(),
      lorebook:await db.lorebook.toArray(),
      lorebookTriggerLog:await db.lorebookTriggerLog.toArray(),
      // v16 新增
      quickCommands:await db.quickCommands.toArray(),
      scenes:await db.scenes.toArray(),
      // v22 新增
      personas:await db.personas.toArray(),
      playerPanels:await db.playerPanels.toArray(),
      // 補充遺漏的表
      characterStates:await db.characterStates.toArray()
    };
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');a.href=url;a.download=`zhimeng_backup_${new Date().toISOString().slice(0,10)}.json`;a.click();
    URL.revokeObjectURL(url);
    toast(T('數據導出成功！'),'success');
  }catch(e){toast('導出失敗: '+e.message,'error');}
  hideLoading();
}

// v24: 導出書籍格式模板（帶詳細注釋）
function exportBookTemplate(){
  const template = {
    "_說明": "這是織夢 v6.1 的完整書籍JSON格式模板。請根據此模板製作書籍數據，所有標記為「必填」的字段都必須提供。",
    "_版本": "6.1",
    "_導出時間": "ISO格式時間戳，如 2024-01-01T12:00:00.000Z",

    "story": {
      "_說明": "故事基本信息",
      "id": "字符串 - 唯一ID（建議使用UUID格式，如 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'）【必填】",
      "title": "字符串 - 故事標題【必填】",
      "icon": "字符串 - emoji圖標，如 '📖'【可選】",
      "description": "字符串 - 故事簡介【可選】",
      "systemPrompt": "字符串 - 系統提示詞/故事設定【建議填寫】",
      "mode": "字符串 - 模式：'normal'（普通）或 'simulation'（經營）【必填，默認 'normal'】",
      "currentBranchId": "字符串 - 當前分支ID（默認使用 'main'）【必填】",
      "currentMessageId": "字符串 - 當前消息ID【可選】",
      "preview": "字符串 - 預覽文字（最近一條AI回覆的前100字）【可選】",
      "wordCount": "數字 - 總字數【可選，默認0】",
      "messageCount": "數字 - 消息數量【可選，默認0】",
      "createdAt": "數字 - 創建時間戳（毫秒）【必填】",
      "updatedAt": "數字 - 更新時間戳（毫秒）【必填】",
      "storyTime": "字符串 - 故事內時間，如 '第三天 上午'【可選】",
      "inventory": "數組 - 財產資產列表【可選】",
      "draft": "字符串 - 草稿內容【可選】",
      "_經營模式專用字段": {
        "simDay": "數字 - 經營模式第幾天【經營模式可用】",
        "simResources": "數組 - 資源列表，格式：[{name:'資源名',icon:'📊',value:100,max:1000}]【經營模式可用】"
      }
    },

    "messages": [
      {
        "_說明": "對話消息列表（故事劇情）",
        "id": "字符串 - 唯一ID（UUID格式）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "branchId": "字符串 - 所屬分支ID【必填】",
        "role": "字符串 - 'user'（玩家）或 'assistant'（AI）【必填】",
        "content": "字符串 - 消息內容【必填】",
        "tokens": "數字 - token數量【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】",
        "storyTime": "字符串 - 故事內時間【可選】",
        "isImportant": "布爾值 - 是否標記為重要記憶【可選，默認false】"
      }
    ],

    "branches": [
      {
        "_說明": "分支管理（平行世界線）",
        "id": "字符串 - 分支ID（默認分支用 'main'）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "name": "字符串 - 分支名稱【必填】",
        "description": "字符串 - 分支描述【可選】",
        "parentId": "字符串 - 父分支ID【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】"
      }
    ],

    "characters": [
      {
        "_說明": "角色系統（支持 Character Card V2 格式）",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "name": "字符串 - 角色名稱【必填】",
        "avatar": "字符串 - emoji頭像，如 '👤'【可選】",
        "avatarImage": "字符串 - 頭像圖片URL（base64或網址）【可選】",
        "title": "字符串 - 身份/稱號【可選】",
        "category": "字符串 - 類別：'protagonist'（主角）、'supporting'（配角）、'npc'【可選，默認'supporting'】",
        "description": "字符串 - 角色描述【可選】",
        "personality": "字符串 - 性格特點【可選】",
        "scenario": "字符串 - 場景描述【可選】",
        "first_mes": "字符串 - 開場白【可選】",
        "mes_example": "字符串 - 對話示例（用<START>分隔）【可選】",
        "system_prompt": "字符串 - 角色專屬系統提示【可選】",
        "post_history_instructions": "字符串 - 歷史後指令【可選】",
        "creator_notes": "字符串 - 創作者備註【可選】",
        "creator": "字符串 - 創作者名稱【可選】",
        "character_version": "字符串 - 角色卡版本號【可選】",
        "alternate_greetings": "數組 - 替代開場白列表【可選】",
        "tags": "數組 - 標籤列表，如 ['友好','重要']【可選】",
        "stats": "對象 - 當前屬性值，如 {\"好感\":50,\"忠誠\":80}【可選】",
        "initialStats": "對象 - 初始屬性值【可選】",
        "relationships": "數組 - 關係列表，格式：[{type:'friend',targetName:'某角色',label:'好友',mutual:true}]【可選】",
        "expressions": "數組 - 表情立繪列表【可選】",
        "expressionMode": "字符串 - 'auto'（AI自動）或 'manual'（手動）【可選】",
        "character_book": "對象 - 角色專屬Lorebook【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】",
        "updatedAt": "數字 - 更新時間戳（毫秒）【必填】"
      }
    ],

    "lorebook": [
      {
        "_說明": "Lorebook世界觀設定庫",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "name": "字符串 - 條目名稱【必填】",
        "content": "字符串 - 條目內容【必填】",
        "keywords": "數組 - 觸發關鍵詞，如 ['皇宮','京城']【必填】",
        "enabled": "布爾值 - 是否啟用【必填，默認true】",
        "priority": "數字 - 優先級（0-10，數字越大越優先）【可選，默認5】",
        "category": "字符串 - 分類，如 '地點','人物','設定'【可選】",
        "insertionOrder": "數字 - 插入順序【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】",
        "updatedAt": "數字 - 更新時間戳（毫秒）【必填】"
      }
    ],

    "playerPanels": [
      {
        "_說明": "玩家狀態面板",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "name": "字符串 - 面板名稱，如 '我的狀態'【必填】",
        "attributes": "數組 - 屬性定義列表【必填】",
        "_attributes範例": [
          {
            "name": "字符串 - 屬性名稱【必填】",
            "icon": "字符串 - emoji圖標【必填】",
            "type": "字符串 - 'number'（數字）、'percent'（百分比）或 'text'（文字）【必填】",
            "defaultValue": "數字或字符串 - 默認值【必填】",
            "maxValue": "數字 - 最大值（僅數字和百分比類型）【可選】",
            "keywords": "數組 - 自動解析關鍵詞【可選】",
            "group": "字符串 - 分組名稱，如 'stats','status','finance'【可選】",
            "color": "字符串 - 顏色：'red','orange','green','blue','purple','pink','default'【可選】"
          }
        ],
        "values": "對象 - 當前屬性值，如 {\"魅力\":75,\"金錢\":1000}【必填】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】",
        "updatedAt": "數字 - 更新時間戳（毫秒）【必填】"
      }
    ],

    "scenes": [
      {
        "_說明": "場景系統（多角色互動）",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "name": "字符串 - 場景名稱【必填】",
        "description": "字符串 - 場景描述【可選】",
        "participants": "數組 - 參與角色ID列表【必填】",
        "isActive": "布爾值 - 是否當前場景【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】"
      }
    ],

    "personas": [
      {
        "_說明": "Persona系統（玩家人格）",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "name": "字符串 - Persona名稱【必填】",
        "description": "字符串 - 描述【可選】",
        "avatar": "字符串 - emoji頭像【可選】",
        "prompt": "字符串 - 提示詞內容【可選】",
        "isActive": "布爾值 - 是否激活【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】"
      }
    ],

    "chapters": [
      {
        "_說明": "章節管理",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "title": "字符串 - 章節標題【必填】",
        "startMessageId": "字符串 - 起始消息ID【可選】",
        "endMessageId": "字符串 - 結束消息ID【可選】",
        "summary": "字符串 - 章節摘要【可選】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】"
      }
    ],

    "foreshadowing": [
      {
        "_說明": "伏筆系統",
        "id": "字符串 - 唯一ID（UUID）【必填】",
        "storyId": "字符串 - 所屬故事ID【必填】",
        "title": "字符串 - 伏筆標題【必填】",
        "description": "字符串 - 伏筆描述【必填】",
        "isResolved": "布爾值 - 是否已回收【可選，默認false】",
        "createdAt": "數字 - 創建時間戳（毫秒）【必填】"
      }
    ],

    "_使用說明": {
      "步驟1": "根據此模板填寫您的書籍數據",
      "步驟2": "確保所有【必填】字段都已填寫",
      "步驟3": "時間戳使用 Date.now() 格式（毫秒），如 1704067200000",
      "步驟4": "ID使用UUID格式，可用在線工具生成",
      "步驟5": "保存為 .json 文件",
      "步驟6": "在織夢中通過「主界面 → 導入書籍」功能導入",
      "注意事項": "JSON必須是有效格式，建議使用JSON驗證工具檢查"
    }
  };

  try {
    const jsonStr = JSON.stringify(template, null, 2);
    const blob = new Blob([jsonStr], {type: 'application/json;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `織夢書籍格式模板_v6.1_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);

    toast(T('📋 書籍格式模板已導出！'), 'success');
  } catch(e) {
    console.error('模板導出失敗:', e);
    toast('模板導出失敗: ' + e.message, 'error');
  }
}

function importAll(){
  const input=document.getElementById('import-input');
  input.onchange=async e=>{
    const f=e.target.files[0];if(!f)return;
    showLoading('導入中...');
    try{
      const text=await f.text();
      const data=safeJSONParse(text);
      if(!data || !data.version || !data.stories)throw new Error('無效的備份文件');
      if(data.stories)await db.stories.bulkPut(data.stories);
      if(data.messages)await db.messages.bulkPut(data.messages);
      if(data.branches)await db.branches.bulkPut(data.branches);
      if(data.instructions)await db.instructions.bulkPut(data.instructions);
      if(data.storyInstructions)await db.storyInstructions.bulkPut(data.storyInstructions);
      if(data.loreEntries)await db.loreEntries.bulkPut(data.loreEntries);
      if(data.foreshadowing)await db.foreshadowing.bulkPut(data.foreshadowing);
      if(data.events)await db.events.bulkPut(data.events);
      if(data.saves)await db.saves.bulkPut(data.saves);
      if(data.apiPresets)await db.apiPresets.bulkPut(data.apiPresets);
      if(data.settings)await db.settings.bulkPut(data.settings);
      if(data.timeline)await db.timeline.bulkPut(data.timeline);
      if(data.chapters)await db.chapters.bulkPut(data.chapters);
      if(data.bookmarks)await db.bookmarks.bulkPut(data.bookmarks);
      if(data.plotTags)await db.plotTags.bulkPut(data.plotTags);
      // v7: 角色數據（兼容舊數據：如果沒有initialStats，自動設置）
      if(data.characters){
        const characters = data.characters.map(c => {
          if(!c.initialStats && c.stats && Object.keys(c.stats).length > 0) {
            c.initialStats = { ...c.stats };
          }
          return c;
        });
        await db.characters.bulkPut(characters);
      }
      if(data.characterSnapshots)await db.characterSnapshots.bulkPut(data.characterSnapshots);
      if(data.characterHistory)await db.characterHistory.bulkPut(data.characterHistory);
      // v13: Lorebook 數據
      if(data.lorebook)await db.lorebook.bulkPut(data.lorebook);
      if(data.lorebookTriggerLog)await db.lorebookTriggerLog.bulkPut(data.lorebookTriggerLog);
      // v16: 快捷指令和場景
      if(data.quickCommands)await db.quickCommands.bulkPut(data.quickCommands);
      if(data.scenes)await db.scenes.bulkPut(data.scenes);
      // v22: Persona 和玩家面板
      if(data.personas)await db.personas.bulkPut(data.personas);
      if(data.playerPanels)await db.playerPanels.bulkPut(data.playerPanels);
      // 補充遺漏的表
      if(data.characterStates)await db.characterStates.bulkPut(data.characterStates);
      await loadSettings();await renderStories();await renderInst();await renderQuickCommands();
      toast(T('數據導入成功！'),'success');
    }catch(e){toast('導入失敗: '+e.message,'error');}
    hideLoading();input.value='';
  };
  input.click();
}

// v24: 導入書籍（從主界面）
function importBook(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';

  input.onchange = async e => {
    const f = e.target.files[0];
    if(!f) return;

    showLoading('正在導入書籍...');

    try {
      const text = await f.text();
      const data = safeJSONParse(text);

      if(!data) {
        throw new Error('無效的JSON文件');
      }

      let importedCount = 0;
      const errors = [];  // 記錄錯誤

      // 判斷是完整導出格式還是單本書格式
      if(data.version && data.stories) {
        // 完整導出格式（可能包含多個故事）
        if(data.stories && Array.isArray(data.stories)) {
          try {
            await db.stories.bulkPut(data.stories);
            importedCount = data.stories.length;
          } catch(e) {
            errors.push(`故事: ${e.message}`);
          }
        }
        if(data.messages) {
          try {
            await db.messages.bulkPut(data.messages);
          } catch(e) {
            errors.push(`訊息: ${e.message}`);
          }
        }
        if(data.branches) {
          try {
            await db.branches.bulkPut(data.branches);
          } catch(e) {
            errors.push(`分支: ${e.message}`);
          }
        }
        if(data.characters) {
          try {
            const characters = data.characters.map(c => {
              if(!c.initialStats && c.stats && Object.keys(c.stats).length > 0) {
                c.initialStats = { ...c.stats };
              }
              return c;
            });
            await db.characters.bulkPut(characters);
          } catch(e) {
            errors.push(`角色: ${e.message}`);
          }
        }
        if(data.lorebook) {
          try {
            await db.lorebook.bulkPut(data.lorebook);
          } catch(e) {
            errors.push(`Lorebook: ${e.message}`);
          }
        }
        if(data.playerPanels) {
          try {
            await db.playerPanels.bulkPut(data.playerPanels);
          } catch(e) {
            errors.push(`玩家面板: ${e.message}`);
          }
        }
        if(data.scenes) {
          try {
            await db.scenes.bulkPut(data.scenes);
          } catch(e) {
            errors.push(`場景: ${e.message}`);
          }
        }
        if(data.personas) {
          try {
            await db.personas.bulkPut(data.personas);
          } catch(e) {
            errors.push(`Persona: ${e.message}`);
          }
        }
        if(data.instructions) {
          try {
            await db.instructions.bulkPut(data.instructions);
          } catch(e) {
            errors.push(`指令: ${e.message}`);
          }
        }
        if(data.storyInstructions) {
          try {
            await db.storyInstructions.bulkPut(data.storyInstructions);
          } catch(e) {
            errors.push(`故事指令綁定: ${e.message}`);
          }
        }
        if(data.chapters) {
          try {
            await db.chapters.bulkPut(data.chapters);
          } catch(e) {
            errors.push(`章節: ${e.message}`);
          }
        }
        if(data.foreshadowing) {
          try {
            await db.foreshadowing.bulkPut(data.foreshadowing);
          } catch(e) {
            errors.push(`伏筆: ${e.message}`);
          }
        }
        if(data.timeline) {
          try {
            await db.timeline.bulkPut(data.timeline);
          } catch(e) {
            errors.push(`時間軸: ${e.message}`);
          }
        }
        if(data.bookmarks) {
          try {
            await db.bookmarks.bulkPut(data.bookmarks);
          } catch(e) {
            errors.push(`書籤: ${e.message}`);
          }
        }
        if(data.characterSnapshots) {
          try {
            await db.characterSnapshots.bulkPut(data.characterSnapshots);
          } catch(e) {
            errors.push(`角色快照: ${e.message}`);
          }
        }
        if(data.characterHistory) {
          try {
            await db.characterHistory.bulkPut(data.characterHistory);
          } catch(e) {
            errors.push(`角色歷史: ${e.message}`);
          }
        }
        if(data.characterStates) {
          try {
            await db.characterStates.bulkPut(data.characterStates);
          } catch(e) {
            errors.push(`角色狀態: ${e.message}`);
          }
        }
      } else if(data.story) {
        // 單本書格式
        const story = data.story;

        // 確保必填字段存在
        if(!story.id) story.id = crypto.randomUUID();
        if(!story.title) throw new Error('書籍缺少標題');
        if(!story.currentBranchId) story.currentBranchId = 'main';
        if(!story.createdAt) story.createdAt = Date.now();
        if(!story.updatedAt) story.updatedAt = Date.now();
        if(!story.mode) story.mode = 'normal';

        try {
          await db.stories.put(story);
          importedCount = 1;
        } catch(e) {
          errors.push(`故事: ${e.message}`);
          throw new Error('故事導入失敗，無法繼續');
        }

        // 導入消息
        if(data.messages && Array.isArray(data.messages)) {
          try {
            // 確保所有消息的storyId正確
            const messages = data.messages.map(m => ({
              ...m,
              storyId: story.id,
              branchId: m.branchId || story.currentBranchId
            }));
            await db.messages.bulkPut(messages);
          } catch(e) {
            errors.push(`訊息: ${e.message}`);
          }
        }

        // 導入分支
        if(data.branches && Array.isArray(data.branches)) {
          try {
            const branches = data.branches.map(b => ({
              ...b,
              storyId: story.id
            }));
            await db.branches.bulkPut(branches);
          } catch(e) {
            errors.push(`分支: ${e.message}`);
          }
        } else {
          try {
            // 確保至少有主分支
            const mainBranch = {
              id: 'main',
              storyId: story.id,
              name: '主線',
              description: '主要劇情線',
              createdAt: Date.now()
            };
            await db.branches.put(mainBranch);
          } catch(e) {
            errors.push(`主分支: ${e.message}`);
          }
        }

        // 導入角色
        if(data.characters && Array.isArray(data.characters)) {
          try {
            const characters = data.characters.map(c => {
              const char = { ...c, storyId: story.id };
              if(!char.id) char.id = crypto.randomUUID();
              if(!char.createdAt) char.createdAt = Date.now();
              if(!char.updatedAt) char.updatedAt = Date.now();
              if(!char.initialStats && char.stats && Object.keys(char.stats).length > 0) {
                char.initialStats = { ...char.stats };
              }
              return char;
            });
            await db.characters.bulkPut(characters);
          } catch(e) {
            errors.push(`角色: ${e.message}`);
          }
        }

        // 導入Lorebook
        if(data.lorebook && Array.isArray(data.lorebook)) {
          try {
            const lorebook = data.lorebook.map(l => ({
              ...l,
              id: l.id || crypto.randomUUID(),
              storyId: story.id,
              createdAt: l.createdAt || Date.now(),
              updatedAt: l.updatedAt || Date.now()
            }));
            await db.lorebook.bulkPut(lorebook);
          } catch(e) {
            errors.push(`Lorebook: ${e.message}`);
          }
        }

        // 導入玩家面板
        if(data.playerPanels && Array.isArray(data.playerPanels)) {
          try {
            const panels = data.playerPanels.map(p => ({
              ...p,
              storyId: story.id
            }));
            await db.playerPanels.bulkPut(panels);
          } catch(e) {
            errors.push(`玩家面板: ${e.message}`);
          }
        }

        // 導入場景
        if(data.scenes && Array.isArray(data.scenes)) {
          try {
            const scenes = data.scenes.map(s => ({
              ...s,
              storyId: story.id
            }));
            await db.scenes.bulkPut(scenes);
          } catch(e) {
            errors.push(`場景: ${e.message}`);
          }
        }

        // 導入Persona
        if(data.personas && Array.isArray(data.personas)) {
          try {
            await db.personas.bulkPut(data.personas);
          } catch(e) {
            errors.push(`Persona: ${e.message}`);
          }
        }

        // 導入指令
        if(data.instructions && Array.isArray(data.instructions)) {
          try {
            await db.instructions.bulkPut(data.instructions);
          } catch(e) {
            errors.push(`指令: ${e.message}`);
          }
        }

        // 導入故事指令綁定
        if(data.storyInstructions && Array.isArray(data.storyInstructions)) {
          try {
            const storyInsts = data.storyInstructions.map(si => ({
              ...si,
              storyId: story.id
            }));
            await db.storyInstructions.bulkPut(storyInsts);
          } catch(e) {
            errors.push(`故事指令綁定: ${e.message}`);
          }
        }

        // 導入章節
        if(data.chapters && Array.isArray(data.chapters)) {
          try {
            const chapters = data.chapters.map(ch => ({
              ...ch,
              storyId: story.id
            }));
            await db.chapters.bulkPut(chapters);
          } catch(e) {
            errors.push(`章節: ${e.message}`);
          }
        }

        // 導入伏筆
        if(data.foreshadowing && Array.isArray(data.foreshadowing)) {
          try {
            const foreshadowing = data.foreshadowing.map(f => ({
              ...f,
              storyId: story.id
            }));
            await db.foreshadowing.bulkPut(foreshadowing);
          } catch(e) {
            errors.push(`伏筆: ${e.message}`);
          }
        }
      } else {
        throw new Error('無法識別的書籍格式。請確保JSON包含 story 或 stories 字段。');
      }

      // 刷新故事列表和指令列表
      await renderStories();
      await renderInst();

      hideLoading();

      // 顯示導入結果
      if(errors.length === 0) {
        toast(`📚 成功導入 ${importedCount} 本書籍！`, 'success');
      } else if(importedCount > 0) {
        // 部分成功
        const errorMsg = errors.join('\n• ');
        toast(`⚠️ 書籍已導入，但以下項目失敗：\n• ${errorMsg}`, 'warning');
      } else {
        // 完全失敗
        const errorMsg = errors.join('\n• ');
        throw new Error(`導入失敗：\n• ${errorMsg}`);
      }

    } catch(e) {
      hideLoading();
      console.error('導入書籍失敗:', e);
      toast('導入失敗: ' + e.message, 'error');
    }
  };

  input.click();
}

function clearAll(){showConfirm('確定要清空所有數據嗎？此操作不可恢復！',async()=>{showLoading('清空中...');try{await db.delete();await initDB();await renderStories();await renderInst();toast(T('數據已清空'),'success');}catch(e){toast('清空失敗: '+e.message,'error');}hideLoading();},true);}

// Toast & Loading
let toastTimeout = null;
function toast(msg,type=''){
  const t=document.getElementById('toast');
  document.getElementById('toast-text').textContent=msg;
  t.className='toast active '+type;
  // 清除之前的定時器，避免重疊
  if(toastTimeout) clearTimeout(toastTimeout);
  toastTimeout = setTimeout(()=>{
    t.classList.remove('active');
    toastTimeout = null;
  },2500);
}
function showLoading(txt='處理中...'){document.getElementById('loading-text').textContent=txt;document.getElementById('loading').classList.add('active');}
function hideLoading(){document.getElementById('loading').classList.remove('active');}

// 工具函數
function esc(t){if(!t)return'';const d=document.createElement('div');d.textContent=t;return d.innerHTML;}
// 别名：escHtml = esc
function escHtml(t){return esc(t);}
// 转义HTML属性值（防止XSS）
function escAttr(t){if(!t)return'';return String(t).replace(/'/g,'&#39;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}
function fmtNum(n){return n>=10000?(n/10000).toFixed(1)+'萬':n.toLocaleString();}
function fmtDate(ts){if(!ts)return'未知';const d=new Date(ts);return `${d.getFullYear()}/${d.getMonth()+1}/${d.getDate()} ${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;}
function timeAgo(ts){const d=Date.now()-ts,m=Math.floor(d/60000),h=Math.floor(d/3600000),dy=Math.floor(d/86400000);if(m<1)return'剛剛';if(m<60)return m+'分鐘前';if(h<24)return h+'小時前';if(dy<7)return dy+'天前';const dt=new Date(ts);return(dt.getMonth()+1)+'/'+dt.getDate();}
// 安全的整数解析：如果解析失败返回默认值而不是NaN
function safeParseInt(value, defaultValue = 0){
  const parsed = parseInt(value);
  return isNaN(parsed) ? defaultValue : parsed;
}
// 安全的JSON解析：捕获错误并返回默认值
function safeJSONParse(jsonString, defaultValue = null){
  if(!jsonString || typeof jsonString !== 'string') return defaultValue;
  try{
    const parsed = JSON.parse(jsonString);
    // 基本验证：确保不是函数或其他危险类型
    if(typeof parsed === 'function') return defaultValue;
    return parsed;
  }catch(e){
    console.warn('[JSON] 解析失败:', e.message, '输入:', jsonString.slice(0, 100));
    return defaultValue;
  }
}

// ============ 雲端同步功能 (GitHub Gist) ============
let cloudSyncSettings = {
  githubToken: '',
  gistId: '',
  autoSync: false,
  lastSyncTime: 0
};

// 加載雲端同步設置
async function loadCloudSyncSettings(){
  try {
    const saved = await db.settings.get('cloudSyncSettings');
    if(saved && saved.value){
      cloudSyncSettings = {...cloudSyncSettings, ...saved.value};
      updateCloudSyncStatus();
    }
  } catch(e){
    console.error('[CloudSync] 加載設置失敗:', e);
  }
}

// 更新雲端同步狀態顯示
function updateCloudSyncStatus(){
  const statusEl = document.getElementById('cloud-sync-status');
  if(!statusEl) return;

  if(cloudSyncSettings.githubToken){
    const lastSync = cloudSyncSettings.lastSyncTime;
    if(lastSync){
      const timeAgo = Math.floor((Date.now() - lastSync) / 60000); // 分鐘
      if(timeAgo < 60){
        statusEl.textContent = `${timeAgo}分鐘前 ›`;
      } else if(timeAgo < 1440){
        statusEl.textContent = `${Math.floor(timeAgo/60)}小時前 ›`;
      } else {
        statusEl.textContent = `${Math.floor(timeAgo/1440)}天前 ›`;
      }
    } else {
      statusEl.textContent = '已設置 ›';
    }
  } else {
    statusEl.textContent = '未設置 ›';
  }
}

// 顯示雲端同步設置
function showCloudSyncSettings(){
  document.getElementById('github-token').value = cloudSyncSettings.githubToken || '';
  document.getElementById('gist-id').value = cloudSyncSettings.gistId || '';
  document.getElementById('auto-sync-enabled').checked = cloudSyncSettings.autoSync || false;
  showModal('cloud-sync-modal');
}

// 保存雲端同步設置
async function saveCloudSyncSettings(){
  const token = document.getElementById('github-token').value.trim();
  const gistId = document.getElementById('gist-id').value.trim();
  const autoSync = document.getElementById('auto-sync-enabled').checked;

  if(!token){
    toast('請輸入 GitHub Token', 'warning');
    return;
  }

  if(!token.startsWith('ghp_') && !token.startsWith('github_pat_')){
    toast('Token 格式不正確，應以 ghp_ 或 github_pat_ 開頭', 'warning');
    return;
  }

  cloudSyncSettings = {
    githubToken: token,
    gistId: gistId,
    autoSync: autoSync,
    lastSyncTime: cloudSyncSettings.lastSyncTime
  };

  await db.settings.put({
    key: 'cloudSyncSettings',
    value: cloudSyncSettings
  });

  updateCloudSyncStatus();
  closeModal('cloud-sync-modal');
  toast('雲端同步設置已保存', 'success');
}

// 上傳到雲端
async function uploadToCloud(){
  if(!cloudSyncSettings.githubToken){
    toast('請先設置 GitHub Token', 'warning');
    showCloudSyncSettings();
    return;
  }

  showLoading('正在上傳到雲端...');

  try {
    // 導出所有數據
    const data = {
      version: '6.2',
      exportedAt: Date.now(),
      exportType: 'cloud-backup',
      stories: await db.stories.toArray(),
      messages: await db.messages.toArray(),
      branches: await db.branches.toArray(),
      instructions: await db.instructions.toArray(),
      storyInstructions: await db.storyInstructions.toArray(),
      characters: await db.characters.toArray(),
      lorebook: await db.lorebook.toArray(),
      playerPanels: await db.playerPanels.toArray(),
      scenes: await db.scenes.toArray(),
      personas: await db.personas.toArray(),
      chapters: await db.chapters.toArray(),
      foreshadowing: await db.foreshadowing.toArray(),
      timeline: await db.timeline.toArray(),
      bookmarks: await db.bookmarks.toArray(),
      characterSnapshots: await db.characterSnapshots.toArray(),
      characterHistory: await db.characterHistory.toArray(),
      characterStates: await db.characterStates.toArray(),
      quickCommands: await db.quickCommands.toArray(),
      saves: await db.saves.toArray()
    };

    const jsonContent = JSON.stringify(data, null, 2);
    const fileName = `zhimeng_backup_${new Date().toISOString().slice(0,10)}.json`;

    // 上傳到 GitHub Gist
    const gistData = {
      description: '織夢 AI 互動小說閱讀器 - 雲端備份',
      public: false,
      files: {
        [fileName]: {
          content: jsonContent
        }
      }
    };

    let response;
    if(cloudSyncSettings.gistId){
      // 更新現有 Gist
      response = await fetch(`https://api.github.com/gists/${cloudSyncSettings.gistId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `token ${cloudSyncSettings.githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(gistData)
      });
    } else {
      // 創建新 Gist
      response = await fetch('https://api.github.com/gists', {
        method: 'POST',
        headers: {
          'Authorization': `token ${cloudSyncSettings.githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(gistData)
      });
    }

    if(!response.ok){
      const error = await response.json();
      throw new Error(error.message || `HTTP ${response.status}`);
    }

    const result = await response.json();

    // 保存 Gist ID
    if(!cloudSyncSettings.gistId){
      cloudSyncSettings.gistId = result.id;
      document.getElementById('gist-id').value = result.id;
    }

    // 更新最後同步時間
    cloudSyncSettings.lastSyncTime = Date.now();
    await db.settings.put({
      key: 'cloudSyncSettings',
      value: cloudSyncSettings
    });

    updateCloudSyncStatus();
    hideLoading();
    toast('✅ 已成功上傳到雲端！', 'success');

  } catch(e){
    hideLoading();
    console.error('[CloudSync] 上傳失敗:', e);
    toast('上傳失敗: ' + e.message, 'error');
  }
}

// 自動同步防抖計時器
let autoSyncTimer = null;

// 自動同步到雲端（靜默模式，不顯示 loading 和 toast）
// 使用防抖機制，避免頻繁觸發（30秒內只執行一次）
async function autoSyncToCloud(){
  // 檢查是否啟用自動同步
  if(!cloudSyncSettings.autoSync || !cloudSyncSettings.githubToken){
    return;
  }

  // 清除之前的計時器
  if(autoSyncTimer){
    clearTimeout(autoSyncTimer);
  }

  // 設置新的計時器，30秒後執行同步
  autoSyncTimer = setTimeout(async () => {
    try {
      console.log('[CloudSync] 開始自動同步...');

      // 導出所有數據
      const data = {
      version: '6.2',
      exportTime: new Date().toISOString(),
      stories: await db.stories.toArray(),
      messages: await db.messages.toArray(),
      branches: await db.branches.toArray(),
      instructions: await db.instructions.toArray(),
      storyInstructions: await db.storyInstructions.toArray(),
      loreEntries: await db.loreEntries.toArray(),
      foreshadowing: await db.foreshadowing.toArray(),
      events: await db.events.toArray(),
      characterStates: await db.characterStates.toArray(),
      timeline: await db.timeline.toArray(),
      saves: await db.saves.toArray(),
      apiPresets: await db.apiPresets.toArray(),
      settings: await db.settings.toArray(),
      chapters: await db.chapters.toArray(),
      bookmarks: await db.bookmarks.toArray(),
      plotTags: await db.plotTags.toArray(),
      characters: await db.characters.toArray(),
      characterSnapshots: await db.characterSnapshots.toArray(),
      characterHistory: await db.characterHistory.toArray(),
      lorebook: await db.lorebook.toArray(),
      lorebookTriggerLog: await db.lorebookTriggerLog.toArray()
    };

    const jsonContent = JSON.stringify(data, null, 2);
    const fileName = `zhimeng-backup-${new Date().toISOString().split('T')[0]}.json`;

    const gistData = {
      description: '織夢 AI 互動小說閱讀器 - 雲端備份',
      public: false,
      files: {
        [fileName]: {
          content: jsonContent
        }
      }
    };

    let response;
    if(cloudSyncSettings.gistId){
      // 更新現有 Gist
      response = await fetch(`https://api.github.com/gists/${cloudSyncSettings.gistId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `token ${cloudSyncSettings.githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(gistData)
      });
    } else {
      // 創建新 Gist
      response = await fetch('https://api.github.com/gists', {
        method: 'POST',
        headers: {
          'Authorization': `token ${cloudSyncSettings.githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(gistData)
      });
    }

    if(!response.ok){
      const error = await response.json();
      throw new Error(error.message || `HTTP ${response.status}`);
    }

    const result = await response.json();

    // 保存 Gist ID
    if(!cloudSyncSettings.gistId){
      cloudSyncSettings.gistId = result.id;
    }

    // 更新最後同步時間
    cloudSyncSettings.lastSyncTime = Date.now();
    await db.settings.put({
      key: 'cloudSyncSettings',
      value: cloudSyncSettings
    });

    updateCloudSyncStatus();
    console.log('[CloudSync] 自動同步成功');

  } catch(e){
    console.error('[CloudSync] 自動同步失敗:', e);
    // 靜默失敗，不打擾用戶
  }
  }, 30000); // 30秒後執行
}

// 從雲端下載
async function downloadFromCloud(){
  if(!cloudSyncSettings.githubToken){
    toast('請先設置 GitHub Token', 'warning');
    showCloudSyncSettings();
    return;
  }

  if(!cloudSyncSettings.gistId){
    toast('請先上傳數據或輸入 Gist ID', 'warning');
    showCloudSyncSettings();
    return;
  }

  showLoading('正在從雲端下載...');

  try {
    const response = await fetch(`https://api.github.com/gists/${cloudSyncSettings.gistId}`, {
      headers: {
        'Authorization': `token ${cloudSyncSettings.githubToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });

    if(!response.ok){
      const error = await response.json();
      throw new Error(error.message || `HTTP ${response.status}`);
    }

    const gist = await response.json();
    const files = Object.values(gist.files);

    if(files.length === 0){
      throw new Error('Gist 中沒有找到備份文件');
    }

    // 獲取最新的備份文件
    const backupFile = files.find(f => f.filename.startsWith('zhimeng_backup_')) || files[0];
    const content = backupFile.content;
    const data = JSON.parse(content);

    // 確認是否要覆蓋本地數據
    const confirmed = await new Promise(resolve => {
      showConfirm(
        `確定要從雲端恢復數據嗎？\n\n這將覆蓋本地所有數據！\n\n雲端備份時間：${new Date(data.exportedAt).toLocaleString()}`,
        () => resolve(true),
        true
      );
      // 添加取消按鈕的處理
      setTimeout(() => {
        const cancelBtn = document.querySelector('#confirm-modal .modal-btn.cancel');
        if(cancelBtn){
          cancelBtn.onclick = () => {
            closeModal('confirm-modal');
            resolve(false);
          };
        }
      }, 100);
    });

    if(!confirmed){
      hideLoading();
      return;
    }

    // 導入數據
    if(data.stories) await db.stories.bulkPut(data.stories);
    if(data.messages) await db.messages.bulkPut(data.messages);
    if(data.branches) await db.branches.bulkPut(data.branches);
    if(data.instructions) await db.instructions.bulkPut(data.instructions);
    if(data.storyInstructions) await db.storyInstructions.bulkPut(data.storyInstructions);
    if(data.characters) await db.characters.bulkPut(data.characters);
    if(data.lorebook) await db.lorebook.bulkPut(data.lorebook);
    if(data.playerPanels) await db.playerPanels.bulkPut(data.playerPanels);
    if(data.scenes) await db.scenes.bulkPut(data.scenes);
    if(data.personas) await db.personas.bulkPut(data.personas);
    if(data.chapters) await db.chapters.bulkPut(data.chapters);
    if(data.foreshadowing) await db.foreshadowing.bulkPut(data.foreshadowing);
    if(data.timeline) await db.timeline.bulkPut(data.timeline);
    if(data.bookmarks) await db.bookmarks.bulkPut(data.bookmarks);
    if(data.characterSnapshots) await db.characterSnapshots.bulkPut(data.characterSnapshots);
    if(data.characterHistory) await db.characterHistory.bulkPut(data.characterHistory);
    if(data.characterStates) await db.characterStates.bulkPut(data.characterStates);
    if(data.quickCommands) await db.quickCommands.bulkPut(data.quickCommands);
    if(data.saves) await db.saves.bulkPut(data.saves);

    await loadSettings();
    await renderStories();
    await renderInst();
    await renderQuickCommands();

    hideLoading();
    toast('✅ 已成功從雲端恢復數據！', 'success');

  } catch(e){
    hideLoading();
    console.error('[CloudSync] 下載失敗:', e);
    toast('下載失敗: ' + e.message, 'error');
  }
}

// 初始化時加載雲端同步設置
document.addEventListener('DOMContentLoaded', async () => {
  await loadCloudSyncSettings();
});

console.log('織夢 v6.2 - AI互動小說閱讀器 準備就緒！');

// PWA 支持
let deferredPrompt = null;

// 註冊 Service Worker (使用內嵌方式)
// 注意：Blob URL 方式在某些瀏覽器（如 Safari）可能不支持，這是正常現象
if ('serviceWorker' in navigator) {
  const swCode = `
    const CACHE_NAME = 'zhimeng-v6.2';
    const urlsToCache = [self.location.href];
    
    self.addEventListener('install', e => {
      e.waitUntil(
        caches.open(CACHE_NAME)
          .then(cache => cache.addAll(urlsToCache))
          .then(() => self.skipWaiting())
      );
    });
    
    self.addEventListener('activate', e => {
      e.waitUntil(
        caches.keys().then(names => 
          Promise.all(names.filter(n => n !== CACHE_NAME).map(n => caches.delete(n)))
        ).then(() => self.clients.claim())
      );
    });
    
    self.addEventListener('fetch', e => {
      if (e.request.method !== 'GET') return;
      e.respondWith(
        caches.match(e.request).then(cached => {
          const fetchPromise = fetch(e.request).then(response => {
            if (response.ok) {
              const clone = response.clone();
              caches.open(CACHE_NAME).then(cache => cache.put(e.request, clone));
            }
            return response;
          }).catch(() => cached);
          return cached || fetchPromise;
        })
      );
    });
  `;
  
  try {
    const swBlob = new Blob([swCode], {type: 'application/javascript'});
    const swUrl = URL.createObjectURL(swBlob);
    
    navigator.serviceWorker.register(swUrl, {scope: './'})
      .then(reg => console.log('ServiceWorker 註冊成功:', reg.scope))
      .catch(err => {
        // Blob URL 方式在某些環境下不支持，這是正常的
        console.log('ServiceWorker 註冊失敗 (Blob URL 方式可能不受支持):', err.message);
      });
  } catch(e) {
    console.log('ServiceWorker 初始化失敗:', e.message);
  }
}

// 創建並注入 manifest
const manifest = {
  "name": "織夢 - AI互動小說閱讀器",
  "short_name": "織夢",
  "description": "AI互動小說閱讀器 - 創建你的專屬故事",
  "start_url": "./",
  "display": "standalone",
  "background_color": "#0F0F1A",
  "theme_color": "#8B7CF7",
  "orientation": "portrait",
  "icons": [
    {
      "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%238B7CF7' width='512' height='512' rx='80'/><text x='256' y='340' text-anchor='middle' fill='white' font-size='280' font-family='serif'>織</text></svg>",
      "sizes": "512x512",
      "type": "image/svg+xml",
      "purpose": "any maskable"
    },
    {
      "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%238B7CF7' width='192' height='192' rx='30'/><text x='96' y='130' text-anchor='middle' fill='white' font-size='110' font-family='serif'>織</text></svg>",
      "sizes": "192x192",
      "type": "image/svg+xml"
    }
  ]
};

const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
const manifestUrl = URL.createObjectURL(manifestBlob);
const manifestLink = document.createElement('link');
manifestLink.rel = 'manifest';
manifestLink.href = manifestUrl;
document.head.appendChild(manifestLink);

// 監聽安裝提示事件
window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  // 更新安裝狀態顯示
  const statusEl = document.getElementById('pwa-install-status');
  if (statusEl) statusEl.textContent = '可安裝 ›';
  // 顯示安裝提示
  showInstallBanner();
});

// 監聽安裝完成
window.addEventListener('appinstalled', () => {
  console.log('PWA 已安裝');
  deferredPrompt = null;
  const statusEl = document.getElementById('pwa-install-status');
  if (statusEl) statusEl.textContent = '✓ 已安裝';
});

// 顯示安裝提示橫幅
function showInstallBanner() {
  // 檢查是否已經安裝或已經顯示過
  if (window.matchMedia('(display-mode: standalone)').matches) return;
  if (localStorage.getItem('pwa-install-dismissed')) return;
  
  const banner = document.createElement('div');
  banner.id = 'install-banner';
  banner.innerHTML = `
    <div style="position:fixed;bottom:80px;left:16px;right:16px;max-width:388px;margin:0 auto;background:linear-gradient(135deg,var(--primary-dark),var(--primary));padding:16px;border-radius:12px;box-shadow:0 4px 20px rgba(139,124,247,0.4);z-index:1000;display:flex;align-items:center;gap:12px;">
      <div style="font-size:32px">📱</div>
      <div style="flex:1">
        <div style="font-size:14px;font-weight:600;color:white;margin-bottom:4px">安裝到主畫面</div>
        <div style="font-size:12px;color:rgba(255,255,255,0.8)">像 App 一樣使用織夢</div>
      </div>
      <button onclick="installPWA()" style="padding:8px 16px;background:white;color:var(--primary);border:none;border-radius:8px;font-size:13px;font-weight:600;cursor:pointer">安裝</button>
      <button onclick="dismissInstallBanner()" style="padding:8px;background:transparent;color:rgba(255,255,255,0.8);border:none;font-size:18px;cursor:pointer">×</button>
    </div>
  `;
  document.body.appendChild(banner);
}

// 調試 API 連接
async function debugApiTest() {
  const testUrl = 'https://api.deepseek.com/v1/chat/completions';
  const info = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
    isAndroid: /Android/.test(navigator.userAgent),
    isSafari: /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent),
    isChrome: /Chrome/.test(navigator.userAgent),
    location: window.location.href,
    protocol: window.location.protocol,
    online: navigator.onLine
  };
  
  let result = `📱 設備信息：\n`;
  result += `• 平台: ${info.platform}\n`;
  result += `• iOS: ${info.isIOS}\n`;
  result += `• Safari: ${info.isSafari}\n`;
  result += `• Chrome: ${info.isChrome}\n`;
  result += `• 在線: ${info.online}\n`;
  result += `• 協議: ${info.protocol}\n\n`;
  
  result += `🔗 測試連接到: ${testUrl}\n\n`;
  
  // 測試 1: 簡單 GET 請求
  result += `測試 1: HEAD 請求...\n`;
  try {
    const r1 = await fetch(testUrl, { method: 'HEAD', mode: 'cors' });
    result += `✅ HEAD 成功: ${r1.status}\n\n`;
  } catch(e) {
    result += `❌ HEAD 失敗: ${e.name} - ${e.message}\n\n`;
  }
  
  // 測試 2: POST 請求（無 body）
  result += `測試 2: POST 請求（無認證）...\n`;
  try {
    const r2 = await fetch(testUrl, { 
      method: 'POST', 
      mode: 'cors',
      credentials: 'omit',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    const t2 = await r2.text();
    result += `✅ POST 狀態: ${r2.status}\n`;
    result += `響應: ${t2.slice(0, 100)}...\n\n`;
  } catch(e) {
    result += `❌ POST 失敗: ${e.name} - ${e.message}\n`;
    result += `錯誤類型: ${e.constructor.name}\n\n`;
  }
  
  // 測試 3: 測試另一個 API
  const testUrl2 = 'https://httpbin.org/post';
  result += `測試 3: httpbin.org（CORS 測試服務）...\n`;
  try {
    const r3 = await fetch(testUrl2, { 
      method: 'POST', 
      mode: 'cors',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ test: 'hello' })
    });
    const t3 = await r3.text();
    result += `✅ httpbin 成功: ${r3.status}\n`;
    result += `響應: ${t3.slice(0, 80)}...\n\n`;
  } catch(e) {
    result += `❌ httpbin 失敗: ${e.name} - ${e.message}\n\n`;
  }
  
  // 顯示結果
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.cssText = 'max-width:90%;max-height:80vh;overflow:auto;white-space:pre-wrap;font-family:monospace;font-size:12px;text-align:left;';
  modal.innerHTML = `
    <div class="modal-title">🔧 API 調試結果</div>
    <div style="background:var(--bg-tertiary);padding:12px;border-radius:8px;margin-bottom:16px;max-height:50vh;overflow:auto;">${result}</div>
    <div class="modal-actions">
      <button class="modal-btn confirm" onclick="this.closest('.modal').remove();document.getElementById('overlay').classList.remove('active')">關閉</button>
    </div>
  `;
  document.getElementById('overlay').classList.add('active');
  document.body.appendChild(modal);
}

// 安裝 PWA
async function installPWA() {
  if (!deferredPrompt) {
    // 對於 iOS，顯示手動安裝指引
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    if (isIOS) {
      showModal('ios-install-modal');
    } else {
      toast(T('請使用瀏覽器菜單中的「加入主畫面」功能'), 'info');
    }
    dismissInstallBanner();
    return;
  }
  
  deferredPrompt.prompt();
  const result = await deferredPrompt.userChoice;
  console.log('安裝結果:', result.outcome);
  deferredPrompt = null;
  dismissInstallBanner();
  
  if (result.outcome === 'accepted') {
    toast(T('🎉 安裝成功！'), 'success');
  }
}

// 關閉安裝橫幅
function dismissInstallBanner() {
  const banner = document.getElementById('install-banner');
  if (banner) banner.remove();
  localStorage.setItem('pwa-install-dismissed', 'true');
}

// 檢測是否以 PWA 模式運行
if (window.matchMedia('(display-mode: standalone)').matches) {
  console.log('正在以 PWA 模式運行');
  // 更新安裝狀態
  setTimeout(() => {
    const statusEl = document.getElementById('pwa-install-status');
    if (statusEl) statusEl.textContent = '✓ 已安裝';
  }, 100);
}

// ============================================
// 指令生成向導系統
// ============================================

// 向導狀態
let wizardState = {
  step: 0,
  data: {
    template: null,
    basic: { type: '', era: '', setting: '', theme: '' },
    protagonist: { name: '', identity: '', gender: '', personality: '', appearance: '', background: '', goal: '' },
    characters: [],
    mechanics: { attributes: [], systems: [], triggers: [] },
    style: { tone: '', perspective: '', detail: '', format: '' },
    aiRules: { dos: [], donts: [], special: '' },
    examples: { opening: '', response: '', status: '' },
    aiChat: []
  },
  aiAsked: false
};

// 預設模板
const wizardTemplates = [
  {
    id: 'palace',
    name: '宮廷後宮',
    icon: '👑',
    desc: '宮鬥、權謀、愛恨交織',
    preset: {
      type: '宮廷後宮',
      era: '架空古代東方',
      attributes: ['好感度(表面/真實)', '忠誠度', '野心值', '權勢', '寵愛度'],
      systems: ['派系勢力', '後宮位份', '朝堂政治'],
      tone: '沉穩細膩',
      perspective: '第二人稱'
    }
  },
  {
    id: 'cultivation',
    name: '修仙玄幻',
    icon: '⚔️',
    desc: '修煉、歷練、問道長生',
    preset: {
      type: '修仙玄幻',
      era: '架空仙俠世界',
      attributes: ['境界', '靈力', '壽元', '悟性', '氣運'],
      systems: ['宗門體系', '功法傳承', '天材地寶'],
      tone: '熱血激昂',
      perspective: '第二人稱'
    }
  },
  {
    id: 'apocalypse',
    name: '末日生存',
    icon: '🧟',
    desc: '廢土、喪屍、人性考驗',
    preset: {
      type: '末日生存',
      era: '近未來廢土',
      attributes: ['生命值', '飢餓度', '精神值', '感染度', '聲望'],
      systems: ['據點建設', '物資管理', '倖存者關係'],
      tone: '緊張刺激',
      perspective: '第二人稱'
    }
  },
  {
    id: 'fantasy',
    name: '西幻冒險',
    icon: '🐉',
    desc: '劍與魔法的史詩旅途',
    preset: {
      type: '西方奇幻',
      era: '中世紀魔法世界',
      attributes: ['HP', 'MP', '力量', '敏捷', '智力', '魅力'],
      systems: ['職業成長', '技能樹', '任務系統'],
      tone: '史詩壯闘',
      perspective: '第二人稱'
    }
  },
  {
    id: 'modern',
    name: '都市情感',
    icon: '🌃',
    desc: '都市愛情、職場、日常',
    preset: {
      type: '現代都市',
      era: '當代都市',
      attributes: ['好感度', '金錢', '社會地位', '壓力值', '魅力'],
      systems: ['社交關係', '事業發展', '情感線'],
      tone: '輕鬆浪漫',
      perspective: '第二人稱'
    }
  },
  {
    id: 'custom',
    name: '自定義',
    icon: '✨',
    desc: '從零開始創建',
    preset: null
  }
];

// 向導階段定義
const wizardSteps = [
  { id: 'template', title: '選擇模板', icon: '📋' },
  { id: 'basic', title: '基礎設定', icon: '🌍' },
  { id: 'protagonist', title: '主角設定', icon: '👤' },
  { id: 'characters', title: '配角系統', icon: '👥' },
  { id: 'mechanics', title: '遊戲機制', icon: '⚙️' },
  { id: 'style', title: '寫作風格', icon: '✍️' },
  { id: 'aiRules', title: 'AI行為', icon: '🤖' },
  { id: 'finish', title: '完成生成', icon: '🎉' }
];

// 範例片段
const wizardExamples = {
  basic: `## 世界觀設定
這是一個架空的東方宮廷世界，以明清為藍本但融入了更多奇幻元素。皇城分為外朝與內廷，外朝處理朝政，內廷則是后妃居所。后宮品級從高到低為：皇后、皇貴妃、貴妃、妃、嬪、貴人、常在、答應。`,
  protagonist: `## 主角設定
你是剛入宮的新晉貴人，出身江南書香門第。你外表溫婉端莊，實則聰慧機敏，心中有著自己的堅持與底線。你的父親是當朝翰林，因家族需要一個在宮中的棋子而被送入宮中。你的目標是在這吃人的後宮中保全自己和家族。`,
  characters: `## 主要角色
### 皇帝 - 蕭煜
年約二十五，在位三年。表面溫和寡言，實則城府極深。對後宮諸事看似不上心，實則一切盡在掌握。喜怒不形於色，讓人難以捉摸。

### 皇后 - 沈氏
太后娘家侄女，端莊賢淑，處事公允。但在皇后的外表下，暗藏著對權力的渴望和對自身處境的不安。`,
  mechanics: `## 遊戲機制
### 好感度系統
每個角色有兩個好感度數值：
- 表面好感：NPC 對主角展現的態度（0-100）
- 真實好感：NPC 內心真實的想法（0-100）
高表面好感+低真實好感=可能是偽裝
低表面好感+高真實好感=傲嬌/深藏不露

### 每次互動後請更新狀態：
\`\`\`
【狀態更新】
時間：XX年XX月XX日 XX時
地點：XXX
角色狀態變化：
- XXX：表面好感 +5 → 75，真實好感 不變 50
\`\`\``,
  style: `## 寫作風格要求
- 採用古風典雅的文字風格，適當使用詩詞典故
- 描寫細膩，注重氛圍營造和心理刻畫
- 對話要符合角色身份，宮廷用語得體
- 每段回覆控制在800-1500字
- 適時加入環境描寫和角色微表情細節`
};

// 啟動向導
function startWizard() {
  wizardState = {
    step: 0,
    data: {
      template: null,
      basic: { type: '', era: '', setting: '', theme: '' },
      protagonist: { name: '', identity: '', gender: '', personality: '', appearance: '', background: '', goal: '' },
      characters: [],
      mechanics: { attributes: [], systems: [], triggers: [] },
      style: { tone: '', perspective: '', detail: '', format: '' },
      aiRules: { dos: [], donts: [], special: '' },
      examples: { opening: '', response: '', status: '' },
      aiChat: []
    },
    aiAsked: false
  };
  renderWizardStep();
  goTo('view-wizard');
}

function exitWizard() {
  showConfirm('確定要退出嗎？已填寫的內容將不會保存。', () => {
    goBack();
  });
}

function showWizardHelp() {
  showConfirm(
    '指令生成向導幫助\n\n' +
    '這個向導將引導你創建一個完整的文游指令。\n\n' +
    '• 共 8 個步驟，可隨時返回修改\n' +
    '• 每步都有 AI 智能提問幫助完善\n' +
    '• 最後可導出為文檔或保存為指令\n\n' +
    '小技巧：選擇預設模板可以快速開始！',
    null, false, '💡 幫助'
  );
}

// 渲染當前步驟
function renderWizardStep() {
  const step = wizardSteps[wizardState.step];
  document.getElementById('wizard-title').textContent = step.title;
  document.getElementById('wizard-progress-fill').style.width = ((wizardState.step + 1) / wizardSteps.length * 100) + '%';
  document.getElementById('wizard-progress-text').textContent = `${wizardState.step + 1}/${wizardSteps.length} ${step.title}`;
  
  // 更新按鈕狀態
  document.getElementById('wizard-prev').disabled = wizardState.step === 0;
  const nextBtn = document.getElementById('wizard-next');
  if (wizardState.step === wizardSteps.length - 1) {
    nextBtn.textContent = '完成';
  } else {
    nextBtn.textContent = '下一步';
  }
  
  const content = document.getElementById('wizard-content');
  wizardState.aiAsked = false;
  
  switch(step.id) {
    case 'template': renderTemplateStep(content); break;
    case 'basic': renderBasicStep(content); break;
    case 'protagonist': renderProtagonistStep(content); break;
    case 'characters': renderCharactersStep(content); break;
    case 'mechanics': renderMechanicsStep(content); break;
    case 'style': renderStyleStep(content); break;
    case 'aiRules': renderAiRulesStep(content); break;
    case 'finish': renderFinishStep(content); break;
  }
}

// 步驟 0：選擇模板
function renderTemplateStep(container) {
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">📋 選擇一個模板開始</div>
      <div class="wizard-section-desc">選擇預設模板可以快速填充常用設定，你也可以選擇「自定義」從零開始。</div>
      <div class="wizard-options">
        ${wizardTemplates.map(t => `
          <div class="wizard-option template ${wizardState.data.template === t.id ? 'selected' : ''}" onclick="selectTemplate('${t.id}')">
            <div class="template-icon">${t.icon}</div>
            <div class="template-name">${t.name}</div>
            <div class="template-desc">${t.desc}</div>
          </div>
        `).join('')}
      </div>
    </div>
  `;
}

function selectTemplate(id) {
  wizardState.data.template = id;
  const template = wizardTemplates.find(t => t.id === id);
  if (template?.preset) {
    // 應用預設
    wizardState.data.basic.type = template.preset.type || '';
    wizardState.data.basic.era = template.preset.era || '';
    wizardState.data.mechanics.attributes = template.preset.attributes || [];
    wizardState.data.mechanics.systems = template.preset.systems || [];
    wizardState.data.style.tone = template.preset.tone || '';
    wizardState.data.style.perspective = template.preset.perspective || '';
  }
  renderWizardStep();
}

// 步驟 1：基礎設定
function renderBasicStep(container) {
  const d = wizardState.data.basic;
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">🌍 世界觀基礎設定</div>
      <div class="wizard-section-desc">定義故事發生的世界背景，這將決定整個故事的基調。</div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">故事類型</label>
      <input class="wizard-input" id="wiz-type" value="${esc(d.type)}" placeholder="如：宮廷後宮、修仙玄幻、末日生存...">
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">時代背景</label>
      <input class="wizard-input" id="wiz-era" value="${esc(d.era)}" placeholder="如：架空古代、近未來、中世紀魔法世界...">
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">世界觀設定</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-setting" placeholder="描述這個世界的獨特設定、規則、歷史背景等...">${esc(d.setting)}</textarea>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">核心主題</label>
      <input class="wizard-input" id="wiz-theme" value="${esc(d.theme)}" placeholder="如：權謀鬥爭、成長蛻變、愛恨糾葛...">
      
      <div class="wizard-example">
        <div class="wizard-example-title">📝 範例參考</div>
        ${wizardExamples.basic}
      </div>
    </div>
    <div class="wizard-ai-container"></div>
  `;
  
  // 自動觸發 AI 提問
  setTimeout(() => askWizardAI('basic'), 500);
}

// 步驟 2：主角設定
function renderProtagonistStep(container) {
  const d = wizardState.data.protagonist;
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">👤 主角設定</div>
      <div class="wizard-section-desc">詳細設定主角的各項屬性，這將是玩家代入的角色。</div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
        <div>
          <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">稱呼/名字</label>
          <input class="wizard-input" id="wiz-pname" value="${esc(d.name)}" placeholder="如：你、少俠、殿下...">
        </div>
        <div>
          <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">性別</label>
          <select class="wizard-input" id="wiz-pgender" style="padding:12px">
            <option value="">請選擇</option>
            <option value="male" ${d.gender==='male'?'selected':''}>男</option>
            <option value="female" ${d.gender==='female'?'selected':''}>女</option>
            <option value="custom" ${d.gender==='custom'?'selected':''}>自定義/不限</option>
          </select>
        </div>
      </div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">身份地位</label>
      <input class="wizard-input" id="wiz-pidentity" value="${esc(d.identity)}" placeholder="如：新晉貴人、散修、倖存者...">
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">性格特點</label>
      <input class="wizard-input" id="wiz-ppersonality" value="${esc(d.personality)}" placeholder="如：外柔內剛、腹黑機智、熱血正直...">
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">外貌描述</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-pappearance" placeholder="主角的外貌特徵...">${esc(d.appearance)}</textarea>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">背景故事</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-pbackground" placeholder="主角的身世、來歷、過去的經歷...">${esc(d.background)}</textarea>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">目標/動機</label>
      <input class="wizard-input" id="wiz-pgoal" value="${esc(d.goal)}" placeholder="主角在故事中的目標是什麼？">
      
      <div class="wizard-example">
        <div class="wizard-example-title">📝 範例參考</div>
        ${wizardExamples.protagonist}
      </div>
    </div>
    <div class="wizard-ai-container"></div>
  `;
  
  setTimeout(() => askWizardAI('protagonist'), 500);
}

// 步驟 3：配角系統
function renderCharactersStep(container) {
  const chars = wizardState.data.characters;
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">👥 配角系統</div>
      <div class="wizard-section-desc">添加故事中的重要 NPC，豐富的配角能讓故事更精彩。建議至少 3-5 個主要角色。</div>
      
      <div class="wizard-char-list" id="wizard-char-list">
        ${chars.length ? chars.map((c, i) => `
          <div class="wizard-char-card">
            <div class="wizard-char-avatar">${c.avatar || '👤'}</div>
            <div class="wizard-char-info">
              <div class="wizard-char-name">${esc(c.name)}</div>
              <div class="wizard-char-role">${esc(c.role)} · ${esc(c.relation)}</div>
            </div>
            <div class="wizard-char-actions">
              <button class="wizard-char-btn" onclick="editWizardChar(${i})">✏️</button>
              <button class="wizard-char-btn" onclick="deleteWizardChar(${i})">🗑️</button>
            </div>
          </div>
        `).join('') : '<div style="text-align:center;padding:20px;color:var(--text-tertiary)">尚未添加角色</div>'}
      </div>
      
      <button class="wizard-btn secondary" style="width:100%;margin-top:12px" onclick="addWizardChar()">➕ 添加角色</button>
      <button class="wizard-btn secondary" style="width:100%;margin-top:8px" onclick="aiGenerateChars()">🤖 AI 建議角色</button>
      
      <div class="wizard-example">
        <div class="wizard-example-title">📝 範例參考</div>
        ${wizardExamples.characters}
      </div>
    </div>
    <div class="wizard-ai-container"></div>
  `;
  
  setTimeout(() => askWizardAI('characters'), 500);
}

// 步驟 4：遊戲機制
function renderMechanicsStep(container) {
  const d = wizardState.data.mechanics;
  const attrOptions = ['好感度', '好感度(表面/真實)', '忠誠度', '野心值', '權勢', '寵愛度', '境界', '靈力', '壽元', '生命值', '飢餓度', '精神值', 'HP', 'MP', '力量', '敏捷', '智力', '魅力', '金錢', '聲望'];
  const sysOptions = ['派系勢力', '好感度系統', '數值成長', '技能樹', '任務系統', '物資管理', '據點建設', '時間流逝', '隱藏事件', '多結局分支', '隨機事件'];
  
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">⚙️ 遊戲機制設計</div>
      <div class="wizard-section-desc">設計讓故事更有互動性的機制，合理的機制能增強代入感。</div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">角色屬性（可多選）</label>
      <div class="wizard-options" style="margin-bottom:16px">
        ${attrOptions.map(a => `
          <div class="wizard-option ${d.attributes.includes(a)?'selected':''}" onclick="toggleWizardOption('attributes','${a}')">${a}</div>
        `).join('')}
      </div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">自定義屬性</label>
      <input class="wizard-input" id="wiz-custom-attr" placeholder="輸入後按 Enter 添加">
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px;margin-top:16px">遊戲系統（可多選）</label>
      <div class="wizard-options" style="margin-bottom:16px">
        ${sysOptions.map(s => `
          <div class="wizard-option ${d.systems.includes(s)?'selected':''}" onclick="toggleWizardOption('systems','${s}')">${s}</div>
        `).join('')}
      </div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">特殊觸發機制</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-triggers" placeholder="描述一些特殊的觸發條件，例如：好感度達到 80 時解鎖特殊劇情...">${d.triggers.join('\n')}</textarea>
      
      <div class="wizard-example">
        <div class="wizard-example-title">📝 範例參考</div>
        ${wizardExamples.mechanics}
      </div>
    </div>
    <div class="wizard-ai-container"></div>
  `;
  
  // 自定義屬性輸入
  document.getElementById('wiz-custom-attr')?.addEventListener('keypress', e => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      if (!d.attributes.includes(e.target.value.trim())) {
        d.attributes.push(e.target.value.trim());
        renderMechanicsStep(container);
      }
      e.target.value = '';
    }
  });
  
  setTimeout(() => askWizardAI('mechanics'), 500);
}

function toggleWizardOption(type, value) {
  const arr = wizardState.data.mechanics[type];
  const idx = arr.indexOf(value);
  if (idx >= 0) arr.splice(idx, 1);
  else arr.push(value);
  renderWizardStep();
}

// 步驟 5：寫作風格
function renderStyleStep(container) {
  const d = wizardState.data.style;
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">✍️ 寫作風格設定</div>
      <div class="wizard-section-desc">定義 AI 的寫作風格，讓故事呈現符合你期望的質感。</div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">文風基調</label>
      <div class="wizard-options" style="margin-bottom:16px">
        ${['輕鬆歡快', '沉穩細膩', '熱血激昂', '黑暗壓抑', '浪漫唯美', '幽默諷刺', '史詩壯闘', '懸疑緊張'].map(t => `
          <div class="wizard-option ${d.tone===t?'selected':''}" onclick="wizardState.data.style.tone='${t}';renderWizardStep()">${t}</div>
        `).join('')}
      </div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">敘事視角</label>
      <div class="wizard-options" style="margin-bottom:16px">
        ${['第一人稱', '第二人稱', '第三人稱', '上帝視角'].map(p => `
          <div class="wizard-option ${d.perspective===p?'selected':''}" onclick="wizardState.data.style.perspective='${p}';renderWizardStep()">${p}</div>
        `).join('')}
      </div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">細節程度</label>
      <div class="wizard-options" style="margin-bottom:16px">
        ${['簡潔明快（300-500字）', '適中詳細（500-1000字）', '豐富細膩（1000-2000字）', '超長篇幅（2000字+）'].map(d2 => `
          <div class="wizard-option ${d.detail===d2?'selected':''}" onclick="wizardState.data.style.detail='${d2}';renderWizardStep()">${d2}</div>
        `).join('')}
      </div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">特殊格式要求</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-format" placeholder="例如：每段開頭空兩格、對話用「」、內心獨白用（）...">${esc(d.format)}</textarea>
      
      <div class="wizard-example">
        <div class="wizard-example-title">📝 範例參考</div>
        ${wizardExamples.style}
      </div>
    </div>
    <div class="wizard-ai-container"></div>
  `;
  
  setTimeout(() => askWizardAI('style'), 500);
}

// 步驟 6：AI 行為規則
function renderAiRulesStep(container) {
  const d = wizardState.data.aiRules;
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">🤖 AI 行為規則</div>
      <div class="wizard-section-desc">設定 AI 應該做什麼、不該做什麼，確保故事按你的期望發展。</div>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">AI 應該做的（Dos）</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-dos" placeholder="每行一條，例如：
- 保持角色性格一致性
- 適時給出行動選項
- 描寫角色微表情變化">${d.dos.join('\n')}</textarea>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">AI 不應該做的（Don'ts）</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-donts" placeholder="每行一條，例如：
- 不要擅自決定主角的行動
- 不要跳過重要劇情
- 不要讓角色突然性格大變">${d.donts.join('\n')}</textarea>
      
      <label style="font-size:13px;color:var(--text-secondary);display:block;margin-bottom:6px">特殊指令</label>
      <textarea class="wizard-input wizard-textarea" id="wiz-special" placeholder="其他特殊要求...">${esc(d.special)}</textarea>
    </div>
    <div class="wizard-ai-container"></div>
  `;
  
  setTimeout(() => askWizardAI('aiRules'), 500);
}

// 步驟 7：完成
function renderFinishStep(container) {
  const prompt = generatePrompt();
  const charCount = prompt.length;
  
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">🎉 指令生成完成！</div>
      <div class="wizard-section-desc">你的文游指令已生成，可以預覽、編輯或保存。</div>
      
      <div class="wizard-preview">
        <div class="wizard-preview-header">
          <div class="wizard-preview-title">📄 指令預覽</div>
          <div class="wizard-preview-stats">${charCount.toLocaleString()} 字</div>
        </div>
        <div class="wizard-preview-content" id="wizard-preview-content">${esc(prompt.slice(0, 2000))}${prompt.length > 2000 ? '\n\n... (點擊展開查看更多)' : ''}</div>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:16px">
        <button class="wizard-btn secondary" onclick="previewFullPrompt()">👁️ 完整預覽</button>
        <button class="wizard-btn secondary" onclick="editPrompt()">✏️ 編輯微調</button>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <button class="wizard-btn secondary" onclick="exportPrompt('md')">📄 導出 MD</button>
        <button class="wizard-btn secondary" onclick="exportPrompt('txt')">📝 導出 TXT</button>
      </div>
      <button class="wizard-btn primary" style="width:100%;margin-top:8px" onclick="saveAsInstruction()">💾 保存為指令</button>
    </div>
    
    <div class="wizard-section" style="margin-top:24px">
      <div class="wizard-section-title">💬 AI 對話完善</div>
      <div class="wizard-section-desc">還有什麼想補充的？可以和 AI 對話繼續完善指令。</div>
      <div class="wizard-chat" id="wizard-chat">
        ${wizardState.data.aiChat.map(m => `
          <div class="wizard-chat-msg ${m.role}">${marked.parse(m.content)}</div>
        `).join('')}
      </div>
      <div class="wizard-chat-input">
        <input class="wizard-chat-field" id="wizard-chat-input" placeholder="輸入你的想法..." onkeypress="if(event.key==='Enter')sendWizardChat()">
        <button class="wizard-chat-send" onclick="sendWizardChat()">➤</button>
      </div>
    </div>
  `;
}

// 保存當前步驟數據
function saveWizardStepData() {
  const step = wizardSteps[wizardState.step];
  switch(step.id) {
    case 'basic':
      wizardState.data.basic = {
        type: document.getElementById('wiz-type')?.value || '',
        era: document.getElementById('wiz-era')?.value || '',
        setting: document.getElementById('wiz-setting')?.value || '',
        theme: document.getElementById('wiz-theme')?.value || ''
      };
      break;
    case 'protagonist':
      wizardState.data.protagonist = {
        name: document.getElementById('wiz-pname')?.value || '',
        identity: document.getElementById('wiz-pidentity')?.value || '',
        gender: document.getElementById('wiz-pgender')?.value || '',
        personality: document.getElementById('wiz-ppersonality')?.value || '',
        appearance: document.getElementById('wiz-pappearance')?.value || '',
        background: document.getElementById('wiz-pbackground')?.value || '',
        goal: document.getElementById('wiz-pgoal')?.value || ''
      };
      break;
    case 'mechanics':
      const triggers = document.getElementById('wiz-triggers')?.value || '';
      wizardState.data.mechanics.triggers = triggers.split('\n').filter(t => t.trim());
      break;
    case 'style':
      wizardState.data.style.format = document.getElementById('wiz-format')?.value || '';
      break;
    case 'aiRules':
      const dos = document.getElementById('wiz-dos')?.value || '';
      const donts = document.getElementById('wiz-donts')?.value || '';
      wizardState.data.aiRules = {
        dos: dos.split('\n').filter(t => t.trim()),
        donts: donts.split('\n').filter(t => t.trim()),
        special: document.getElementById('wiz-special')?.value || ''
      };
      break;
  }
}

// 上一步/下一步
function wizardPrev() {
  if (wizardState.step > 0) {
    saveWizardStepData();
    wizardState.step--;
    renderWizardStep();
  }
}

function wizardNext() {
  saveWizardStepData();
  if (wizardState.step < wizardSteps.length - 1) {
    wizardState.step++;
    renderWizardStep();
  } else {
    saveAsInstruction();
  }
}

// AI 提問
async function askWizardAI(stepId) {
  if (wizardState.aiAsked) return;
  wizardState.aiAsked = true;
  
  const box = document.querySelector('.wizard-ai-container');
  if (!box) return;
  
  box.innerHTML = `
    <div class="wizard-ai-box">
      <div class="wizard-ai-header"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span> AI 正在思考...</div>
    </div>
  `;
  
  try {
    const preset = await db.apiPresets.filter(p => p.isActive).first();
    if (!preset) {
      box.innerHTML = `<div class="wizard-ai-box"><div class="wizard-ai-header">⚠️ 提示</div><div class="wizard-ai-content">請先在設置中配置 API，才能使用 AI 智能提問功能。</div></div>`;
      return;
    }
    
    const context = JSON.stringify(wizardState.data, null, 2);
    const prompts = {
      basic: `用戶正在創建文游指令，目前填寫的基礎設定如下：
${context}

請根據用戶填寫的內容，提出 1-2 個有針對性的問題，幫助完善世界觀設定。問題要具體、有建設性。如果內容已經很完整，可以給出肯定並提出進階建議。回覆要簡潔（100字內）。`,
      protagonist: `用戶正在設定文游的主角：
${context}

請根據主角設定，提出 1-2 個問題幫助完善。可以問：主角的弱點/缺陷是什麼？有什麼特殊技能或背景故事？回覆簡潔（100字內）。`,
      characters: `用戶正在添加配角：
${context}

請根據故事類型和已有角色，建議還需要什麼類型的角色，或提問現有角色的細節。回覆簡潔（100字內）。`,
      mechanics: `用戶正在設計遊戲機制：
${context}

請根據故事類型，提出機制方面的建議或問題。例如：這些屬性之間如何互相影響？有沒有特殊的觸發機制？回覆簡潔（100字內）。`,
      style: `用戶正在設定寫作風格：
${context}

請根據故事類型和風格選擇，給出建議或提問。例如：要不要加入詩詞/專業術語？對話風格有什麼要求？回覆簡潔（100字內）。`,
      aiRules: `用戶正在設定 AI 行為規則：
${context}

請根據整體設定，建議一些重要的 AI 行為規則。什麼是 AI 必須遵守的？什麼是絕對不能做的？回覆簡潔（100字內）。`
    };
    
    const response = await callAI(prompts[stepId] || '請給出一些建議。');
    
    box.innerHTML = `
      <div class="wizard-ai-box">
        <div class="wizard-ai-header">🤖 AI 提問</div>
        <div class="wizard-ai-content">${marked.parse(response.content)}</div>
      </div>
    `;
  } catch (e) {
    box.innerHTML = `<div class="wizard-ai-box"><div class="wizard-ai-header">⚠️ AI 暫時無法回應</div><div class="wizard-ai-content">${e.message}</div></div>`;
  }
}

// 添加/編輯角色
function addWizardChar() {
  showModal('wizard-char-modal');
  document.getElementById('wiz-char-name').value = '';
  document.getElementById('wiz-char-role').value = '';
  document.getElementById('wiz-char-personality').value = '';
  document.getElementById('wiz-char-relation').value = '';
  document.getElementById('wiz-char-desc').value = '';
  document.getElementById('wiz-char-idx').value = '-1';
}

function editWizardChar(idx) {
  const c = wizardState.data.characters[idx];
  showModal('wizard-char-modal');
  document.getElementById('wiz-char-name').value = c.name || '';
  document.getElementById('wiz-char-role').value = c.role || '';
  document.getElementById('wiz-char-personality').value = c.personality || '';
  document.getElementById('wiz-char-relation').value = c.relation || '';
  document.getElementById('wiz-char-desc').value = c.description || '';
  document.getElementById('wiz-char-idx').value = idx;
}

function saveWizardChar() {
  const idx = parseInt(document.getElementById('wiz-char-idx').value);
  const char = {
    name: document.getElementById('wiz-char-name').value.trim(),
    role: document.getElementById('wiz-char-role').value.trim(),
    personality: document.getElementById('wiz-char-personality').value.trim(),
    relation: document.getElementById('wiz-char-relation').value.trim(),
    description: document.getElementById('wiz-char-desc').value.trim(),
    avatar: '👤'
  };
  if (!char.name) { toast(T('請輸入角色名稱'), 'warning'); return; }
  
  if (idx >= 0) {
    wizardState.data.characters[idx] = char;
  } else {
    wizardState.data.characters.push(char);
  }
  closeModal('wizard-char-modal');
  renderWizardStep();
}

function deleteWizardChar(idx) {
  showConfirm('確定要刪除這個角色嗎？', () => {
    wizardState.data.characters.splice(idx, 1);
    renderWizardStep();
  });
}

// AI 生成角色建議
async function aiGenerateChars() {
  toast(T('AI 正在生成角色建議...'), 'info');
  try {
    const context = JSON.stringify(wizardState.data, null, 2);
    const response = await callAI(`根據以下文游設定，建議 3 個適合的配角。請用 JSON 格式返回：
${context}

返回格式：
\`\`\`json
[
  {"name": "角色名", "role": "身份", "personality": "性格", "relation": "與主角關係", "description": "簡介"}
]
\`\`\``);
    
    const match = response.content.match(/```json\s*([\s\S]*?)\s*```/) || response.content.match(/\[\s*\{[\s\S]*\}\s*\]/);
    if (match) {
      const chars = JSON.parse(match[1] || match[0]);
      chars.forEach(c => {
        c.avatar = '👤';
        wizardState.data.characters.push(c);
      });
      renderWizardStep();
      toast(`已添加 ${chars.length} 個角色`, 'success');
    }
  } catch (e) {
    toast('生成失敗: ' + e.message, 'error');
  }
}

// 生成完整 Prompt
function generatePrompt() {
  const d = wizardState.data;
  let prompt = '';
  
  // 世界觀
  prompt += `# 世界觀設定\n\n`;
  prompt += `## 基本信息\n`;
  prompt += `- 故事類型：${d.basic.type}\n`;
  prompt += `- 時代背景：${d.basic.era}\n`;
  prompt += `- 核心主題：${d.basic.theme}\n\n`;
  if (d.basic.setting) {
    prompt += `## 詳細設定\n${d.basic.setting}\n\n`;
  }
  
  // 主角
  prompt += `# 主角設定\n\n`;
  prompt += `- 稱呼：${d.protagonist.name}\n`;
  prompt += `- 性別：${d.protagonist.gender === 'male' ? '男' : d.protagonist.gender === 'female' ? '女' : '自定義'}\n`;
  prompt += `- 身份：${d.protagonist.identity}\n`;
  prompt += `- 性格：${d.protagonist.personality}\n`;
  if (d.protagonist.appearance) prompt += `\n## 外貌\n${d.protagonist.appearance}\n`;
  if (d.protagonist.background) prompt += `\n## 背景\n${d.protagonist.background}\n`;
  if (d.protagonist.goal) prompt += `\n## 目標\n${d.protagonist.goal}\n`;
  prompt += `\n`;
  
  // 配角
  if (d.characters.length) {
    prompt += `# 主要角色\n\n`;
    d.characters.forEach(c => {
      prompt += `## ${c.name}\n`;
      prompt += `- 身份：${c.role}\n`;
      prompt += `- 性格：${c.personality}\n`;
      prompt += `- 與主角關係：${c.relation}\n`;
      if (c.description) prompt += `\n${c.description}\n`;
      prompt += `\n`;
    });
  }
  
  // 遊戲機制
  prompt += `# 遊戲機制\n\n`;
  if (d.mechanics.attributes.length) {
    prompt += `## 屬性系統\n`;
    d.mechanics.attributes.forEach(a => prompt += `- ${a}\n`);
    prompt += `\n`;
  }
  if (d.mechanics.systems.length) {
    prompt += `## 遊戲系統\n`;
    d.mechanics.systems.forEach(s => prompt += `- ${s}\n`);
    prompt += `\n`;
  }
  if (d.mechanics.triggers.length) {
    prompt += `## 特殊觸發\n`;
    d.mechanics.triggers.forEach(t => prompt += `- ${t}\n`);
    prompt += `\n`;
  }
  
  // 寫作風格
  prompt += `# 寫作要求\n\n`;
  prompt += `- 文風：${d.style.tone}\n`;
  prompt += `- 視角：${d.style.perspective}\n`;
  prompt += `- 篇幅：${d.style.detail}\n`;
  if (d.style.format) prompt += `\n## 格式要求\n${d.style.format}\n`;
  prompt += `\n`;
  
  // AI 規則
  prompt += `# AI 行為規則\n\n`;
  if (d.aiRules.dos.length) {
    prompt += `## 必須遵守\n`;
    d.aiRules.dos.forEach(r => prompt += `- ${r}\n`);
    prompt += `\n`;
  }
  if (d.aiRules.donts.length) {
    prompt += `## 禁止事項\n`;
    d.aiRules.donts.forEach(r => prompt += `- ${r}\n`);
    prompt += `\n`;
  }
  if (d.aiRules.special) {
    prompt += `## 特殊指令\n${d.aiRules.special}\n`;
  }
  
  return prompt;
}

// 預覽完整 Prompt
function previewFullPrompt() {
  const prompt = generatePrompt();
  showConfirm(prompt, null, false, '📄 完整指令預覽');
}

// 編輯 Prompt
function editPrompt() {
  const prompt = generatePrompt();
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.cssText = 'max-width:90%;max-height:80vh;';
  modal.innerHTML = `
    <div class="modal-title">✏️ 編輯指令</div>
    <textarea class="form-input" id="edit-prompt-text" style="min-height:50vh;font-family:monospace;font-size:13px;line-height:1.6">${esc(prompt)}</textarea>
    <div class="modal-actions">
      <button class="modal-btn cancel" onclick="this.closest('.modal').remove();document.getElementById('overlay').classList.remove('active')">取消</button>
      <button class="modal-btn confirm" onclick="applyEditedPrompt()">應用修改</button>
    </div>
  `;
  document.getElementById('overlay').classList.add('active');
  document.body.appendChild(modal);
}

function applyEditedPrompt() {
  const text = document.getElementById('edit-prompt-text').value;
  wizardState.editedPrompt = text;
  document.querySelector('.modal')?.remove();
  document.getElementById('overlay').classList.remove('active');
  toast(T('已應用修改'), 'success');
  renderWizardStep();
}

// 導出 Prompt
function exportPrompt(format) {
  const prompt = wizardState.editedPrompt || generatePrompt();
  const filename = `文游指令_${wizardState.data.basic.type || '自定義'}_${Date.now()}`;
  
  if (format === 'md') {
    downloadFile(prompt, filename + '.md', 'text/markdown');
  } else {
    downloadFile(prompt, filename + '.txt', 'text/plain');
  }
  toast(T('已導出指令文檔'), 'success');
}

function downloadFile(content, filename, type) {
  const blob = new Blob([content], { type: type + ';charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// 保存為指令
async function saveAsInstruction() {
  const prompt = wizardState.editedPrompt || generatePrompt();
  const name = wizardState.data.basic.type || '自定義指令';
  
  const inst = {
    id: crypto.randomUUID(),
    name: name + ' - ' + new Date().toLocaleDateString(),
    icon: wizardTemplates.find(t => t.id === wizardState.data.template)?.icon || '📜',
    systemPrompt: prompt,
    createdAt: Date.now()
  };
  
  await db.instructions.put(inst);
  toast(T('指令已保存！'), 'success');
  goTo('view-instructions');
  await renderInst();
}

// 對話完善
async function sendWizardChat() {
  const input = document.getElementById('wizard-chat-input');
  const msg = input.value.trim();
  if (!msg) return;
  
  input.value = '';
  wizardState.data.aiChat.push({ role: 'user', content: msg });
  renderWizardStep();
  
  try {
    const prompt = generatePrompt();
    const response = await callAI(`用戶正在完善以下文游指令：

${prompt}

用戶說：${msg}

請根據用戶的意見，給出修改建議或回答問題。如果用戶要求修改某部分，請明確指出應該如何修改。回覆要有建設性。`);
    
    wizardState.data.aiChat.push({ role: 'ai', content: response.content });
    renderWizardStep();
  } catch (e) {
    toast('回覆失敗: ' + e.message, 'error');
  }
}

// ============================================
// Prompt 分析系統
// ============================================

let analyzeState = {
  originalPrompt: '',
  improvedPrompt: '',
  analysis: null,
  moduleImprovements: {},
  chatHistory: []
};

const analyzeModules = [
  { id: 'worldview', name: '世界觀設定', icon: '🌍', keywords: ['世界', '背景', '時代', '設定', '歷史', '魔法', '系統'] },
  { id: 'protagonist', name: '主角設定', icon: '👤', keywords: ['主角', '你', '玩家', '身份', '性格', '目標'] },
  { id: 'characters', name: '配角系統', icon: '👥', keywords: ['角色', 'NPC', '人物', '關係', '配角'] },
  { id: 'mechanics', name: '遊戲機制', icon: '⚙️', keywords: ['屬性', '數值', '好感', '系統', '機制', '觸發'] },
  { id: 'style', name: '寫作風格', icon: '✍️', keywords: ['風格', '文風', '視角', '描寫', '篇幅', '字數'] },
  { id: 'aiRules', name: 'AI 行為規則', icon: '🤖', keywords: ['AI', '規則', '禁止', '必須', '不要', '應該', '輸出'] }
];

// 啟動分析
function startAnalyze() {
  analyzeState = {
    originalPrompt: '',
    improvedPrompt: '',
    analysis: null,
    moduleImprovements: {},
    chatHistory: []
  };
  renderAnalyzeImport();
  goTo('view-analyze');
}

function showAnalyzeHelp() {
  showConfirm(
    'Prompt 分析功能幫助\n\n' +
    '這個功能可以分析你現有的 Prompt，找出不足之處並提供改進建議。\n\n' +
    '• 支持上傳 .txt / .md 文檔或直接粘貼\n' +
    '• AI 會深度分析 6 個維度\n' +
    '• 可以分模塊單獨完善\n' +
    '• 支持原版與改進版對比\n\n' +
    '分析完成後可以導出或保存為指令。',
    null, false, '💡 幫助'
  );
}

// 渲染導入界面
function renderAnalyzeImport() {
  const container = document.getElementById('analyze-content');
  container.innerHTML = `
    <div class="wizard-section">
      <div class="wizard-section-title">📥 導入你的 Prompt</div>
      <div class="wizard-section-desc">上傳文檔或直接粘貼你想分析的 Prompt 內容。</div>
      
      <div class="analyze-import">
        <div class="analyze-import-btn" onclick="document.getElementById('analyze-file').click()">
          <div class="icon">📄</div>
          <div class="label">上傳文檔<br><small style="color:var(--text-tertiary)">.txt / .md</small></div>
        </div>
        <div class="analyze-import-btn" onclick="pasteFromClipboard()">
          <div class="icon">📋</div>
          <div class="label">從剪貼板粘貼</div>
        </div>
      </div>
      
      <div class="wizard-section-title" style="margin-top:20px">或直接輸入</div>
      <textarea class="analyze-textarea" id="analyze-input" placeholder="在此粘貼你的 Prompt 內容..."></textarea>
      
      <div id="analyze-file-info" style="display:none;margin-top:12px;padding:12px;background:var(--bg-card);border-radius:8px">
        <div style="display:flex;align-items:center;gap:8px">
          <span>📄</span>
          <span id="analyze-file-name" style="flex:1;font-size:14px"></span>
          <button onclick="clearAnalyzeFile()" style="background:none;border:none;color:var(--error);cursor:pointer">✕</button>
        </div>
      </div>
      
      <button class="wizard-btn primary" style="width:100%;margin-top:16px" onclick="startDeepAnalyze()">🔍 開始深度分析</button>
    </div>
  `;
}

// 處理文件上傳
async function handleAnalyzeFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    let text = '';
    if (file.name.endsWith('.docx')) {
      toast(T('正在解析文檔...'), 'info');
      // 簡單處理，實際需要 mammoth.js
      toast(T('暫不支持 .docx 格式，請使用 .txt 或 .md'), 'warning');
      return;
    } else {
      text = await file.text();
    }
    
    analyzeState.originalPrompt = text;
    document.getElementById('analyze-input').value = text;
    document.getElementById('analyze-file-info').style.display = 'block';
    document.getElementById('analyze-file-name').textContent = file.name;
    toast(T('文件已載入'), 'success');
  } catch (e) {
    toast('讀取文件失敗: ' + e.message, 'error');
  }
  
  event.target.value = '';
}

async function pasteFromClipboard() {
  try {
    const text = await navigator.clipboard.readText();
    if (text) {
      document.getElementById('analyze-input').value = text;
      analyzeState.originalPrompt = text;
      toast(T('已粘貼內容'), 'success');
    }
  } catch (e) {
    toast(T('無法訪問剪貼板，請手動粘貼'), 'warning');
  }
}

function clearAnalyzeFile() {
  analyzeState.originalPrompt = '';
  document.getElementById('analyze-input').value = '';
  document.getElementById('analyze-file-info').style.display = 'none';
}

// 開始深度分析
async function startDeepAnalyze() {
  const input = document.getElementById('analyze-input');
  const prompt = input?.value?.trim() || analyzeState.originalPrompt;
  
  if (!prompt) {
    toast(T('請先輸入或上傳 Prompt 內容'), 'warning');
    return;
  }
  
  if (prompt.length < 100) {
    toast(T('Prompt 內容太短，至少需要 100 字'), 'warning');
    return;
  }
  
  analyzeState.originalPrompt = prompt;
  
  // 顯示分析中
  const container = document.getElementById('analyze-content');
  container.innerHTML = `
    <div style="text-align:center;padding:60px 20px">
      <div class="typing-dot" style="display:inline-block"></div>
      <div class="typing-dot" style="display:inline-block"></div>
      <div class="typing-dot" style="display:inline-block"></div>
      <div style="margin-top:20px;font-size:15px;color:var(--text-secondary)">AI 正在深度分析你的 Prompt...</div>
      <div style="margin-top:8px;font-size:13px;color:var(--text-tertiary)">這可能需要 30-60 秒</div>
    </div>
  `;
  
  try {
    const preset = await db.apiPresets.filter(p => p.isActive).first();
    if (!preset) {
      toast(T('請先在設置中配置 API'), 'error');
      renderAnalyzeImport();
      return;
    }
    
    // 調用 AI 分析
    const response = await callAI(`你是一個專業的文游 Prompt 分析專家。請深度分析以下 Prompt，並給出詳細評估。

【待分析的 Prompt】
${prompt}

請按以下 JSON 格式返回分析結果：
\`\`\`json
{
  "overallScore": 0-100的整體評分,
  "overallComment": "整體評價（50字內）",
  "modules": {
    "worldview": {
      "score": 0-100,
      "found": true/false 是否找到相關內容,
      "content": "找到的相關內容摘要（50字內）",
      "issues": ["問題1", "問題2"],
      "suggestions": ["建議1", "建議2"]
    },
    "protagonist": {
      "score": 0-100,
      "found": true/false,
      "content": "摘要",
      "issues": [],
      "suggestions": []
    },
    "characters": {
      "score": 0-100,
      "found": true/false,
      "content": "摘要",
      "issues": [],
      "suggestions": []
    },
    "mechanics": {
      "score": 0-100,
      "found": true/false,
      "content": "摘要",
      "issues": [],
      "suggestions": []
    },
    "style": {
      "score": 0-100,
      "found": true/false,
      "content": "摘要",
      "issues": [],
      "suggestions": []
    },
    "aiRules": {
      "score": 0-100,
      "found": true/false,
      "content": "摘要",
      "issues": [],
      "suggestions": []
    }
  },
  "criticalIssues": ["最嚴重的問題1", "問題2"],
  "topSuggestions": ["最重要的建議1", "建議2", "建議3"]
}
\`\`\`

評分標準：
- 90-100：非常完善，幾乎沒有改進空間
- 70-89：良好，有小的改進空間
- 50-69：一般，有明顯不足
- 30-49：較差，缺失重要內容
- 0-29：很差，基本沒有相關內容

請嚴格按照 JSON 格式返回，不要有其他內容。`);
    
    // 解析結果
    const match = response.content.match(/```json\s*([\s\S]*?)\s*```/) || response.content.match(/\{[\s\S]*\}/);
    if (match) {
      const analysis = JSON.parse(match[1] || match[0]);
      analyzeState.analysis = analysis;
      renderAnalyzeResult();
    } else {
      throw new Error('無法解析 AI 返回的結果');
    }
  } catch (e) {
    toast('分析失敗: ' + e.message, 'error');
    renderAnalyzeImport();
  }
}

// 渲染分析結果
function renderAnalyzeResult() {
  const a = analyzeState.analysis;
  const container = document.getElementById('analyze-content');
  
  // 計算統計
  const charCount = analyzeState.originalPrompt.length;
  const lineCount = analyzeState.originalPrompt.split('\n').length;
  const issueCount = Object.values(a.modules).reduce((sum, m) => sum + (m.issues?.length || 0), 0);
  
  container.innerHTML = `
    <div class="analyze-stats">
      <div class="analyze-stat"><div class="analyze-stat-value">${charCount.toLocaleString()}</div><div class="analyze-stat-label">字數</div></div>
      <div class="analyze-stat"><div class="analyze-stat-value">${lineCount}</div><div class="analyze-stat-label">行數</div></div>
      <div class="analyze-stat"><div class="analyze-stat-value">${issueCount}</div><div class="analyze-stat-label">問題</div></div>
    </div>
    
    <div class="analyze-score">
      <div class="analyze-score-ring">
        <svg width="120" height="120" viewBox="0 0 120 120">
          <circle class="bg" cx="60" cy="60" r="52"/>
          <circle class="fill" cx="60" cy="60" r="52" 
            stroke-dasharray="${2 * Math.PI * 52}" 
            stroke-dashoffset="${2 * Math.PI * 52 * (1 - a.overallScore / 100)}"/>
        </svg>
        <div class="analyze-score-value">
          <div class="analyze-score-num">${a.overallScore}</div>
          <div class="analyze-score-label">總分</div>
        </div>
      </div>
      <div class="analyze-score-text">${a.overallComment || '分析完成'}</div>
    </div>
    
    <div class="wizard-section-title">📋 模塊評分</div>
    <div class="analyze-modules" id="analyze-modules">
      ${analyzeModules.map(m => {
        const data = a.modules[m.id] || { score: 0, found: false, issues: [], suggestions: [] };
        const scoreClass = data.score >= 70 ? 'high' : data.score >= 40 ? 'medium' : 'low';
        const statusIcon = data.score >= 70 ? '✅' : data.score >= 40 ? '⚠️' : '❌';
        const improved = analyzeState.moduleImprovements[m.id];
        return `
          <div class="analyze-module ${improved ? 'improved' : ''}" id="module-${m.id}">
            <div class="analyze-module-header" onclick="toggleAnalyzeModule('${m.id}')">
              <span class="analyze-module-icon">${m.icon}</span>
              <span class="analyze-module-name">${m.name}</span>
              <div class="analyze-module-score">
                <div class="analyze-module-bar"><div class="analyze-module-bar-fill ${scoreClass}" style="width:${data.score}%"></div></div>
                <span class="analyze-module-num">${data.score}</span>
                <span class="analyze-module-status">${improved ? '✨' : statusIcon}</span>
              </div>
            </div>
            <div class="analyze-module-body">
              ${data.found ? `<div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px;padding:10px;background:var(--bg-tertiary);border-radius:8px">${esc(data.content || '已找到相關內容')}</div>` : '<div style="font-size:13px;color:var(--warning);margin-bottom:12px">⚠️ 未找到相關內容</div>'}
              ${data.issues?.length ? `
                <div class="analyze-module-issues">
                  ${data.issues.map(issue => `
                    <div class="analyze-issue">
                      <span class="analyze-issue-icon">⚠️</span>
                      <span class="analyze-issue-text">${esc(issue)}</span>
                    </div>
                  `).join('')}
                </div>
              ` : ''}
              ${data.suggestions?.length ? `
                <div style="margin-bottom:12px">
                  <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:6px">💡 建議</div>
                  ${data.suggestions.map(s => `<div style="font-size:13px;color:var(--text-secondary);padding:4px 0">• ${esc(s)}</div>`).join('')}
                </div>
              ` : ''}
              ${improved ? `
                <div style="margin-bottom:12px;padding:10px;background:rgba(16,185,129,.1);border-radius:8px;border-left:3px solid var(--success)">
                  <div style="font-size:12px;color:var(--success);margin-bottom:6px">✨ 已改進</div>
                  <div style="font-size:13px;color:var(--text-secondary);white-space:pre-wrap;max-height:150px;overflow-y:auto">${esc(improved.slice(0, 500))}${improved.length > 500 ? '...' : ''}</div>
                </div>
              ` : ''}
              <div class="analyze-module-actions">
                <button class="analyze-module-btn ${improved ? '' : 'primary'}" onclick="improveModule('${m.id}')">
                  ${improved ? '🔄 重新生成' : '🤖 AI 完善'}
                </button>
                <button class="analyze-module-btn" onclick="editModule('${m.id}')">✏️ 手動編輯</button>
              </div>
            </div>
          </div>
        `;
      }).join('')}
    </div>
    
    ${a.criticalIssues?.length ? `
      <div class="analyze-suggestions" style="border-left-color:var(--error)">
        <div class="analyze-suggestions-title"><span>❌</span> 嚴重問題</div>
        <div class="analyze-suggestions-content">
          ${a.criticalIssues.map((issue, i) => `${i + 1}. ${esc(issue)}`).join('<br>')}
        </div>
      </div>
    ` : ''}
    
    <div class="analyze-suggestions">
      <div class="analyze-suggestions-title"><span>💡</span> AI 建議</div>
      <div class="analyze-suggestions-content">
        ${a.topSuggestions?.map((s, i) => `${i + 1}. ${esc(s)}`).join('<br>') || '暫無建議'}
      </div>
    </div>
    
    <div class="wizard-section-title" style="margin-top:24px">📤 導出選項</div>
    <div class="analyze-actions">
      <button class="wizard-btn secondary" onclick="showAnalyzeCompare()">📊 對比查看</button>
      <button class="wizard-btn secondary" onclick="previewImprovedPrompt()">👁️ 預覽改進版</button>
      <button class="wizard-btn secondary" onclick="exportAnalyzedPrompt('md')">📄 導出 MD</button>
      <button class="wizard-btn secondary" onclick="exportAnalyzedPrompt('txt')">📝 導出 TXT</button>
    </div>
    <button class="wizard-btn primary" style="width:100%;margin-top:12px" onclick="saveAnalyzedAsInstruction()">💾 保存為指令</button>
    
    <div class="analyze-chat">
      <div class="wizard-section-title">💬 對話討論</div>
      <div class="wizard-section-desc">有疑問？和 AI 討論具體問題。</div>
      <div class="wizard-chat" id="analyze-chat-list">
        ${analyzeState.chatHistory.map(m => `
          <div class="wizard-chat-msg ${m.role}">${marked.parse(m.content)}</div>
        `).join('')}
      </div>
      <div class="wizard-chat-input">
        <input class="wizard-chat-field" id="analyze-chat-input" placeholder="詢問 AI 關於 Prompt 的問題..." onkeypress="if(event.key==='Enter')sendAnalyzeChat()">
        <button class="wizard-chat-send" onclick="sendAnalyzeChat()">➤</button>
      </div>
    </div>
  `;
}

// 切換模塊展開
function toggleAnalyzeModule(id) {
  const module = document.getElementById('module-' + id);
  if (module) {
    module.classList.toggle('expanded');
  }
}

// AI 完善單個模塊
async function improveModule(moduleId) {
  const module = analyzeModules.find(m => m.id === moduleId);
  if (!module) return;
  
  toast(`AI 正在完善 ${module.name}...`, 'info');
  
  try {
    const a = analyzeState.analysis;
    const moduleData = a.modules[moduleId] || {};
    
    const response = await callAI(`你是一個專業的文游 Prompt 寫作專家。

【原始 Prompt】
${analyzeState.originalPrompt}

【當前模塊】${module.name}
【現有內容】${moduleData.content || '無'}
【發現的問題】${moduleData.issues?.join('、') || '無'}
【改進建議】${moduleData.suggestions?.join('、') || '無'}

請為這個模塊生成改進後的內容。要求：
1. 保持與原 Prompt 風格一致
2. 解決發現的問題
3. 採納建議進行優化
4. 內容要具體、可用

直接輸出改進後的內容，不要有其他解釋。輸出格式保持 Markdown。`);
    
    analyzeState.moduleImprovements[moduleId] = response.content;
    toast(`${module.name} 已完善`, 'success');
    renderAnalyzeResult();
    
    // 展開這個模塊
    setTimeout(() => {
      const el = document.getElementById('module-' + moduleId);
      if (el) el.classList.add('expanded');
    }, 100);
  } catch (e) {
    toast('完善失敗: ' + e.message, 'error');
  }
}

// 手動編輯模塊
function editModule(moduleId) {
  const module = analyzeModules.find(m => m.id === moduleId);
  if (!module) return;
  
  const current = analyzeState.moduleImprovements[moduleId] || '';
  const moduleData = analyzeState.analysis?.modules[moduleId] || {};
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.cssText = 'max-width:90%;max-height:80vh;';
  modal.innerHTML = `
    <div class="modal-title">✏️ 編輯 ${module.name}</div>
    <div style="font-size:13px;color:var(--text-secondary);margin-bottom:12px">
      ${moduleData.suggestions?.length ? '💡 AI 建議：' + moduleData.suggestions.join('；') : ''}
    </div>
    <textarea class="form-input" id="edit-module-text" style="min-height:40vh;font-family:monospace;font-size:13px;line-height:1.6">${esc(current)}</textarea>
    <div class="modal-actions">
      <button class="modal-btn cancel" onclick="this.closest('.modal').remove();document.getElementById('overlay').classList.remove('active')">取消</button>
      <button class="modal-btn confirm" onclick="saveModuleEdit('${moduleId}')">保存</button>
    </div>
  `;
  document.getElementById('overlay').classList.add('active');
  document.body.appendChild(modal);
}

function saveModuleEdit(moduleId) {
  const text = document.getElementById('edit-module-text').value.trim();
  if (text) {
    analyzeState.moduleImprovements[moduleId] = text;
  } else {
    delete analyzeState.moduleImprovements[moduleId];
  }
  document.querySelector('.modal')?.remove();
  document.getElementById('overlay').classList.remove('active');
  toast(T('已保存'), 'success');
  renderAnalyzeResult();
}

// 生成改進後的 Prompt
function generateImprovedPrompt() {
  let improved = analyzeState.originalPrompt;
  
  // 如果有模塊改進，附加到末尾
  const improvements = Object.entries(analyzeState.moduleImprovements);
  if (improvements.length > 0) {
    improved += '\n\n---\n\n# 補充與改進\n\n';
    improvements.forEach(([id, content]) => {
      const module = analyzeModules.find(m => m.id === id);
      improved += `## ${module?.icon || '📝'} ${module?.name || id}\n\n${content}\n\n`;
    });
  }
  
  analyzeState.improvedPrompt = improved;
  return improved;
}

// 顯示對比
function showAnalyzeCompare() {
  const improved = generateImprovedPrompt();
  const original = analyzeState.originalPrompt;
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.cssText = 'max-width:95%;max-height:85vh;width:800px;';
  modal.innerHTML = `
    <div class="modal-title">📊 原版 vs 改進版對比</div>
    <div class="analyze-compare" style="max-height:60vh">
      <div class="analyze-compare-col">
        <div class="analyze-compare-title">📄 原版 (${original.length} 字)</div>
        <div class="analyze-compare-content">${esc(original)}</div>
      </div>
      <div class="analyze-compare-col">
        <div class="analyze-compare-title">✨ 改進版 (${improved.length} 字)</div>
        <div class="analyze-compare-content">${esc(improved)}</div>
      </div>
    </div>
    <div style="margin-top:12px;font-size:13px;color:var(--text-secondary)">
      ${Object.keys(analyzeState.moduleImprovements).length > 0 
        ? `✅ 已改進 ${Object.keys(analyzeState.moduleImprovements).length} 個模塊` 
        : '⚠️ 尚未進行任何改進'}
    </div>
    <div class="modal-actions">
      <button class="modal-btn confirm" onclick="this.closest('.modal').remove();document.getElementById('overlay').classList.remove('active')">關閉</button>
    </div>
  `;
  document.getElementById('overlay').classList.add('active');
  document.body.appendChild(modal);
}

// 預覽改進版
function previewImprovedPrompt() {
  const improved = generateImprovedPrompt();
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.style.cssText = 'max-width:90%;max-height:80vh;';
  modal.innerHTML = `
    <div class="modal-title">👁️ 改進版預覽</div>
    <div style="font-size:13px;color:var(--text-tertiary);margin-bottom:12px">${improved.length.toLocaleString()} 字</div>
    <div style="background:var(--bg-tertiary);border-radius:8px;padding:12px;max-height:50vh;overflow-y:auto;font-size:13px;line-height:1.7;white-space:pre-wrap;font-family:monospace">${esc(improved)}</div>
    <div class="modal-actions">
      <button class="modal-btn cancel" onclick="this.closest('.modal').remove();document.getElementById('overlay').classList.remove('active')">關閉</button>
      <button class="modal-btn confirm" onclick="copyImprovedPrompt()">📋 複製</button>
    </div>
  `;
  document.getElementById('overlay').classList.add('active');
  document.body.appendChild(modal);
}

async function copyImprovedPrompt() {
  const improved = generateImprovedPrompt();
  try {
    await navigator.clipboard.writeText(improved);
    toast(T('已複製到剪貼板'), 'success');
  } catch (e) {
    toast(T('複製失敗'), 'error');
  }
}

// 導出
function exportAnalyzedPrompt(format) {
  const improved = generateImprovedPrompt();
  const filename = `Prompt分析改進版_${Date.now()}`;
  
  if (format === 'md') {
    downloadFile(improved, filename + '.md', 'text/markdown');
  } else {
    downloadFile(improved, filename + '.txt', 'text/plain');
  }
  toast(T('已導出'), 'success');
}

// 保存為指令
async function saveAnalyzedAsInstruction() {
  const improved = generateImprovedPrompt();
  
  const inst = {
    id: crypto.randomUUID(),
    name: '分析改進版 - ' + new Date().toLocaleDateString(),
    icon: '✨',
    systemPrompt: improved,
    createdAt: Date.now()
  };
  
  await db.instructions.put(inst);
  toast(T('已保存為指令！'), 'success');
  goTo('view-instructions');
  await renderInst();
}

// 對話討論
async function sendAnalyzeChat() {
  const input = document.getElementById('analyze-chat-input');
  const msg = input.value.trim();
  if (!msg) return;
  
  input.value = '';
  analyzeState.chatHistory.push({ role: 'user', content: msg });
  renderAnalyzeResult();
  
  try {
    const response = await callAI(`你是 Prompt 分析專家。用戶正在分析以下 Prompt：

【原始 Prompt 摘要】
${analyzeState.originalPrompt.slice(0, 2000)}...

【分析結果】
總分：${analyzeState.analysis?.overallScore || '未知'}
主要問題：${analyzeState.analysis?.criticalIssues?.join('、') || '無'}

【用戶問題】
${msg}

請針對用戶的問題給出專業、具體的回答。回覆要簡潔實用。`);
    
    analyzeState.chatHistory.push({ role: 'ai', content: response.content });
    renderAnalyzeResult();
    
    // 滾動到底部
    setTimeout(() => {
      const chatList = document.getElementById('analyze-chat-list');
      if (chatList) chatList.scrollTop = chatList.scrollHeight;
    }, 100);
  } catch (e) {
    toast('回覆失敗: ' + e.message, 'error');
  }
}

</script>
</body>
</html>
